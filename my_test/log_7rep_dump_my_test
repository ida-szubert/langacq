['SemLearn.py', 'i_n', '-', '7']
build or check is  i_n
Number of possible LFs in training:7
testout =  None
put in sent coutn =  0
K k=-0.8
making  lambda $0_{ev}.Q(and(aux|will&COND(v|do(pro:dem|that,$0),$0),adv|as_well($0)),$0)
making  Q(and(aux|will&COND(v|do(pro:dem|that,$0),$0),adv|as_well($0)),$0)
making  and(aux|will&COND(v|do(pro:dem|that,$0),$0),adv|as_well($0)),$0)
making  aux|will&COND(v|do(pro:dem|that,$0),$0)
making  v|do(pro:dem|that,$0)
making  pro:dem|that
making  $0
making  $0
making  adv|as_well($0)
making  $0
making  $0)
Is Q
sentence is  more juice ?
making  lambda $0_{ev}.adv:loc|here($0)
making  adv:loc|here($0)
making  $0
sentence is  more juice ?
making  lambda $0_{ev}.v|go(pro|you,$0)
making  v|go(pro|you,$0)
making  pro|you
making  $0
sentence is  more juice ?
making  lambda $0_{ev}.Q(qn|more($1,n|juice($1)),$0)
making  Q(qn|more($1,n|juice($1)),$0)
making  qn|more($1,n|juice($1)),$0)
making  n|juice($1)
making  $1
making  $0)
Is Q
sentence is  more juice ?
making  lambda $0_{e}.eqLoc(pro:poss:det|your($1,n|cup($1)),$0)
making  eqLoc(pro:poss:det|your($1,n|cup($1)),$0)
making  pro:poss:det|your($1,n|cup($1)),$0)
making  n|cup($1)
making  $1
making  $0)
sentence is  more juice ?
making  lambda $0_{ev}.v|take&PAST(pro|I,pro|it,$0)
making  v|take&PAST(pro|I,pro|it,$0)
making  pro|I
making  pro|it
making  $0
sentence is  more juice ?
making  lambda $0_{ev}.not(adj|sure(pro|I),$0)
making  not(adj|sure(pro|I),$0)
making  adj|sure(pro|I),$0)
making  pro|I
making  $0)
sentence is  more juice ?

got training pair
Sent : more juice ?
Cat : Syn:lambda $0_{ev}.Q(and(aux|will&COND(v|do(pro:dem|that,$0),$0),adv|as_well($0)),$0)
Cat : S:lambda $0_{ev}.adv:loc|here($0)
Cat : S:lambda $0_{ev}.v|go(pro|you,$0)
Cat : Syn:lambda $0_{ev}.Q(qn|more($1,n|juice($1)),$0)
Cat : Swh:lambda $0_{e}.eqLoc(pro:poss:det|your($1,n|cup($1)),$0)
Cat : S:lambda $0_{ev}.v|take&PAST(pro|I,pro|it,$0)
Cat : S:lambda $0_{ev}.not(adj|sure(pro|I),$0)
sentence is  ['more', 'juice']
sem is  lambda $0_{ev}.Q(and(aux|will&COND(v|do(pro:dem|that,$0),$0),adv|as_well($0)),$0)
adding  Syn  to START
sem is  lambda $0_{ev}.adv:loc|here($0)
adding  S  to START
sem is  lambda $0_{ev}.v|go(pro|you,$0)
sem is  lambda $0_{ev}.Q(qn|more($1,n|juice($1)),$0)
sem is  lambda $0_{e}.eqLoc(pro:poss:det|your($1,n|cup($1)),$0)
adding  Swh  to START
types dont match 2 :  (Swh/NP):lambda $0_{e}.lambda $1_{e}.eqLoc($0,$1)   <e,<e,<ev,t>>>   <e,<e,t>>  comp is  False 

(Swh/NP):lambda $0_{e}.lambda $1_{e}.eqLoc($0,$1) NP:pro:poss:det|your($0,n|cup($0))
NOT ADDING THIS
types dont match 3 :  (Swh\NP):lambda $0_{e}.lambda $1_{e}.eqLoc($0,$1)   <e,<e,<ev,t>>>   <e,<e,t>>  comp is  False 

NOT ADDING THIS
types dont match 2 :  (Swh/N):lambda $0_{<e,t>}.lambda $1_{e}.eqLoc(pro:poss:det|your($2,$0($2)),$1)   <<e,t>,<e,<ev,t>>>   <<e,t>,<e,t>>  comp is  False 

(Swh/N):lambda $0_{<e,t>}.lambda $1_{e}.eqLoc(pro:poss:det|your($2,$0($2)),$1) N:lambda $0_{e}.n|cup($0)
NOT ADDING THIS
types dont match 3 :  (Swh\N):lambda $0_{<e,t>}.lambda $1_{e}.eqLoc(pro:poss:det|your($2,$0($2)),$1)   <<e,t>,<e,<ev,t>>>   <<e,t>,<e,t>>  comp is  False 

NOT ADDING THIS
sem is  lambda $0_{ev}.v|take&PAST(pro|I,pro|it,$0)
sem is  lambda $0_{ev}.not(adj|sure(pro|I),$0)
size of chart is  77
got chart
norm score is  -16.241636697
doing updates with learning rate  0.043047096028
Deleting 0 entries of the total 71
done io
WATCH	more juice ?
getting topparses
outputting cat probs
done with sent


making  lambda $0_{ev}.adv:loc|here($0)
making  adv:loc|here($0)
making  $0
sentence is  where 's your cup ?
making  lambda $0_{ev}.v|go(pro|you,$0)
making  v|go(pro|you,$0)
making  pro|you
making  $0
sentence is  where 's your cup ?
making  lambda $0_{ev}.Q(qn|more($1,n|juice($1)),$0)
making  Q(qn|more($1,n|juice($1)),$0)
making  qn|more($1,n|juice($1)),$0)
making  n|juice($1)
making  $1
making  $0)
Is Q
sentence is  where 's your cup ?
making  lambda $0_{e}.eqLoc(pro:poss:det|your($1,n|cup($1)),$0)
making  eqLoc(pro:poss:det|your($1,n|cup($1)),$0)
making  pro:poss:det|your($1,n|cup($1)),$0)
making  n|cup($1)
making  $1
making  $0)
sentence is  where 's your cup ?
making  lambda $0_{ev}.v|take&PAST(pro|I,pro|it,$0)
making  v|take&PAST(pro|I,pro|it,$0)
making  pro|I
making  pro|it
making  $0
sentence is  where 's your cup ?
making  lambda $0_{ev}.not(adj|sure(pro|I),$0)
making  not(adj|sure(pro|I),$0)
making  adj|sure(pro|I),$0)
making  pro|I
making  $0)
sentence is  where 's your cup ?
making  lambda $0_{ev}.Q(aux|be&PRES(part|say-PROG(pro|you,n:prop|Fraser,$0),$0),$0)
making  Q(aux|be&PRES(part|say-PROG(pro|you,n:prop|Fraser,$0),$0),$0)
making  aux|be&PRES(part|say-PROG(pro|you,n:prop|Fraser,$0),$0),$0)
making  part|say-PROG(pro|you,n:prop|Fraser,$0)
making  pro|you
making  n:prop|Fraser
making  $0
making  $0
making  $0)
Is Q
sentence is  where 's your cup ?

got training pair
Sent : where 's your cup ?
Cat : S:lambda $0_{ev}.adv:loc|here($0)
Cat : S:lambda $0_{ev}.v|go(pro|you,$0)
Cat : Syn:lambda $0_{ev}.Q(qn|more($1,n|juice($1)),$0)
Cat : Swh:lambda $0_{e}.eqLoc(pro:poss:det|your($1,n|cup($1)),$0)
Cat : S:lambda $0_{ev}.v|take&PAST(pro|I,pro|it,$0)
Cat : S:lambda $0_{ev}.not(adj|sure(pro|I),$0)
Cat : Syn:lambda $0_{ev}.Q(aux|be&PRES(part|say-PROG(pro|you,n:prop|Fraser,$0),$0),$0)
sentence is  ['where', "'s", 'your', 'cup', '?']
sem is  lambda $0_{ev}.adv:loc|here($0)
sem is  lambda $0_{ev}.v|go(pro|you,$0)
sem is  lambda $0_{ev}.Q(qn|more($1,n|juice($1)),$0)
sem is  lambda $0_{e}.eqLoc(pro:poss:det|your($1,n|cup($1)),$0)
types dont match 2 :  (Swh/NP):lambda $0_{e}.lambda $1_{e}.eqLoc($0,$1)   <e,<e,<ev,t>>>   <e,<e,t>>  comp is  False 

(Swh/NP):lambda $0_{e}.lambda $1_{e}.eqLoc($0,$1) NP:pro:poss:det|your($0,n|cup($0))
NOT ADDING THIS
types dont match 3 :  (Swh\NP):lambda $0_{e}.lambda $1_{e}.eqLoc($0,$1)   <e,<e,<ev,t>>>   <e,<e,t>>  comp is  False 

NOT ADDING THIS
types dont match 2 :  (Swh/N):lambda $0_{<e,t>}.lambda $1_{e}.eqLoc(pro:poss:det|your($2,$0($2)),$1)   <<e,t>,<e,<ev,t>>>   <<e,t>,<e,t>>  comp is  False 

(Swh/N):lambda $0_{<e,t>}.lambda $1_{e}.eqLoc(pro:poss:det|your($2,$0($2)),$1) N:lambda $0_{e}.n|cup($0)
NOT ADDING THIS
types dont match 3 :  (Swh\N):lambda $0_{<e,t>}.lambda $1_{e}.eqLoc(pro:poss:det|your($2,$0($2)),$1)   <<e,t>,<e,<ev,t>>>   <<e,t>,<e,t>>  comp is  False 

NOT ADDING THIS
sem is  lambda $0_{ev}.v|take&PAST(pro|I,pro|it,$0)
sem is  lambda $0_{ev}.not(adj|sure(pro|I),$0)
sem is  lambda $0_{ev}.Q(aux|be&PRES(part|say-PROG(pro|you,n:prop|Fraser,$0),$0),$0)
size of chart is  1489
got chart
norm score is  -40.199103263
doing updates with learning rate  0.0423835495277
Deleting 0 entries of the total 971
done io
WATCH	where 's your cup ?
WATCH	2	((S\NP)\NP)	0.466565534393
WATCH	2	((S\NP)/NP)	0.0334344656068
WATCH	2	((S/NP)/NP)	0.466565534393
WATCH	2	((S/NP)\NP)	0.0334344656068
getting topparses
outputting cat probs
done with sent


making  lambda $0_{ev}.v|go(pro|you,$0)
making  v|go(pro|you,$0)
making  pro|you
making  $0
sentence is  I took it .
making  lambda $0_{ev}.Q(qn|more($1,n|juice($1)),$0)
making  Q(qn|more($1,n|juice($1)),$0)
making  qn|more($1,n|juice($1)),$0)
making  n|juice($1)
making  $1
making  $0)
Is Q
sentence is  I took it .
making  lambda $0_{e}.eqLoc(pro:poss:det|your($1,n|cup($1)),$0)
making  eqLoc(pro:poss:det|your($1,n|cup($1)),$0)
making  pro:poss:det|your($1,n|cup($1)),$0)
making  n|cup($1)
making  $1
making  $0)
sentence is  I took it .
making  lambda $0_{ev}.v|take&PAST(pro|I,pro|it,$0)
making  v|take&PAST(pro|I,pro|it,$0)
making  pro|I
making  pro|it
making  $0
sentence is  I took it .
making  lambda $0_{ev}.not(adj|sure(pro|I),$0)
making  not(adj|sure(pro|I),$0)
making  adj|sure(pro|I),$0)
making  pro|I
making  $0)
sentence is  I took it .
making  lambda $0_{ev}.Q(aux|be&PRES(part|say-PROG(pro|you,n:prop|Fraser,$0),$0),$0)
making  Q(aux|be&PRES(part|say-PROG(pro|you,n:prop|Fraser,$0),$0),$0)
making  aux|be&PRES(part|say-PROG(pro|you,n:prop|Fraser,$0),$0),$0)
making  part|say-PROG(pro|you,n:prop|Fraser,$0)
making  pro|you
making  n:prop|Fraser
making  $0
making  $0
making  $0)
Is Q
sentence is  I took it .
making  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  eq($0,pro:dem|that,$1)
making  $0,pro:dem|that,$1)
making  pro:dem|that,$1)
making  $1)
sentence is  I took it .

got training pair
Sent : I took it .
Cat : S:lambda $0_{ev}.v|go(pro|you,$0)
Cat : Syn:lambda $0_{ev}.Q(qn|more($1,n|juice($1)),$0)
Cat : Swh:lambda $0_{e}.eqLoc(pro:poss:det|your($1,n|cup($1)),$0)
Cat : S:lambda $0_{ev}.v|take&PAST(pro|I,pro|it,$0)
Cat : S:lambda $0_{ev}.not(adj|sure(pro|I),$0)
Cat : Syn:lambda $0_{ev}.Q(aux|be&PRES(part|say-PROG(pro|you,n:prop|Fraser,$0),$0),$0)
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
sentence is  ['I', 'took', 'it']
sem is  lambda $0_{ev}.v|go(pro|you,$0)
sem is  lambda $0_{ev}.Q(qn|more($1,n|juice($1)),$0)
sem is  lambda $0_{e}.eqLoc(pro:poss:det|your($1,n|cup($1)),$0)
types dont match 2 :  (Swh/NP):lambda $0_{e}.lambda $1_{e}.eqLoc($0,$1)   <e,<e,<ev,t>>>   <e,<e,t>>  comp is  False 

(Swh/NP):lambda $0_{e}.lambda $1_{e}.eqLoc($0,$1) NP:pro:poss:det|your($0,n|cup($0))
NOT ADDING THIS
types dont match 3 :  (Swh\NP):lambda $0_{e}.lambda $1_{e}.eqLoc($0,$1)   <e,<e,<ev,t>>>   <e,<e,t>>  comp is  False 

NOT ADDING THIS
types dont match 2 :  (Swh/N):lambda $0_{<e,t>}.lambda $1_{e}.eqLoc(pro:poss:det|your($2,$0($2)),$1)   <<e,t>,<e,<ev,t>>>   <<e,t>,<e,t>>  comp is  False 

(Swh/N):lambda $0_{<e,t>}.lambda $1_{e}.eqLoc(pro:poss:det|your($2,$0($2)),$1) N:lambda $0_{e}.n|cup($0)
NOT ADDING THIS
types dont match 3 :  (Swh\N):lambda $0_{<e,t>}.lambda $1_{e}.eqLoc(pro:poss:det|your($2,$0($2)),$1)   <<e,t>,<e,<ev,t>>>   <<e,t>,<e,t>>  comp is  False 

NOT ADDING THIS
sem is  lambda $0_{ev}.v|take&PAST(pro|I,pro|it,$0)
sem is  lambda $0_{ev}.not(adj|sure(pro|I),$0)
sem is  lambda $0_{ev}.Q(aux|be&PRES(part|say-PROG(pro|you,n:prop|Fraser,$0),$0),$0)
sem is  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
size of chart is  322
got chart
norm score is  -22.9654742707
doing updates with learning rate  0.0417425815524
Deleting 0 entries of the total 1209
done io
WATCH	I took it .
WATCH	3	((S\NP)\NP)	0.491033972956
WATCH	3	((S\NP)/NP)	0.0089660270439
WATCH	3	((S/NP)/NP)	0.491033972956
WATCH	3	((S/NP)\NP)	0.0089660270439
getting topparses
outputting cat probs
done with sent


making  lambda $0_{ev}.Q(qn|more($1,n|juice($1)),$0)
making  Q(qn|more($1,n|juice($1)),$0)
making  qn|more($1,n|juice($1)),$0)
making  n|juice($1)
making  $1
making  $0)
Is Q
sentence is  I 'm not sure .
making  lambda $0_{e}.eqLoc(pro:poss:det|your($1,n|cup($1)),$0)
making  eqLoc(pro:poss:det|your($1,n|cup($1)),$0)
making  pro:poss:det|your($1,n|cup($1)),$0)
making  n|cup($1)
making  $1
making  $0)
sentence is  I 'm not sure .
making  lambda $0_{ev}.v|take&PAST(pro|I,pro|it,$0)
making  v|take&PAST(pro|I,pro|it,$0)
making  pro|I
making  pro|it
making  $0
sentence is  I 'm not sure .
making  lambda $0_{ev}.not(adj|sure(pro|I),$0)
making  not(adj|sure(pro|I),$0)
making  adj|sure(pro|I),$0)
making  pro|I
making  $0)
sentence is  I 'm not sure .
making  lambda $0_{ev}.Q(aux|be&PRES(part|say-PROG(pro|you,n:prop|Fraser,$0),$0),$0)
making  Q(aux|be&PRES(part|say-PROG(pro|you,n:prop|Fraser,$0),$0),$0)
making  aux|be&PRES(part|say-PROG(pro|you,n:prop|Fraser,$0),$0),$0)
making  part|say-PROG(pro|you,n:prop|Fraser,$0)
making  pro|you
making  n:prop|Fraser
making  $0
making  $0
making  $0)
Is Q
sentence is  I 'm not sure .
making  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  eq($0,pro:dem|that,$1)
making  $0,pro:dem|that,$1)
making  pro:dem|that,$1)
making  $1)
sentence is  I 'm not sure .
making  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  eq($0,pro:dem|that,$1)
making  $0,pro:dem|that,$1)
making  pro:dem|that,$1)
making  $1)
sentence is  I 'm not sure .

got training pair
Sent : I 'm not sure .
Cat : Syn:lambda $0_{ev}.Q(qn|more($1,n|juice($1)),$0)
Cat : Swh:lambda $0_{e}.eqLoc(pro:poss:det|your($1,n|cup($1)),$0)
Cat : S:lambda $0_{ev}.v|take&PAST(pro|I,pro|it,$0)
Cat : S:lambda $0_{ev}.not(adj|sure(pro|I),$0)
Cat : Syn:lambda $0_{ev}.Q(aux|be&PRES(part|say-PROG(pro|you,n:prop|Fraser,$0),$0),$0)
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
sentence is  ['I', "'m", 'not', 'sure']
sem is  lambda $0_{ev}.Q(qn|more($1,n|juice($1)),$0)
sem is  lambda $0_{e}.eqLoc(pro:poss:det|your($1,n|cup($1)),$0)
types dont match 2 :  (Swh/NP):lambda $0_{e}.lambda $1_{e}.eqLoc($0,$1)   <e,<e,<ev,t>>>   <e,<e,t>>  comp is  False 

(Swh/NP):lambda $0_{e}.lambda $1_{e}.eqLoc($0,$1) NP:pro:poss:det|your($0,n|cup($0))
NOT ADDING THIS
types dont match 3 :  (Swh\NP):lambda $0_{e}.lambda $1_{e}.eqLoc($0,$1)   <e,<e,<ev,t>>>   <e,<e,t>>  comp is  False 

NOT ADDING THIS
types dont match 2 :  (Swh/N):lambda $0_{<e,t>}.lambda $1_{e}.eqLoc(pro:poss:det|your($2,$0($2)),$1)   <<e,t>,<e,<ev,t>>>   <<e,t>,<e,t>>  comp is  False 

(Swh/N):lambda $0_{<e,t>}.lambda $1_{e}.eqLoc(pro:poss:det|your($2,$0($2)),$1) N:lambda $0_{e}.n|cup($0)
NOT ADDING THIS
types dont match 3 :  (Swh\N):lambda $0_{<e,t>}.lambda $1_{e}.eqLoc(pro:poss:det|your($2,$0($2)),$1)   <<e,t>,<e,<ev,t>>>   <<e,t>,<e,t>>  comp is  False 

NOT ADDING THIS
sem is  lambda $0_{ev}.v|take&PAST(pro|I,pro|it,$0)
sem is  lambda $0_{ev}.not(adj|sure(pro|I),$0)
sem is  lambda $0_{ev}.Q(aux|be&PRES(part|say-PROG(pro|you,n:prop|Fraser,$0),$0),$0)
sem is  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
sem is  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
size of chart is  810
got chart
norm score is  -31.2124210786
doing updates with learning rate  0.0411230191652
Deleting 0 entries of the total 1672
done io
WATCH	I 'm not sure .
WATCH	4	((S\NP)\NP)	0.57315954195
WATCH	4	((S\NP)/NP)	0.00618645942652
WATCH	4	((S/NP)/NP)	0.416222686539
WATCH	4	((S/NP)\NP)	0.00443131208447
getting topparses
outputting cat probs
done with sent


making  lambda $0_{e}.eqLoc(pro:poss:det|your($1,n|cup($1)),$0)
making  eqLoc(pro:poss:det|your($1,n|cup($1)),$0)
making  pro:poss:det|your($1,n|cup($1)),$0)
making  n|cup($1)
making  $1
making  $0)
sentence is  are you saying Fraser ?
making  lambda $0_{ev}.v|take&PAST(pro|I,pro|it,$0)
making  v|take&PAST(pro|I,pro|it,$0)
making  pro|I
making  pro|it
making  $0
sentence is  are you saying Fraser ?
making  lambda $0_{ev}.not(adj|sure(pro|I),$0)
making  not(adj|sure(pro|I),$0)
making  adj|sure(pro|I),$0)
making  pro|I
making  $0)
sentence is  are you saying Fraser ?
making  lambda $0_{ev}.Q(aux|be&PRES(part|say-PROG(pro|you,n:prop|Fraser,$0),$0),$0)
making  Q(aux|be&PRES(part|say-PROG(pro|you,n:prop|Fraser,$0),$0),$0)
making  aux|be&PRES(part|say-PROG(pro|you,n:prop|Fraser,$0),$0),$0)
making  part|say-PROG(pro|you,n:prop|Fraser,$0)
making  pro|you
making  n:prop|Fraser
making  $0
making  $0
making  $0)
Is Q
sentence is  are you saying Fraser ?
making  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  eq($0,pro:dem|that,$1)
making  $0,pro:dem|that,$1)
making  pro:dem|that,$1)
making  $1)
sentence is  are you saying Fraser ?
making  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  eq($0,pro:dem|that,$1)
making  $0,pro:dem|that,$1)
making  pro:dem|that,$1)
making  $1)
sentence is  are you saying Fraser ?
making  det|a($0,n|fly($0))
making  n|fly($0)
making  $0
sentence is  are you saying Fraser ?

got training pair
Sent : are you saying Fraser ?
Cat : Swh:lambda $0_{e}.eqLoc(pro:poss:det|your($1,n|cup($1)),$0)
Cat : S:lambda $0_{ev}.v|take&PAST(pro|I,pro|it,$0)
Cat : S:lambda $0_{ev}.not(adj|sure(pro|I),$0)
Cat : Syn:lambda $0_{ev}.Q(aux|be&PRES(part|say-PROG(pro|you,n:prop|Fraser,$0),$0),$0)
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
Cat : NP:det|a($0,n|fly($0))
sentence is  ['are', 'you', 'saying', 'Fraser']
sem is  lambda $0_{e}.eqLoc(pro:poss:det|your($1,n|cup($1)),$0)
types dont match 2 :  (Swh/NP):lambda $0_{e}.lambda $1_{e}.eqLoc($0,$1)   <e,<e,<ev,t>>>   <e,<e,t>>  comp is  False 

(Swh/NP):lambda $0_{e}.lambda $1_{e}.eqLoc($0,$1) NP:pro:poss:det|your($0,n|cup($0))
NOT ADDING THIS
types dont match 3 :  (Swh\NP):lambda $0_{e}.lambda $1_{e}.eqLoc($0,$1)   <e,<e,<ev,t>>>   <e,<e,t>>  comp is  False 

NOT ADDING THIS
types dont match 2 :  (Swh/N):lambda $0_{<e,t>}.lambda $1_{e}.eqLoc(pro:poss:det|your($2,$0($2)),$1)   <<e,t>,<e,<ev,t>>>   <<e,t>,<e,t>>  comp is  False 

(Swh/N):lambda $0_{<e,t>}.lambda $1_{e}.eqLoc(pro:poss:det|your($2,$0($2)),$1) N:lambda $0_{e}.n|cup($0)
NOT ADDING THIS
types dont match 3 :  (Swh\N):lambda $0_{<e,t>}.lambda $1_{e}.eqLoc(pro:poss:det|your($2,$0($2)),$1)   <<e,t>,<e,<ev,t>>>   <<e,t>,<e,t>>  comp is  False 

NOT ADDING THIS
sem is  lambda $0_{ev}.v|take&PAST(pro|I,pro|it,$0)
sem is  lambda $0_{ev}.not(adj|sure(pro|I),$0)
sem is  lambda $0_{ev}.Q(aux|be&PRES(part|say-PROG(pro|you,n:prop|Fraser,$0),$0),$0)
sem is  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
sem is  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
sem is  det|a($0,n|fly($0))
adding  NP  to START
size of chart is  763
got chart
norm score is  -41.4128312577
doing updates with learning rate  0.0405237706188
Deleting 0 entries of the total 2154
done io
WATCH	are you saying Fraser ?
WATCH	5	((S\NP)\NP)	0.57860570574
WATCH	5	((S\NP)/NP)	0.00522833809908
WATCH	5	((S/NP)/NP)	0.412451880803
WATCH	5	((S/NP)\NP)	0.0037140753583
getting topparses
outputting cat probs
done with sent


making  lambda $0_{ev}.v|take&PAST(pro|I,pro|it,$0)
making  v|take&PAST(pro|I,pro|it,$0)
making  pro|I
making  pro|it
making  $0
sentence is  what is that ?
making  lambda $0_{ev}.not(adj|sure(pro|I),$0)
making  not(adj|sure(pro|I),$0)
making  adj|sure(pro|I),$0)
making  pro|I
making  $0)
sentence is  what is that ?
making  lambda $0_{ev}.Q(aux|be&PRES(part|say-PROG(pro|you,n:prop|Fraser,$0),$0),$0)
making  Q(aux|be&PRES(part|say-PROG(pro|you,n:prop|Fraser,$0),$0),$0)
making  aux|be&PRES(part|say-PROG(pro|you,n:prop|Fraser,$0),$0),$0)
making  part|say-PROG(pro|you,n:prop|Fraser,$0)
making  pro|you
making  n:prop|Fraser
making  $0
making  $0
making  $0)
Is Q
sentence is  what is that ?
making  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  eq($0,pro:dem|that,$1)
making  $0,pro:dem|that,$1)
making  pro:dem|that,$1)
making  $1)
sentence is  what is that ?
making  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  eq($0,pro:dem|that,$1)
making  $0,pro:dem|that,$1)
making  pro:dem|that,$1)
making  $1)
sentence is  what is that ?
making  det|a($0,n|fly($0))
making  n|fly($0)
making  $0
sentence is  what is that ?
making  lambda $0_{ev}.v|get(pro|you,det|a($1,n|fly($1)),$0)
making  v|get(pro|you,det|a($1,n|fly($1)),$0)
making  pro|you
making  det|a($1,n|fly($1))
making  n|fly($1)
making  $1
making  $0
sentence is  what is that ?

got training pair
Sent : what is that ?
Cat : S:lambda $0_{ev}.v|take&PAST(pro|I,pro|it,$0)
Cat : S:lambda $0_{ev}.not(adj|sure(pro|I),$0)
Cat : Syn:lambda $0_{ev}.Q(aux|be&PRES(part|say-PROG(pro|you,n:prop|Fraser,$0),$0),$0)
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
Cat : NP:det|a($0,n|fly($0))
Cat : S:lambda $0_{ev}.v|get(pro|you,det|a($1,n|fly($1)),$0)
sentence is  ['what', 'is', 'that']
sem is  lambda $0_{ev}.v|take&PAST(pro|I,pro|it,$0)
sem is  lambda $0_{ev}.not(adj|sure(pro|I),$0)
sem is  lambda $0_{ev}.Q(aux|be&PRES(part|say-PROG(pro|you,n:prop|Fraser,$0),$0),$0)
sem is  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
sem is  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
sem is  det|a($0,n|fly($0))
sem is  lambda $0_{ev}.v|get(pro|you,det|a($1,n|fly($1)),$0)
size of chart is  296
got chart
norm score is  -23.5944811833
doing updates with learning rate  0.0399438183829
Deleting 0 entries of the total 2384
done io
WATCH	what is that ?
WATCH	6	((S\NP)\NP)	0.579770730491
WATCH	6	((S\NP)/NP)	0.00381123696686
WATCH	6	((S/NP)/NP)	0.413763089551
WATCH	6	((S/NP)\NP)	0.00265494299042
getting topparses
outputting cat probs
done with sent


making  lambda $0_{ev}.not(adj|sure(pro|I),$0)
making  not(adj|sure(pro|I),$0)
making  adj|sure(pro|I),$0)
making  pro|I
making  $0)
sentence is  what is that ?
making  lambda $0_{ev}.Q(aux|be&PRES(part|say-PROG(pro|you,n:prop|Fraser,$0),$0),$0)
making  Q(aux|be&PRES(part|say-PROG(pro|you,n:prop|Fraser,$0),$0),$0)
making  aux|be&PRES(part|say-PROG(pro|you,n:prop|Fraser,$0),$0),$0)
making  part|say-PROG(pro|you,n:prop|Fraser,$0)
making  pro|you
making  n:prop|Fraser
making  $0
making  $0
making  $0)
Is Q
sentence is  what is that ?
making  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  eq($0,pro:dem|that,$1)
making  $0,pro:dem|that,$1)
making  pro:dem|that,$1)
making  $1)
sentence is  what is that ?
making  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  eq($0,pro:dem|that,$1)
making  $0,pro:dem|that,$1)
making  pro:dem|that,$1)
making  $1)
sentence is  what is that ?
making  det|a($0,n|fly($0))
making  n|fly($0)
making  $0
sentence is  what is that ?
making  lambda $0_{ev}.v|get(pro|you,det|a($1,n|fly($1)),$0)
making  v|get(pro|you,det|a($1,n|fly($1)),$0)
making  pro|you
making  det|a($1,n|fly($1))
making  n|fly($1)
making  $1
making  $0
sentence is  what is that ?
making  lambda $0_{ev}.v|get(pro|you,pro:indef|one,$0)
making  v|get(pro|you,pro:indef|one,$0)
making  pro|you
making  pro:indef|one
making  $0
sentence is  what is that ?

got training pair
Sent : what is that ?
Cat : S:lambda $0_{ev}.not(adj|sure(pro|I),$0)
Cat : Syn:lambda $0_{ev}.Q(aux|be&PRES(part|say-PROG(pro|you,n:prop|Fraser,$0),$0),$0)
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
Cat : NP:det|a($0,n|fly($0))
Cat : S:lambda $0_{ev}.v|get(pro|you,det|a($1,n|fly($1)),$0)
Cat : S:lambda $0_{ev}.v|get(pro|you,pro:indef|one,$0)
sentence is  ['what', 'is', 'that']
sem is  lambda $0_{ev}.not(adj|sure(pro|I),$0)
sem is  lambda $0_{ev}.Q(aux|be&PRES(part|say-PROG(pro|you,n:prop|Fraser,$0),$0),$0)
sem is  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
sem is  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
sem is  det|a($0,n|fly($0))
sem is  lambda $0_{ev}.v|get(pro|you,det|a($1,n|fly($1)),$0)
sem is  lambda $0_{ev}.v|get(pro|you,pro:indef|one,$0)
size of chart is  284
got chart
norm score is  -11.0978938181
doing updates with learning rate  0.0393822128836
Deleting 0 entries of the total 2400
done io
WATCH	what is that ?
WATCH	7	((S\NP)\NP)	0.627387823864
WATCH	7	((S\NP)/NP)	0.00254196367383
WATCH	7	((S/NP)/NP)	0.368309451193
WATCH	7	((S/NP)\NP)	0.00176076126939
getting topparses
outputting cat probs
done with sent


making  lambda $0_{ev}.Q(aux|be&PRES(part|say-PROG(pro|you,n:prop|Fraser,$0),$0),$0)
making  Q(aux|be&PRES(part|say-PROG(pro|you,n:prop|Fraser,$0),$0),$0)
making  aux|be&PRES(part|say-PROG(pro|you,n:prop|Fraser,$0),$0),$0)
making  part|say-PROG(pro|you,n:prop|Fraser,$0)
making  pro|you
making  n:prop|Fraser
making  $0
making  $0
making  $0)
Is Q
sentence is  a fly .
making  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  eq($0,pro:dem|that,$1)
making  $0,pro:dem|that,$1)
making  pro:dem|that,$1)
making  $1)
sentence is  a fly .
making  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  eq($0,pro:dem|that,$1)
making  $0,pro:dem|that,$1)
making  pro:dem|that,$1)
making  $1)
sentence is  a fly .
making  det|a($0,n|fly($0))
making  n|fly($0)
making  $0
sentence is  a fly .
making  lambda $0_{ev}.v|get(pro|you,det|a($1,n|fly($1)),$0)
making  v|get(pro|you,det|a($1,n|fly($1)),$0)
making  pro|you
making  det|a($1,n|fly($1))
making  n|fly($1)
making  $1
making  $0
sentence is  a fly .
making  lambda $0_{ev}.v|get(pro|you,pro:indef|one,$0)
making  v|get(pro|you,pro:indef|one,$0)
making  pro|you
making  pro:indef|one
making  $0
sentence is  a fly .
making  pro:poss:det|your($0,n|telephone($0))
making  n|telephone($0)
making  $0
sentence is  a fly .

got training pair
Sent : a fly .
Cat : Syn:lambda $0_{ev}.Q(aux|be&PRES(part|say-PROG(pro|you,n:prop|Fraser,$0),$0),$0)
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
Cat : NP:det|a($0,n|fly($0))
Cat : S:lambda $0_{ev}.v|get(pro|you,det|a($1,n|fly($1)),$0)
Cat : S:lambda $0_{ev}.v|get(pro|you,pro:indef|one,$0)
Cat : NP:pro:poss:det|your($0,n|telephone($0))
sentence is  ['a', 'fly']
sem is  lambda $0_{ev}.Q(aux|be&PRES(part|say-PROG(pro|you,n:prop|Fraser,$0),$0),$0)
sem is  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
sem is  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
sem is  det|a($0,n|fly($0))
sem is  lambda $0_{ev}.v|get(pro|you,det|a($1,n|fly($1)),$0)
sem is  lambda $0_{ev}.v|get(pro|you,pro:indef|one,$0)
sem is  pro:poss:det|your($0,n|telephone($0))
size of chart is  68
got chart
norm score is  -16.5437802978
doing updates with learning rate  0.0388380668695
Deleting 0 entries of the total 2462
done io
WATCH	a fly .
WATCH	8	((S\NP)\NP)	0.627113967097
WATCH	8	((S\NP)/NP)	0.00249600850083
WATCH	8	((S/NP)/NP)	0.368665600118
WATCH	8	((S/NP)\NP)	0.00172442428413
getting topparses
outputting cat probs
done with sent


making  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  eq($0,pro:dem|that,$1)
making  $0,pro:dem|that,$1)
making  pro:dem|that,$1)
making  $1)
sentence is  you get a fly .
making  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  eq($0,pro:dem|that,$1)
making  $0,pro:dem|that,$1)
making  pro:dem|that,$1)
making  $1)
sentence is  you get a fly .
making  det|a($0,n|fly($0))
making  n|fly($0)
making  $0
sentence is  you get a fly .
making  lambda $0_{ev}.v|get(pro|you,det|a($1,n|fly($1)),$0)
making  v|get(pro|you,det|a($1,n|fly($1)),$0)
making  pro|you
making  det|a($1,n|fly($1))
making  n|fly($1)
making  $1
making  $0
sentence is  you get a fly .
making  lambda $0_{ev}.v|get(pro|you,pro:indef|one,$0)
making  v|get(pro|you,pro:indef|one,$0)
making  pro|you
making  pro:indef|one
making  $0
sentence is  you get a fly .
making  pro:poss:det|your($0,n|telephone($0))
making  n|telephone($0)
making  $0
sentence is  you get a fly .
making  lambda $0_{ev}.v|give&PAST(pro|he,pro|you,pro:poss:det|your($1,n|telephone($1)),$0)
making  v|give&PAST(pro|he,pro|you,pro:poss:det|your($1,n|telephone($1)),$0)
making  pro|he
making  pro|you
making  pro:poss:det|your($1,n|telephone($1))
making  n|telephone($1)
making  $1
making  $0
sentence is  you get a fly .

got training pair
Sent : you get a fly .
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
Cat : NP:det|a($0,n|fly($0))
Cat : S:lambda $0_{ev}.v|get(pro|you,det|a($1,n|fly($1)),$0)
Cat : S:lambda $0_{ev}.v|get(pro|you,pro:indef|one,$0)
Cat : NP:pro:poss:det|your($0,n|telephone($0))
Cat : S:lambda $0_{ev}.v|give&PAST(pro|he,pro|you,pro:poss:det|your($1,n|telephone($1)),$0)
sentence is  ['you', 'get', 'a', 'fly']
sem is  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
sem is  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
sem is  det|a($0,n|fly($0))
sem is  lambda $0_{ev}.v|get(pro|you,det|a($1,n|fly($1)),$0)
sem is  lambda $0_{ev}.v|get(pro|you,pro:indef|one,$0)
sem is  pro:poss:det|your($0,n|telephone($0))
sem is  lambda $0_{ev}.v|give&PAST(pro|he,pro|you,pro:poss:det|your($1,n|telephone($1)),$0)
size of chart is  667
got chart
norm score is  -24.8382378331
doing updates with learning rate  0.0383105503327
Deleting 0 entries of the total 2869
done io
WATCH	you get a fly .
WATCH	9	((S\NP)\NP)	0.648833356711
WATCH	9	((S\NP)/NP)	0.00309873836362
WATCH	9	((S/NP)/NP)	0.345366252147
WATCH	9	((S/NP)\NP)	0.00270165277898
getting topparses
outputting cat probs
done with sent


making  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  eq($0,pro:dem|that,$1)
making  $0,pro:dem|that,$1)
making  pro:dem|that,$1)
making  $1)
sentence is  you get one .
making  det|a($0,n|fly($0))
making  n|fly($0)
making  $0
sentence is  you get one .
making  lambda $0_{ev}.v|get(pro|you,det|a($1,n|fly($1)),$0)
making  v|get(pro|you,det|a($1,n|fly($1)),$0)
making  pro|you
making  det|a($1,n|fly($1))
making  n|fly($1)
making  $1
making  $0
sentence is  you get one .
making  lambda $0_{ev}.v|get(pro|you,pro:indef|one,$0)
making  v|get(pro|you,pro:indef|one,$0)
making  pro|you
making  pro:indef|one
making  $0
sentence is  you get one .
making  pro:poss:det|your($0,n|telephone($0))
making  n|telephone($0)
making  $0
sentence is  you get one .
making  lambda $0_{ev}.v|give&PAST(pro|he,pro|you,pro:poss:det|your($1,n|telephone($1)),$0)
making  v|give&PAST(pro|he,pro|you,pro:poss:det|your($1,n|telephone($1)),$0)
making  pro|he
making  pro|you
making  pro:poss:det|your($1,n|telephone($1))
making  n|telephone($1)
making  $1
making  $0
sentence is  you get one .
making  lambda $0_{e}.lambda $1_{ev}.aux|be&PRES(part|call-PROG(pro|you,$0,$1),$1)
making  lambda $1_{ev}.aux|be&PRES(part|call-PROG(pro|you,$0,$1),$1)
making  aux|be&PRES(part|call-PROG(pro|you,$0,$1),$1)
making  part|call-PROG(pro|you,$0,$1)
making  pro|you
making  $0
making  $1
making  $1
sentence is  you get one .

got training pair
Sent : you get one .
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
Cat : NP:det|a($0,n|fly($0))
Cat : S:lambda $0_{ev}.v|get(pro|you,det|a($1,n|fly($1)),$0)
Cat : S:lambda $0_{ev}.v|get(pro|you,pro:indef|one,$0)
Cat : NP:pro:poss:det|your($0,n|telephone($0))
Cat : S:lambda $0_{ev}.v|give&PAST(pro|he,pro|you,pro:poss:det|your($1,n|telephone($1)),$0)
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.aux|be&PRES(part|call-PROG(pro|you,$0,$1),$1)
sentence is  ['you', 'get', 'one']
sem is  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
sem is  det|a($0,n|fly($0))
sem is  lambda $0_{ev}.v|get(pro|you,det|a($1,n|fly($1)),$0)
sem is  lambda $0_{ev}.v|get(pro|you,pro:indef|one,$0)
sem is  pro:poss:det|your($0,n|telephone($0))
sem is  lambda $0_{ev}.v|give&PAST(pro|he,pro|you,pro:poss:det|your($1,n|telephone($1)),$0)
sem is  lambda $0_{e}.lambda $1_{ev}.aux|be&PRES(part|call-PROG(pro|you,$0,$1),$1)
types dont match 2 :  (Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|be&PRES($0($1),$1)   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|be&PRES($0($1),$1) (S/NP):lambda $0_{e}.lambda $1_{ev}.part|call-PROG(pro|you,$0,$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|be&PRES($0($1),$1)   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
types dont match 2 :  (Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|be&PRES($0($1),$1)   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|be&PRES($0($1),$1) (S\NP):lambda $0_{e}.lambda $1_{ev}.part|call-PROG(pro|you,$0,$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|be&PRES($0($1),$1)   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
size of chart is  300
got chart
norm score is  -18.0203601027
doing updates with learning rate  0.0377988859211
Deleting 0 entries of the total 2976
done io
WATCH	you get one .
WATCH	10	((S\NP)\NP)	0.666910702511
WATCH	10	((S\NP)/NP)	0.00291598863773
WATCH	10	((S/NP)/NP)	0.327649358784
WATCH	10	((S/NP)\NP)	0.00252395006733
getting topparses
outputting cat probs
done with sent


making  det|a($0,n|fly($0))
making  n|fly($0)
making  $0
sentence is  go and get your telephone .
making  lambda $0_{ev}.v|get(pro|you,det|a($1,n|fly($1)),$0)
making  v|get(pro|you,det|a($1,n|fly($1)),$0)
making  pro|you
making  det|a($1,n|fly($1))
making  n|fly($1)
making  $1
making  $0
sentence is  go and get your telephone .
making  lambda $0_{ev}.v|get(pro|you,pro:indef|one,$0)
making  v|get(pro|you,pro:indef|one,$0)
making  pro|you
making  pro:indef|one
making  $0
sentence is  go and get your telephone .
making  pro:poss:det|your($0,n|telephone($0))
making  n|telephone($0)
making  $0
sentence is  go and get your telephone .
making  lambda $0_{ev}.v|give&PAST(pro|he,pro|you,pro:poss:det|your($1,n|telephone($1)),$0)
making  v|give&PAST(pro|he,pro|you,pro:poss:det|your($1,n|telephone($1)),$0)
making  pro|he
making  pro|you
making  pro:poss:det|your($1,n|telephone($1))
making  n|telephone($1)
making  $1
making  $0
sentence is  go and get your telephone .
making  lambda $0_{e}.lambda $1_{ev}.aux|be&PRES(part|call-PROG(pro|you,$0,$1),$1)
making  lambda $1_{ev}.aux|be&PRES(part|call-PROG(pro|you,$0,$1),$1)
making  aux|be&PRES(part|call-PROG(pro|you,$0,$1),$1)
making  part|call-PROG(pro|you,$0,$1)
making  pro|you
making  $0
making  $1
making  $1
sentence is  go and get your telephone .
making  lambda $0_{ev}.Q(pro:wh|who,$0)
making  Q(pro:wh|who,$0)
making  pro:wh|who,$0)
making  $0)
Is Q
sentence is  go and get your telephone .

got training pair
Sent : go and get your telephone .
Cat : NP:det|a($0,n|fly($0))
Cat : S:lambda $0_{ev}.v|get(pro|you,det|a($1,n|fly($1)),$0)
Cat : S:lambda $0_{ev}.v|get(pro|you,pro:indef|one,$0)
Cat : NP:pro:poss:det|your($0,n|telephone($0))
Cat : S:lambda $0_{ev}.v|give&PAST(pro|he,pro|you,pro:poss:det|your($1,n|telephone($1)),$0)
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.aux|be&PRES(part|call-PROG(pro|you,$0,$1),$1)
Cat : Syn:lambda $0_{ev}.Q(pro:wh|who,$0)
sentence is  ['go', 'and', 'get', 'your', 'telephone', '.']
sem is  det|a($0,n|fly($0))
sem is  lambda $0_{ev}.v|get(pro|you,det|a($1,n|fly($1)),$0)
sem is  lambda $0_{ev}.v|get(pro|you,pro:indef|one,$0)
sem is  pro:poss:det|your($0,n|telephone($0))
sem is  lambda $0_{ev}.v|give&PAST(pro|he,pro|you,pro:poss:det|your($1,n|telephone($1)),$0)
sem is  lambda $0_{e}.lambda $1_{ev}.aux|be&PRES(part|call-PROG(pro|you,$0,$1),$1)
types dont match 2 :  (Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|be&PRES($0($1),$1)   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|be&PRES($0($1),$1) (S/NP):lambda $0_{e}.lambda $1_{ev}.part|call-PROG(pro|you,$0,$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|be&PRES($0($1),$1)   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
types dont match 2 :  (Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|be&PRES($0($1),$1)   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|be&PRES($0($1),$1) (S\NP):lambda $0_{e}.lambda $1_{ev}.part|call-PROG(pro|you,$0,$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|be&PRES($0($1),$1)   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
sem is  lambda $0_{ev}.Q(pro:wh|who,$0)
size of chart is  3085
got chart
norm score is  -56.4825877391
doing updates with learning rate  0.0373023447888
Deleting 4002 entries of the total 4380
done io
WATCH	go and get your telephone .
WATCH	11	((S\NP)\NP)	0.675156809617
WATCH	11	((S\NP)/NP)	0.00281456998817
WATCH	11	((S/NP)/NP)	0.319499362652
WATCH	11	((S/NP)\NP)	0.00252925774323
getting topparses
outputting cat probs
done with sent


making  lambda $0_{ev}.v|get(pro|you,det|a($1,n|fly($1)),$0)
making  v|get(pro|you,det|a($1,n|fly($1)),$0)
making  pro|you
making  det|a($1,n|fly($1))
making  n|fly($1)
making  $1
making  $0
sentence is  he gave you your telephone .
making  lambda $0_{ev}.v|get(pro|you,pro:indef|one,$0)
making  v|get(pro|you,pro:indef|one,$0)
making  pro|you
making  pro:indef|one
making  $0
sentence is  he gave you your telephone .
making  pro:poss:det|your($0,n|telephone($0))
making  n|telephone($0)
making  $0
sentence is  he gave you your telephone .
making  lambda $0_{ev}.v|give&PAST(pro|he,pro|you,pro:poss:det|your($1,n|telephone($1)),$0)
making  v|give&PAST(pro|he,pro|you,pro:poss:det|your($1,n|telephone($1)),$0)
making  pro|he
making  pro|you
making  pro:poss:det|your($1,n|telephone($1))
making  n|telephone($1)
making  $1
making  $0
sentence is  he gave you your telephone .
making  lambda $0_{e}.lambda $1_{ev}.aux|be&PRES(part|call-PROG(pro|you,$0,$1),$1)
making  lambda $1_{ev}.aux|be&PRES(part|call-PROG(pro|you,$0,$1),$1)
making  aux|be&PRES(part|call-PROG(pro|you,$0,$1),$1)
making  part|call-PROG(pro|you,$0,$1)
making  pro|you
making  $0
making  $1
making  $1
sentence is  he gave you your telephone .
making  lambda $0_{ev}.Q(pro:wh|who,$0)
making  Q(pro:wh|who,$0)
making  pro:wh|who,$0)
making  $0)
Is Q
sentence is  he gave you your telephone .
making  lambda $0_{e}.lambda $1_{ev}.aux|be&3S(part|do-PROG(det|the($2,n|man($2)),$0,$1),$1)
making  lambda $1_{ev}.aux|be&3S(part|do-PROG(det|the($2,n|man($2)),$0,$1),$1)
making  aux|be&3S(part|do-PROG(det|the($2,n|man($2)),$0,$1),$1)
making  part|do-PROG(det|the($2,n|man($2)),$0,$1)
making  det|the($2,n|man($2))
making  n|man($2)
making  $2
making  $0
making  $1
making  $1
sentence is  he gave you your telephone .

got training pair
Sent : he gave you your telephone .
Cat : S:lambda $0_{ev}.v|get(pro|you,det|a($1,n|fly($1)),$0)
Cat : S:lambda $0_{ev}.v|get(pro|you,pro:indef|one,$0)
Cat : NP:pro:poss:det|your($0,n|telephone($0))
Cat : S:lambda $0_{ev}.v|give&PAST(pro|he,pro|you,pro:poss:det|your($1,n|telephone($1)),$0)
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.aux|be&PRES(part|call-PROG(pro|you,$0,$1),$1)
Cat : Syn:lambda $0_{ev}.Q(pro:wh|who,$0)
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.aux|be&3S(part|do-PROG(det|the($2,n|man($2)),$0,$1),$1)
sentence is  ['he', 'gave', 'you', 'your', 'telephone']
sem is  lambda $0_{ev}.v|get(pro|you,det|a($1,n|fly($1)),$0)
sem is  lambda $0_{ev}.v|get(pro|you,pro:indef|one,$0)
sem is  pro:poss:det|your($0,n|telephone($0))
sem is  lambda $0_{ev}.v|give&PAST(pro|he,pro|you,pro:poss:det|your($1,n|telephone($1)),$0)
sem is  lambda $0_{e}.lambda $1_{ev}.aux|be&PRES(part|call-PROG(pro|you,$0,$1),$1)
types dont match 2 :  (Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|be&PRES($0($1),$1)   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|be&PRES($0($1),$1) (S/NP):lambda $0_{e}.lambda $1_{ev}.part|call-PROG(pro|you,$0,$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|be&PRES($0($1),$1)   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
types dont match 2 :  (Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|be&PRES($0($1),$1)   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|be&PRES($0($1),$1) (S\NP):lambda $0_{e}.lambda $1_{ev}.part|call-PROG(pro|you,$0,$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|be&PRES($0($1),$1)   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
sem is  lambda $0_{ev}.Q(pro:wh|who,$0)
sem is  lambda $0_{e}.lambda $1_{ev}.aux|be&3S(part|do-PROG(det|the($2,n|man($2)),$0,$1),$1)
types dont match 2 :  (Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|be&3S($0($1),$1)   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|be&3S($0($1),$1) (S/NP):lambda $0_{e}.lambda $1_{ev}.part|do-PROG(det|the($2,n|man($2)),$0,$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|be&3S($0($1),$1)   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
types dont match 2 :  (Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|be&3S($0($1),$1)   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|be&3S($0($1),$1) (S\NP):lambda $0_{e}.lambda $1_{ev}.part|do-PROG(det|the($2,n|man($2)),$0,$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|be&3S($0($1),$1)   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
size of chart is  2245
got chart
norm score is  -33.342840692
doing updates with learning rate  0.0368202428339
Deleting 0 entries of the total 1522
done io
WATCH	he gave you your telephone .
WATCH	12	((S\NP)\NP)	0.676637425686
WATCH	12	((S\NP)/NP)	0.00274908435963
WATCH	12	((S/NP)/NP)	0.318137851931
WATCH	12	((S/NP)\NP)	0.00247563802336
getting topparses
outputting cat probs
done with sent


making  lambda $0_{ev}.v|get(pro|you,pro:indef|one,$0)
making  v|get(pro|you,pro:indef|one,$0)
making  pro|you
making  pro:indef|one
making  $0
sentence is  who are you calling ?
making  pro:poss:det|your($0,n|telephone($0))
making  n|telephone($0)
making  $0
sentence is  who are you calling ?
making  lambda $0_{ev}.v|give&PAST(pro|he,pro|you,pro:poss:det|your($1,n|telephone($1)),$0)
making  v|give&PAST(pro|he,pro|you,pro:poss:det|your($1,n|telephone($1)),$0)
making  pro|he
making  pro|you
making  pro:poss:det|your($1,n|telephone($1))
making  n|telephone($1)
making  $1
making  $0
sentence is  who are you calling ?
making  lambda $0_{e}.lambda $1_{ev}.aux|be&PRES(part|call-PROG(pro|you,$0,$1),$1)
making  lambda $1_{ev}.aux|be&PRES(part|call-PROG(pro|you,$0,$1),$1)
making  aux|be&PRES(part|call-PROG(pro|you,$0,$1),$1)
making  part|call-PROG(pro|you,$0,$1)
making  pro|you
making  $0
making  $1
making  $1
sentence is  who are you calling ?
making  lambda $0_{ev}.Q(pro:wh|who,$0)
making  Q(pro:wh|who,$0)
making  pro:wh|who,$0)
making  $0)
Is Q
sentence is  who are you calling ?
making  lambda $0_{e}.lambda $1_{ev}.aux|be&3S(part|do-PROG(det|the($2,n|man($2)),$0,$1),$1)
making  lambda $1_{ev}.aux|be&3S(part|do-PROG(det|the($2,n|man($2)),$0,$1),$1)
making  aux|be&3S(part|do-PROG(det|the($2,n|man($2)),$0,$1),$1)
making  part|do-PROG(det|the($2,n|man($2)),$0,$1)
making  det|the($2,n|man($2))
making  n|man($2)
making  $2
making  $0
making  $1
making  $1
sentence is  who are you calling ?
making  lambda $0_{ev}.Q(v|want(pro|you,det|a($1,n|cookie($1)),$0),$0)
making  Q(v|want(pro|you,det|a($1,n|cookie($1)),$0),$0)
making  v|want(pro|you,det|a($1,n|cookie($1)),$0),$0)
making  pro|you
making  det|a($1,n|cookie($1))
making  n|cookie($1)
making  $1
making  $0
making  $0)
Is Q
sentence is  who are you calling ?

got training pair
Sent : who are you calling ?
Cat : S:lambda $0_{ev}.v|get(pro|you,pro:indef|one,$0)
Cat : NP:pro:poss:det|your($0,n|telephone($0))
Cat : S:lambda $0_{ev}.v|give&PAST(pro|he,pro|you,pro:poss:det|your($1,n|telephone($1)),$0)
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.aux|be&PRES(part|call-PROG(pro|you,$0,$1),$1)
Cat : Syn:lambda $0_{ev}.Q(pro:wh|who,$0)
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.aux|be&3S(part|do-PROG(det|the($2,n|man($2)),$0,$1),$1)
Cat : Syn:lambda $0_{ev}.Q(v|want(pro|you,det|a($1,n|cookie($1)),$0),$0)
sentence is  ['who', 'are', 'you', 'calling', '?']
sem is  lambda $0_{ev}.v|get(pro|you,pro:indef|one,$0)
sem is  pro:poss:det|your($0,n|telephone($0))
sem is  lambda $0_{ev}.v|give&PAST(pro|he,pro|you,pro:poss:det|your($1,n|telephone($1)),$0)
sem is  lambda $0_{e}.lambda $1_{ev}.aux|be&PRES(part|call-PROG(pro|you,$0,$1),$1)
types dont match 2 :  (Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|be&PRES($0($1),$1)   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|be&PRES($0($1),$1) (S/NP):lambda $0_{e}.lambda $1_{ev}.part|call-PROG(pro|you,$0,$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|be&PRES($0($1),$1)   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
types dont match 2 :  (Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|be&PRES($0($1),$1)   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|be&PRES($0($1),$1) (S\NP):lambda $0_{e}.lambda $1_{ev}.part|call-PROG(pro|you,$0,$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|be&PRES($0($1),$1)   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
sem is  lambda $0_{ev}.Q(pro:wh|who,$0)
sem is  lambda $0_{e}.lambda $1_{ev}.aux|be&3S(part|do-PROG(det|the($2,n|man($2)),$0,$1),$1)
types dont match 2 :  (Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|be&3S($0($1),$1)   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|be&3S($0($1),$1) (S/NP):lambda $0_{e}.lambda $1_{ev}.part|do-PROG(det|the($2,n|man($2)),$0,$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|be&3S($0($1),$1)   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
types dont match 2 :  (Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|be&3S($0($1),$1)   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|be&3S($0($1),$1) (S\NP):lambda $0_{e}.lambda $1_{ev}.part|do-PROG(det|the($2,n|man($2)),$0,$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|be&3S($0($1),$1)   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
sem is  lambda $0_{ev}.Q(v|want(pro|you,det|a($1,n|cookie($1)),$0),$0)
size of chart is  2841
got chart
norm score is  -30.6881507435
doing updates with learning rate  0.0363519372845
Deleting 0 entries of the total 2843
done io
WATCH	who are you calling ?
WATCH	13	((S\NP)\NP)	0.734028407564
WATCH	13	((S\NP)/NP)	0.00221079266442
WATCH	13	((S/NP)/NP)	0.261762314861
WATCH	13	((S/NP)\NP)	0.00199848491083
getting topparses
outputting cat probs
done with sent


making  pro:poss:det|your($0,n|telephone($0))
making  n|telephone($0)
making  $0
sentence is  who ?
making  lambda $0_{ev}.v|give&PAST(pro|he,pro|you,pro:poss:det|your($1,n|telephone($1)),$0)
making  v|give&PAST(pro|he,pro|you,pro:poss:det|your($1,n|telephone($1)),$0)
making  pro|he
making  pro|you
making  pro:poss:det|your($1,n|telephone($1))
making  n|telephone($1)
making  $1
making  $0
sentence is  who ?
making  lambda $0_{e}.lambda $1_{ev}.aux|be&PRES(part|call-PROG(pro|you,$0,$1),$1)
making  lambda $1_{ev}.aux|be&PRES(part|call-PROG(pro|you,$0,$1),$1)
making  aux|be&PRES(part|call-PROG(pro|you,$0,$1),$1)
making  part|call-PROG(pro|you,$0,$1)
making  pro|you
making  $0
making  $1
making  $1
sentence is  who ?
making  lambda $0_{ev}.Q(pro:wh|who,$0)
making  Q(pro:wh|who,$0)
making  pro:wh|who,$0)
making  $0)
Is Q
sentence is  who ?
making  lambda $0_{e}.lambda $1_{ev}.aux|be&3S(part|do-PROG(det|the($2,n|man($2)),$0,$1),$1)
making  lambda $1_{ev}.aux|be&3S(part|do-PROG(det|the($2,n|man($2)),$0,$1),$1)
making  aux|be&3S(part|do-PROG(det|the($2,n|man($2)),$0,$1),$1)
making  part|do-PROG(det|the($2,n|man($2)),$0,$1)
making  det|the($2,n|man($2))
making  n|man($2)
making  $2
making  $0
making  $1
making  $1
sentence is  who ?
making  lambda $0_{ev}.Q(v|want(pro|you,det|a($1,n|cookie($1)),$0),$0)
making  Q(v|want(pro|you,det|a($1,n|cookie($1)),$0),$0)
making  v|want(pro|you,det|a($1,n|cookie($1)),$0),$0)
making  pro|you
making  det|a($1,n|cookie($1))
making  n|cookie($1)
making  $1
making  $0
making  $0)
Is Q
sentence is  who ?
making  lambda $0_{ev}.Q(aux|can(v|do(pro|you,pro|it,$0),$0),$0)
making  Q(aux|can(v|do(pro|you,pro|it,$0),$0),$0)
making  aux|can(v|do(pro|you,pro|it,$0),$0),$0)
making  v|do(pro|you,pro|it,$0)
making  pro|you
making  pro|it
making  $0
making  $0
making  $0)
Is Q
sentence is  who ?

got training pair
Sent : who ?
Cat : NP:pro:poss:det|your($0,n|telephone($0))
Cat : S:lambda $0_{ev}.v|give&PAST(pro|he,pro|you,pro:poss:det|your($1,n|telephone($1)),$0)
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.aux|be&PRES(part|call-PROG(pro|you,$0,$1),$1)
Cat : Syn:lambda $0_{ev}.Q(pro:wh|who,$0)
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.aux|be&3S(part|do-PROG(det|the($2,n|man($2)),$0,$1),$1)
Cat : Syn:lambda $0_{ev}.Q(v|want(pro|you,det|a($1,n|cookie($1)),$0),$0)
Cat : Syn:lambda $0_{ev}.Q(aux|can(v|do(pro|you,pro|it,$0),$0),$0)
sentence is  ['who', '?']
sem is  pro:poss:det|your($0,n|telephone($0))
sem is  lambda $0_{ev}.v|give&PAST(pro|he,pro|you,pro:poss:det|your($1,n|telephone($1)),$0)
sem is  lambda $0_{e}.lambda $1_{ev}.aux|be&PRES(part|call-PROG(pro|you,$0,$1),$1)
types dont match 2 :  (Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|be&PRES($0($1),$1)   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|be&PRES($0($1),$1) (S/NP):lambda $0_{e}.lambda $1_{ev}.part|call-PROG(pro|you,$0,$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|be&PRES($0($1),$1)   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
types dont match 2 :  (Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|be&PRES($0($1),$1)   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|be&PRES($0($1),$1) (S\NP):lambda $0_{e}.lambda $1_{ev}.part|call-PROG(pro|you,$0,$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|be&PRES($0($1),$1)   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
sem is  lambda $0_{ev}.Q(pro:wh|who,$0)
sem is  lambda $0_{e}.lambda $1_{ev}.aux|be&3S(part|do-PROG(det|the($2,n|man($2)),$0,$1),$1)
types dont match 2 :  (Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|be&3S($0($1),$1)   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|be&3S($0($1),$1) (S/NP):lambda $0_{e}.lambda $1_{ev}.part|do-PROG(det|the($2,n|man($2)),$0,$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|be&3S($0($1),$1)   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
types dont match 2 :  (Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|be&3S($0($1),$1)   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|be&3S($0($1),$1) (S\NP):lambda $0_{e}.lambda $1_{ev}.part|do-PROG(det|the($2,n|man($2)),$0,$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|be&3S($0($1),$1)   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
sem is  lambda $0_{ev}.Q(v|want(pro|you,det|a($1,n|cookie($1)),$0),$0)
sem is  lambda $0_{ev}.Q(aux|can(v|do(pro|you,pro|it,$0),$0),$0)
size of chart is  107
got chart
norm score is  -15.4640739555
doing updates with learning rate  0.0358968235937
Deleting 0 entries of the total 2864
done io
WATCH	who ?
WATCH	14	((S\NP)\NP)	0.732025302598
WATCH	14	((S\NP)/NP)	0.002190579735
WATCH	14	((S/NP)/NP)	0.263785128161
WATCH	14	((S/NP)\NP)	0.00199898950545
getting topparses
outputting cat probs
done with sent


making  lambda $0_{ev}.v|give&PAST(pro|he,pro|you,pro:poss:det|your($1,n|telephone($1)),$0)
making  v|give&PAST(pro|he,pro|you,pro:poss:det|your($1,n|telephone($1)),$0)
making  pro|he
making  pro|you
making  pro:poss:det|your($1,n|telephone($1))
making  n|telephone($1)
making  $1
making  $0
sentence is  what 's the man doing ?
making  lambda $0_{e}.lambda $1_{ev}.aux|be&PRES(part|call-PROG(pro|you,$0,$1),$1)
making  lambda $1_{ev}.aux|be&PRES(part|call-PROG(pro|you,$0,$1),$1)
making  aux|be&PRES(part|call-PROG(pro|you,$0,$1),$1)
making  part|call-PROG(pro|you,$0,$1)
making  pro|you
making  $0
making  $1
making  $1
sentence is  what 's the man doing ?
making  lambda $0_{ev}.Q(pro:wh|who,$0)
making  Q(pro:wh|who,$0)
making  pro:wh|who,$0)
making  $0)
Is Q
sentence is  what 's the man doing ?
making  lambda $0_{e}.lambda $1_{ev}.aux|be&3S(part|do-PROG(det|the($2,n|man($2)),$0,$1),$1)
making  lambda $1_{ev}.aux|be&3S(part|do-PROG(det|the($2,n|man($2)),$0,$1),$1)
making  aux|be&3S(part|do-PROG(det|the($2,n|man($2)),$0,$1),$1)
making  part|do-PROG(det|the($2,n|man($2)),$0,$1)
making  det|the($2,n|man($2))
making  n|man($2)
making  $2
making  $0
making  $1
making  $1
sentence is  what 's the man doing ?
making  lambda $0_{ev}.Q(v|want(pro|you,det|a($1,n|cookie($1)),$0),$0)
making  Q(v|want(pro|you,det|a($1,n|cookie($1)),$0),$0)
making  v|want(pro|you,det|a($1,n|cookie($1)),$0),$0)
making  pro|you
making  det|a($1,n|cookie($1))
making  n|cookie($1)
making  $1
making  $0
making  $0)
Is Q
sentence is  what 's the man doing ?
making  lambda $0_{ev}.Q(aux|can(v|do(pro|you,pro|it,$0),$0),$0)
making  Q(aux|can(v|do(pro|you,pro|it,$0),$0),$0)
making  aux|can(v|do(pro|you,pro|it,$0),$0),$0)
making  v|do(pro|you,pro|it,$0)
making  pro|you
making  pro|it
making  $0
making  $0
making  $0)
Is Q
sentence is  what 's the man doing ?
making  lambda $0_{ev}.adv:loc|there($0)
making  adv:loc|there($0)
making  $0
sentence is  what 's the man doing ?

got training pair
Sent : what 's the man doing ?
Cat : S:lambda $0_{ev}.v|give&PAST(pro|he,pro|you,pro:poss:det|your($1,n|telephone($1)),$0)
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.aux|be&PRES(part|call-PROG(pro|you,$0,$1),$1)
Cat : Syn:lambda $0_{ev}.Q(pro:wh|who,$0)
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.aux|be&3S(part|do-PROG(det|the($2,n|man($2)),$0,$1),$1)
Cat : Syn:lambda $0_{ev}.Q(v|want(pro|you,det|a($1,n|cookie($1)),$0),$0)
Cat : Syn:lambda $0_{ev}.Q(aux|can(v|do(pro|you,pro|it,$0),$0),$0)
Cat : S:lambda $0_{ev}.adv:loc|there($0)
sentence is  ['what', "'s", 'the', 'man', 'doing']
sem is  lambda $0_{ev}.v|give&PAST(pro|he,pro|you,pro:poss:det|your($1,n|telephone($1)),$0)
sem is  lambda $0_{e}.lambda $1_{ev}.aux|be&PRES(part|call-PROG(pro|you,$0,$1),$1)
types dont match 2 :  (Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|be&PRES($0($1),$1)   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|be&PRES($0($1),$1) (S/NP):lambda $0_{e}.lambda $1_{ev}.part|call-PROG(pro|you,$0,$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|be&PRES($0($1),$1)   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
types dont match 2 :  (Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|be&PRES($0($1),$1)   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|be&PRES($0($1),$1) (S\NP):lambda $0_{e}.lambda $1_{ev}.part|call-PROG(pro|you,$0,$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|be&PRES($0($1),$1)   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
sem is  lambda $0_{ev}.Q(pro:wh|who,$0)
sem is  lambda $0_{e}.lambda $1_{ev}.aux|be&3S(part|do-PROG(det|the($2,n|man($2)),$0,$1),$1)
types dont match 2 :  (Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|be&3S($0($1),$1)   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|be&3S($0($1),$1) (S/NP):lambda $0_{e}.lambda $1_{ev}.part|do-PROG(det|the($2,n|man($2)),$0,$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|be&3S($0($1),$1)   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
types dont match 2 :  (Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|be&3S($0($1),$1)   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|be&3S($0($1),$1) (S\NP):lambda $0_{e}.lambda $1_{ev}.part|do-PROG(det|the($2,n|man($2)),$0,$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|be&3S($0($1),$1)   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
sem is  lambda $0_{ev}.Q(v|want(pro|you,det|a($1,n|cookie($1)),$0),$0)
sem is  lambda $0_{ev}.Q(aux|can(v|do(pro|you,pro|it,$0),$0),$0)
sem is  lambda $0_{ev}.adv:loc|there($0)
size of chart is  3173
got chart
norm score is  -38.1001875531
doing updates with learning rate  0.0354543326123
Deleting 0 entries of the total 4485
done io
WATCH	what 's the man doing ?
WATCH	15	((S\NP)\NP)	0.726128393628
WATCH	15	((S\NP)/NP)	0.00189702438609
WATCH	15	((S/NP)/NP)	0.269954930292
WATCH	15	((S/NP)\NP)	0.00201965169424
getting topparses
outputting cat probs
done with sent


making  lambda $0_{e}.lambda $1_{ev}.aux|be&PRES(part|call-PROG(pro|you,$0,$1),$1)
making  lambda $1_{ev}.aux|be&PRES(part|call-PROG(pro|you,$0,$1),$1)
making  aux|be&PRES(part|call-PROG(pro|you,$0,$1),$1)
making  part|call-PROG(pro|you,$0,$1)
making  pro|you
making  $0
making  $1
making  $1
sentence is  you want a cookie ?
making  lambda $0_{ev}.Q(pro:wh|who,$0)
making  Q(pro:wh|who,$0)
making  pro:wh|who,$0)
making  $0)
Is Q
sentence is  you want a cookie ?
making  lambda $0_{e}.lambda $1_{ev}.aux|be&3S(part|do-PROG(det|the($2,n|man($2)),$0,$1),$1)
making  lambda $1_{ev}.aux|be&3S(part|do-PROG(det|the($2,n|man($2)),$0,$1),$1)
making  aux|be&3S(part|do-PROG(det|the($2,n|man($2)),$0,$1),$1)
making  part|do-PROG(det|the($2,n|man($2)),$0,$1)
making  det|the($2,n|man($2))
making  n|man($2)
making  $2
making  $0
making  $1
making  $1
sentence is  you want a cookie ?
making  lambda $0_{ev}.Q(v|want(pro|you,det|a($1,n|cookie($1)),$0),$0)
making  Q(v|want(pro|you,det|a($1,n|cookie($1)),$0),$0)
making  v|want(pro|you,det|a($1,n|cookie($1)),$0),$0)
making  pro|you
making  det|a($1,n|cookie($1))
making  n|cookie($1)
making  $1
making  $0
making  $0)
Is Q
sentence is  you want a cookie ?
making  lambda $0_{ev}.Q(aux|can(v|do(pro|you,pro|it,$0),$0),$0)
making  Q(aux|can(v|do(pro|you,pro|it,$0),$0),$0)
making  aux|can(v|do(pro|you,pro|it,$0),$0),$0)
making  v|do(pro|you,pro|it,$0)
making  pro|you
making  pro|it
making  $0
making  $0
making  $0)
Is Q
sentence is  you want a cookie ?
making  lambda $0_{ev}.adv:loc|there($0)
making  adv:loc|there($0)
making  $0
sentence is  you want a cookie ?
making  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  eq($0,pro:dem|that,$1)
making  $0,pro:dem|that,$1)
making  pro:dem|that,$1)
making  $1)
sentence is  you want a cookie ?

got training pair
Sent : you want a cookie ?
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.aux|be&PRES(part|call-PROG(pro|you,$0,$1),$1)
Cat : Syn:lambda $0_{ev}.Q(pro:wh|who,$0)
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.aux|be&3S(part|do-PROG(det|the($2,n|man($2)),$0,$1),$1)
Cat : Syn:lambda $0_{ev}.Q(v|want(pro|you,det|a($1,n|cookie($1)),$0),$0)
Cat : Syn:lambda $0_{ev}.Q(aux|can(v|do(pro|you,pro|it,$0),$0),$0)
Cat : S:lambda $0_{ev}.adv:loc|there($0)
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
sentence is  ['you', 'want', 'a', 'cookie']
sem is  lambda $0_{e}.lambda $1_{ev}.aux|be&PRES(part|call-PROG(pro|you,$0,$1),$1)
types dont match 2 :  (Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|be&PRES($0($1),$1)   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|be&PRES($0($1),$1) (S/NP):lambda $0_{e}.lambda $1_{ev}.part|call-PROG(pro|you,$0,$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|be&PRES($0($1),$1)   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
types dont match 2 :  (Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|be&PRES($0($1),$1)   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|be&PRES($0($1),$1) (S\NP):lambda $0_{e}.lambda $1_{ev}.part|call-PROG(pro|you,$0,$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|be&PRES($0($1),$1)   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
sem is  lambda $0_{ev}.Q(pro:wh|who,$0)
sem is  lambda $0_{e}.lambda $1_{ev}.aux|be&3S(part|do-PROG(det|the($2,n|man($2)),$0,$1),$1)
types dont match 2 :  (Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|be&3S($0($1),$1)   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|be&3S($0($1),$1) (S/NP):lambda $0_{e}.lambda $1_{ev}.part|do-PROG(det|the($2,n|man($2)),$0,$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|be&3S($0($1),$1)   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
types dont match 2 :  (Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|be&3S($0($1),$1)   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|be&3S($0($1),$1) (S\NP):lambda $0_{e}.lambda $1_{ev}.part|do-PROG(det|the($2,n|man($2)),$0,$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|be&3S($0($1),$1)   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
sem is  lambda $0_{ev}.Q(v|want(pro|you,det|a($1,n|cookie($1)),$0),$0)
sem is  lambda $0_{ev}.Q(aux|can(v|do(pro|you,pro|it,$0),$0),$0)
sem is  lambda $0_{ev}.adv:loc|there($0)
sem is  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
size of chart is  1176
got chart
norm score is  -27.8346377628
doing updates with learning rate  0.0350239280111
Deleting 0 entries of the total 5099
done io
WATCH	you want a cookie ?
WATCH	16	((S\NP)\NP)	0.737859542421
WATCH	16	((S\NP)/NP)	0.00179331901266
WATCH	16	((S/NP)/NP)	0.258428238825
WATCH	16	((S/NP)\NP)	0.00191889974102
getting topparses
outputting cat probs
done with sent


making  lambda $0_{ev}.Q(pro:wh|who,$0)
making  Q(pro:wh|who,$0)
making  pro:wh|who,$0)
making  $0)
Is Q
sentence is  can you do it ?
making  lambda $0_{e}.lambda $1_{ev}.aux|be&3S(part|do-PROG(det|the($2,n|man($2)),$0,$1),$1)
making  lambda $1_{ev}.aux|be&3S(part|do-PROG(det|the($2,n|man($2)),$0,$1),$1)
making  aux|be&3S(part|do-PROG(det|the($2,n|man($2)),$0,$1),$1)
making  part|do-PROG(det|the($2,n|man($2)),$0,$1)
making  det|the($2,n|man($2))
making  n|man($2)
making  $2
making  $0
making  $1
making  $1
sentence is  can you do it ?
making  lambda $0_{ev}.Q(v|want(pro|you,det|a($1,n|cookie($1)),$0),$0)
making  Q(v|want(pro|you,det|a($1,n|cookie($1)),$0),$0)
making  v|want(pro|you,det|a($1,n|cookie($1)),$0),$0)
making  pro|you
making  det|a($1,n|cookie($1))
making  n|cookie($1)
making  $1
making  $0
making  $0)
Is Q
sentence is  can you do it ?
making  lambda $0_{ev}.Q(aux|can(v|do(pro|you,pro|it,$0),$0),$0)
making  Q(aux|can(v|do(pro|you,pro|it,$0),$0),$0)
making  aux|can(v|do(pro|you,pro|it,$0),$0),$0)
making  v|do(pro|you,pro|it,$0)
making  pro|you
making  pro|it
making  $0
making  $0
making  $0)
Is Q
sentence is  can you do it ?
making  lambda $0_{ev}.adv:loc|there($0)
making  adv:loc|there($0)
making  $0
sentence is  can you do it ?
making  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  eq($0,pro:dem|that,$1)
making  $0,pro:dem|that,$1)
making  pro:dem|that,$1)
making  $1)
sentence is  can you do it ?
making  lambda $0_{ev}.eq(pro|it,det|a($1,n|baby($1)),$0)
making  eq(pro|it,det|a($1,n|baby($1)),$0)
making  pro|it,det|a($1,n|baby($1)),$0)
making  det|a($1,n|baby($1)),$0)
making  n|baby($1)
making  $1
making  $0)
sentence is  can you do it ?

got training pair
Sent : can you do it ?
Cat : Syn:lambda $0_{ev}.Q(pro:wh|who,$0)
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.aux|be&3S(part|do-PROG(det|the($2,n|man($2)),$0,$1),$1)
Cat : Syn:lambda $0_{ev}.Q(v|want(pro|you,det|a($1,n|cookie($1)),$0),$0)
Cat : Syn:lambda $0_{ev}.Q(aux|can(v|do(pro|you,pro|it,$0),$0),$0)
Cat : S:lambda $0_{ev}.adv:loc|there($0)
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
Cat : S:lambda $0_{ev}.eq(pro|it,det|a($1,n|baby($1)),$0)
sentence is  ['can', 'you', 'do', 'it']
sem is  lambda $0_{ev}.Q(pro:wh|who,$0)
sem is  lambda $0_{e}.lambda $1_{ev}.aux|be&3S(part|do-PROG(det|the($2,n|man($2)),$0,$1),$1)
types dont match 2 :  (Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|be&3S($0($1),$1)   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|be&3S($0($1),$1) (S/NP):lambda $0_{e}.lambda $1_{ev}.part|do-PROG(det|the($2,n|man($2)),$0,$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|be&3S($0($1),$1)   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
types dont match 2 :  (Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|be&3S($0($1),$1)   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|be&3S($0($1),$1) (S\NP):lambda $0_{e}.lambda $1_{ev}.part|do-PROG(det|the($2,n|man($2)),$0,$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|be&3S($0($1),$1)   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
sem is  lambda $0_{ev}.Q(v|want(pro|you,det|a($1,n|cookie($1)),$0),$0)
sem is  lambda $0_{ev}.Q(aux|can(v|do(pro|you,pro|it,$0),$0),$0)
sem is  lambda $0_{ev}.adv:loc|there($0)
sem is  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
sem is  lambda $0_{ev}.eq(pro|it,det|a($1,n|baby($1)),$0)
size of chart is  1175
got chart
norm score is  -26.4581822606
doing updates with learning rate  0.034605103925
Deleting 0 entries of the total 5729
done io
WATCH	can you do it ?
WATCH	17	((S\NP)\NP)	0.674476207756
WATCH	17	((S\NP)/NP)	0.00161429323349
WATCH	17	((S/NP)/NP)	0.321898398517
WATCH	17	((S/NP)\NP)	0.00201110049357
getting topparses
outputting cat probs
done with sent


making  lambda $0_{e}.lambda $1_{ev}.aux|be&3S(part|do-PROG(det|the($2,n|man($2)),$0,$1),$1)
making  lambda $1_{ev}.aux|be&3S(part|do-PROG(det|the($2,n|man($2)),$0,$1),$1)
making  aux|be&3S(part|do-PROG(det|the($2,n|man($2)),$0,$1),$1)
making  part|do-PROG(det|the($2,n|man($2)),$0,$1)
making  det|the($2,n|man($2))
making  n|man($2)
making  $2
making  $0
making  $1
making  $1
sentence is  there .
making  lambda $0_{ev}.Q(v|want(pro|you,det|a($1,n|cookie($1)),$0),$0)
making  Q(v|want(pro|you,det|a($1,n|cookie($1)),$0),$0)
making  v|want(pro|you,det|a($1,n|cookie($1)),$0),$0)
making  pro|you
making  det|a($1,n|cookie($1))
making  n|cookie($1)
making  $1
making  $0
making  $0)
Is Q
sentence is  there .
making  lambda $0_{ev}.Q(aux|can(v|do(pro|you,pro|it,$0),$0),$0)
making  Q(aux|can(v|do(pro|you,pro|it,$0),$0),$0)
making  aux|can(v|do(pro|you,pro|it,$0),$0),$0)
making  v|do(pro|you,pro|it,$0)
making  pro|you
making  pro|it
making  $0
making  $0
making  $0)
Is Q
sentence is  there .
making  lambda $0_{ev}.adv:loc|there($0)
making  adv:loc|there($0)
making  $0
sentence is  there .
making  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  eq($0,pro:dem|that,$1)
making  $0,pro:dem|that,$1)
making  pro:dem|that,$1)
making  $1)
sentence is  there .
making  lambda $0_{ev}.eq(pro|it,det|a($1,n|baby($1)),$0)
making  eq(pro|it,det|a($1,n|baby($1)),$0)
making  pro|it,det|a($1,n|baby($1)),$0)
making  det|a($1,n|baby($1)),$0)
making  n|baby($1)
making  $1
making  $0)
sentence is  there .
making  lambda $0_{ev}.not(aux|can(v|read&ZERO(n:prop|Mommy,$0),$0),$0)
making  not(aux|can(v|read&ZERO(n:prop|Mommy,$0),$0),$0)
making  aux|can(v|read&ZERO(n:prop|Mommy,$0),$0),$0)
making  v|read&ZERO(n:prop|Mommy,$0)
making  n:prop|Mommy
making  $0
making  $0
making  $0)
sentence is  there .

got training pair
Sent : there .
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.aux|be&3S(part|do-PROG(det|the($2,n|man($2)),$0,$1),$1)
Cat : Syn:lambda $0_{ev}.Q(v|want(pro|you,det|a($1,n|cookie($1)),$0),$0)
Cat : Syn:lambda $0_{ev}.Q(aux|can(v|do(pro|you,pro|it,$0),$0),$0)
Cat : S:lambda $0_{ev}.adv:loc|there($0)
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
Cat : S:lambda $0_{ev}.eq(pro|it,det|a($1,n|baby($1)),$0)
Cat : S:lambda $0_{ev}.not(aux|can(v|read&ZERO(n:prop|Mommy,$0),$0),$0)
sentence is  ['there']
sem is  lambda $0_{e}.lambda $1_{ev}.aux|be&3S(part|do-PROG(det|the($2,n|man($2)),$0,$1),$1)
sem is  lambda $0_{ev}.Q(v|want(pro|you,det|a($1,n|cookie($1)),$0),$0)
sem is  lambda $0_{ev}.Q(aux|can(v|do(pro|you,pro|it,$0),$0),$0)
sem is  lambda $0_{ev}.adv:loc|there($0)
sem is  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
sem is  lambda $0_{ev}.eq(pro|it,det|a($1,n|baby($1)),$0)
sem is  lambda $0_{ev}.not(aux|can(v|read&ZERO(n:prop|Mommy,$0),$0),$0)
size of chart is  7
got chart
norm score is  -10.7250645735
doing updates with learning rate  0.0341973828006
Deleting 0 entries of the total 5736
done io
WATCH	there .
WATCH	18	((S\NP)\NP)	0.674501980832
WATCH	18	((S\NP)/NP)	0.00160308129835
WATCH	18	((S/NP)/NP)	0.321899469975
WATCH	18	((S/NP)\NP)	0.00199546789456
getting topparses
outputting cat probs
done with sent


making  lambda $0_{ev}.Q(v|want(pro|you,det|a($1,n|cookie($1)),$0),$0)
making  Q(v|want(pro|you,det|a($1,n|cookie($1)),$0),$0)
making  v|want(pro|you,det|a($1,n|cookie($1)),$0),$0)
making  pro|you
making  det|a($1,n|cookie($1))
making  n|cookie($1)
making  $1
making  $0
making  $0)
Is Q
sentence is  what 's that ?
making  lambda $0_{ev}.Q(aux|can(v|do(pro|you,pro|it,$0),$0),$0)
making  Q(aux|can(v|do(pro|you,pro|it,$0),$0),$0)
making  aux|can(v|do(pro|you,pro|it,$0),$0),$0)
making  v|do(pro|you,pro|it,$0)
making  pro|you
making  pro|it
making  $0
making  $0
making  $0)
Is Q
sentence is  what 's that ?
making  lambda $0_{ev}.adv:loc|there($0)
making  adv:loc|there($0)
making  $0
sentence is  what 's that ?
making  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  eq($0,pro:dem|that,$1)
making  $0,pro:dem|that,$1)
making  pro:dem|that,$1)
making  $1)
sentence is  what 's that ?
making  lambda $0_{ev}.eq(pro|it,det|a($1,n|baby($1)),$0)
making  eq(pro|it,det|a($1,n|baby($1)),$0)
making  pro|it,det|a($1,n|baby($1)),$0)
making  det|a($1,n|baby($1)),$0)
making  n|baby($1)
making  $1
making  $0)
sentence is  what 's that ?
making  lambda $0_{ev}.not(aux|can(v|read&ZERO(n:prop|Mommy,$0),$0),$0)
making  not(aux|can(v|read&ZERO(n:prop|Mommy,$0),$0),$0)
making  aux|can(v|read&ZERO(n:prop|Mommy,$0),$0),$0)
making  v|read&ZERO(n:prop|Mommy,$0)
making  n:prop|Mommy
making  $0
making  $0
making  $0)
sentence is  what 's that ?
making  adj|busy(pro|I)
making  pro|I
sentence is  what 's that ?

got training pair
Sent : what 's that ?
Cat : Syn:lambda $0_{ev}.Q(v|want(pro|you,det|a($1,n|cookie($1)),$0),$0)
Cat : Syn:lambda $0_{ev}.Q(aux|can(v|do(pro|you,pro|it,$0),$0),$0)
Cat : S:lambda $0_{ev}.adv:loc|there($0)
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
Cat : S:lambda $0_{ev}.eq(pro|it,det|a($1,n|baby($1)),$0)
Cat : S:lambda $0_{ev}.not(aux|can(v|read&ZERO(n:prop|Mommy,$0),$0),$0)
Cat : St:adj|busy(pro|I)
sentence is  ['what', "'s", 'that']
sem is  lambda $0_{ev}.Q(v|want(pro|you,det|a($1,n|cookie($1)),$0),$0)
sem is  lambda $0_{ev}.Q(aux|can(v|do(pro|you,pro|it,$0),$0),$0)
sem is  lambda $0_{ev}.adv:loc|there($0)
sem is  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
sem is  lambda $0_{ev}.eq(pro|it,det|a($1,n|baby($1)),$0)
sem is  lambda $0_{ev}.not(aux|can(v|read&ZERO(n:prop|Mommy,$0),$0),$0)
sem is  adj|busy(pro|I)
adding  St  to START
size of chart is  373
got chart
norm score is  -19.7127569613
doing updates with learning rate  0.0338003134226
Deleting 0 entries of the total 5927
done io
WATCH	what 's that ?
WATCH	19	((S\NP)\NP)	0.675225539757
WATCH	19	((S\NP)/NP)	0.00159327539501
WATCH	19	((S/NP)/NP)	0.321205935298
WATCH	19	((S/NP)\NP)	0.00197524955051
getting topparses
outputting cat probs
done with sent


making  lambda $0_{ev}.Q(aux|can(v|do(pro|you,pro|it,$0),$0),$0)
making  Q(aux|can(v|do(pro|you,pro|it,$0),$0),$0)
making  aux|can(v|do(pro|you,pro|it,$0),$0),$0)
making  v|do(pro|you,pro|it,$0)
making  pro|you
making  pro|it
making  $0
making  $0
making  $0)
Is Q
sentence is  it 's a baby .
making  lambda $0_{ev}.adv:loc|there($0)
making  adv:loc|there($0)
making  $0
sentence is  it 's a baby .
making  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  eq($0,pro:dem|that,$1)
making  $0,pro:dem|that,$1)
making  pro:dem|that,$1)
making  $1)
sentence is  it 's a baby .
making  lambda $0_{ev}.eq(pro|it,det|a($1,n|baby($1)),$0)
making  eq(pro|it,det|a($1,n|baby($1)),$0)
making  pro|it,det|a($1,n|baby($1)),$0)
making  det|a($1,n|baby($1)),$0)
making  n|baby($1)
making  $1
making  $0)
sentence is  it 's a baby .
making  lambda $0_{ev}.not(aux|can(v|read&ZERO(n:prop|Mommy,$0),$0),$0)
making  not(aux|can(v|read&ZERO(n:prop|Mommy,$0),$0),$0)
making  aux|can(v|read&ZERO(n:prop|Mommy,$0),$0),$0)
making  v|read&ZERO(n:prop|Mommy,$0)
making  n:prop|Mommy
making  $0
making  $0
making  $0)
sentence is  it 's a baby .
making  adj|busy(pro|I)
making  pro|I
sentence is  it 's a baby .
making  lambda $0_{ev}.v|read&ZERO(pro|you,det|the($1,n|book($1)),$0)
making  v|read&ZERO(pro|you,det|the($1,n|book($1)),$0)
making  pro|you
making  det|the($1,n|book($1))
making  n|book($1)
making  $1
making  $0
sentence is  it 's a baby .

got training pair
Sent : it 's a baby .
Cat : Syn:lambda $0_{ev}.Q(aux|can(v|do(pro|you,pro|it,$0),$0),$0)
Cat : S:lambda $0_{ev}.adv:loc|there($0)
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
Cat : S:lambda $0_{ev}.eq(pro|it,det|a($1,n|baby($1)),$0)
Cat : S:lambda $0_{ev}.not(aux|can(v|read&ZERO(n:prop|Mommy,$0),$0),$0)
Cat : St:adj|busy(pro|I)
Cat : S:lambda $0_{ev}.v|read&ZERO(pro|you,det|the($1,n|book($1)),$0)
sentence is  ['it', "'s", 'a', 'baby']
sem is  lambda $0_{ev}.Q(aux|can(v|do(pro|you,pro|it,$0),$0),$0)
sem is  lambda $0_{ev}.adv:loc|there($0)
sem is  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
sem is  lambda $0_{ev}.eq(pro|it,det|a($1,n|baby($1)),$0)
sem is  lambda $0_{ev}.not(aux|can(v|read&ZERO(n:prop|Mommy,$0),$0),$0)
sem is  adj|busy(pro|I)
sem is  lambda $0_{ev}.v|read&ZERO(pro|you,det|the($1,n|book($1)),$0)
size of chart is  928
got chart
norm score is  -24.5031177352
doing updates with learning rate  0.0334134691061
Deleting 0 entries of the total 6392
done io
WATCH	it 's a baby .
WATCH	20	((S\NP)\NP)	0.686444421801
WATCH	20	((S\NP)/NP)	0.00137370317241
WATCH	20	((S/NP)/NP)	0.310419663197
WATCH	20	((S/NP)\NP)	0.00176221183004
getting topparses
outputting cat probs
done with sent


making  lambda $0_{ev}.adv:loc|there($0)
making  adv:loc|there($0)
making  $0
sentence is  Mommy can 't read .
making  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  eq($0,pro:dem|that,$1)
making  $0,pro:dem|that,$1)
making  pro:dem|that,$1)
making  $1)
sentence is  Mommy can 't read .
making  lambda $0_{ev}.eq(pro|it,det|a($1,n|baby($1)),$0)
making  eq(pro|it,det|a($1,n|baby($1)),$0)
making  pro|it,det|a($1,n|baby($1)),$0)
making  det|a($1,n|baby($1)),$0)
making  n|baby($1)
making  $1
making  $0)
sentence is  Mommy can 't read .
making  lambda $0_{ev}.not(aux|can(v|read&ZERO(n:prop|Mommy,$0),$0),$0)
making  not(aux|can(v|read&ZERO(n:prop|Mommy,$0),$0),$0)
making  aux|can(v|read&ZERO(n:prop|Mommy,$0),$0),$0)
making  v|read&ZERO(n:prop|Mommy,$0)
making  n:prop|Mommy
making  $0
making  $0
making  $0)
sentence is  Mommy can 't read .
making  adj|busy(pro|I)
making  pro|I
sentence is  Mommy can 't read .
making  lambda $0_{ev}.v|read&ZERO(pro|you,det|the($1,n|book($1)),$0)
making  v|read&ZERO(pro|you,det|the($1,n|book($1)),$0)
making  pro|you
making  det|the($1,n|book($1))
making  n|book($1)
making  $1
making  $0
sentence is  Mommy can 't read .
making  lambda $0_{ev}.eq(pro:dem|that,det|the($1,n|stool($1)),$0)
making  eq(pro:dem|that,det|the($1,n|stool($1)),$0)
making  pro:dem|that,det|the($1,n|stool($1)),$0)
making  det|the($1,n|stool($1)),$0)
making  n|stool($1)
making  $1
making  $0)
sentence is  Mommy can 't read .

got training pair
Sent : Mommy can 't read .
Cat : S:lambda $0_{ev}.adv:loc|there($0)
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
Cat : S:lambda $0_{ev}.eq(pro|it,det|a($1,n|baby($1)),$0)
Cat : S:lambda $0_{ev}.not(aux|can(v|read&ZERO(n:prop|Mommy,$0),$0),$0)
Cat : St:adj|busy(pro|I)
Cat : S:lambda $0_{ev}.v|read&ZERO(pro|you,det|the($1,n|book($1)),$0)
Cat : S:lambda $0_{ev}.eq(pro:dem|that,det|the($1,n|stool($1)),$0)
sentence is  ['Mommy', 'can', "'t", 'read']
sem is  lambda $0_{ev}.adv:loc|there($0)
sem is  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
sem is  lambda $0_{ev}.eq(pro|it,det|a($1,n|baby($1)),$0)
sem is  lambda $0_{ev}.not(aux|can(v|read&ZERO(n:prop|Mommy,$0),$0),$0)
sem is  adj|busy(pro|I)
sem is  lambda $0_{ev}.v|read&ZERO(pro|you,det|the($1,n|book($1)),$0)
sem is  lambda $0_{ev}.eq(pro:dem|that,det|the($1,n|stool($1)),$0)
size of chart is  760
got chart
norm score is  -31.0364760597
doing updates with learning rate  0.0330364460353
Deleting 6350 entries of the total 6916
done io
WATCH	Mommy can 't read .
WATCH	21	((S\NP)\NP)	0.629813908487
WATCH	21	((S\NP)/NP)	0.00419028533516
WATCH	21	((S/NP)/NP)	0.364435781085
WATCH	21	((S/NP)\NP)	0.00156002509306
getting topparses
outputting cat probs
done with sent


making  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  eq($0,pro:dem|that,$1)
making  $0,pro:dem|that,$1)
making  pro:dem|that,$1)
making  $1)
sentence is  I 'm busy .
making  lambda $0_{ev}.eq(pro|it,det|a($1,n|baby($1)),$0)
making  eq(pro|it,det|a($1,n|baby($1)),$0)
making  pro|it,det|a($1,n|baby($1)),$0)
making  det|a($1,n|baby($1)),$0)
making  n|baby($1)
making  $1
making  $0)
sentence is  I 'm busy .
making  lambda $0_{ev}.not(aux|can(v|read&ZERO(n:prop|Mommy,$0),$0),$0)
making  not(aux|can(v|read&ZERO(n:prop|Mommy,$0),$0),$0)
making  aux|can(v|read&ZERO(n:prop|Mommy,$0),$0),$0)
making  v|read&ZERO(n:prop|Mommy,$0)
making  n:prop|Mommy
making  $0
making  $0
making  $0)
sentence is  I 'm busy .
making  adj|busy(pro|I)
making  pro|I
sentence is  I 'm busy .
making  lambda $0_{ev}.v|read&ZERO(pro|you,det|the($1,n|book($1)),$0)
making  v|read&ZERO(pro|you,det|the($1,n|book($1)),$0)
making  pro|you
making  det|the($1,n|book($1))
making  n|book($1)
making  $1
making  $0
sentence is  I 'm busy .
making  lambda $0_{ev}.eq(pro:dem|that,det|the($1,n|stool($1)),$0)
making  eq(pro:dem|that,det|the($1,n|stool($1)),$0)
making  pro:dem|that,det|the($1,n|stool($1)),$0)
making  det|the($1,n|stool($1)),$0)
making  n|stool($1)
making  $1
making  $0)
sentence is  I 'm busy .
making  lambda $0_{ev}.Q(aux|do&PAST(v|eat(pro|you,pro|it,$0),$0),$0)
making  Q(aux|do&PAST(v|eat(pro|you,pro|it,$0),$0),$0)
making  aux|do&PAST(v|eat(pro|you,pro|it,$0),$0),$0)
making  v|eat(pro|you,pro|it,$0)
making  pro|you
making  pro|it
making  $0
making  $0
making  $0)
Is Q
sentence is  I 'm busy .

got training pair
Sent : I 'm busy .
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
Cat : S:lambda $0_{ev}.eq(pro|it,det|a($1,n|baby($1)),$0)
Cat : S:lambda $0_{ev}.not(aux|can(v|read&ZERO(n:prop|Mommy,$0),$0),$0)
Cat : St:adj|busy(pro|I)
Cat : S:lambda $0_{ev}.v|read&ZERO(pro|you,det|the($1,n|book($1)),$0)
Cat : S:lambda $0_{ev}.eq(pro:dem|that,det|the($1,n|stool($1)),$0)
Cat : Syn:lambda $0_{ev}.Q(aux|do&PAST(v|eat(pro|you,pro|it,$0),$0),$0)
sentence is  ['I', "'m", 'busy', '.']
sem is  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
sem is  lambda $0_{ev}.eq(pro|it,det|a($1,n|baby($1)),$0)
sem is  lambda $0_{ev}.not(aux|can(v|read&ZERO(n:prop|Mommy,$0),$0),$0)
sem is  adj|busy(pro|I)
sem is  lambda $0_{ev}.v|read&ZERO(pro|you,det|the($1,n|book($1)),$0)
sem is  lambda $0_{ev}.eq(pro:dem|that,det|the($1,n|stool($1)),$0)
sem is  lambda $0_{ev}.Q(aux|do&PAST(v|eat(pro|you,pro|it,$0),$0),$0)
size of chart is  1020
got chart
norm score is  -29.399482831
doing updates with learning rate  0.0326688617368
Deleting 0 entries of the total 1274
done io
WATCH	I 'm busy .
WATCH	22	((S\NP)\NP)	0.629609063502
WATCH	22	((S\NP)/NP)	0.00408076985299
WATCH	22	((S/NP)/NP)	0.364794506008
WATCH	22	((S/NP)\NP)	0.00151566063708
getting topparses
outputting cat probs
done with sent


making  lambda $0_{ev}.eq(pro|it,det|a($1,n|baby($1)),$0)
making  eq(pro|it,det|a($1,n|baby($1)),$0)
making  pro|it,det|a($1,n|baby($1)),$0)
making  det|a($1,n|baby($1)),$0)
making  n|baby($1)
making  $1
making  $0)
sentence is  you read the book .
making  lambda $0_{ev}.not(aux|can(v|read&ZERO(n:prop|Mommy,$0),$0),$0)
making  not(aux|can(v|read&ZERO(n:prop|Mommy,$0),$0),$0)
making  aux|can(v|read&ZERO(n:prop|Mommy,$0),$0),$0)
making  v|read&ZERO(n:prop|Mommy,$0)
making  n:prop|Mommy
making  $0
making  $0
making  $0)
sentence is  you read the book .
making  adj|busy(pro|I)
making  pro|I
sentence is  you read the book .
making  lambda $0_{ev}.v|read&ZERO(pro|you,det|the($1,n|book($1)),$0)
making  v|read&ZERO(pro|you,det|the($1,n|book($1)),$0)
making  pro|you
making  det|the($1,n|book($1))
making  n|book($1)
making  $1
making  $0
sentence is  you read the book .
making  lambda $0_{ev}.eq(pro:dem|that,det|the($1,n|stool($1)),$0)
making  eq(pro:dem|that,det|the($1,n|stool($1)),$0)
making  pro:dem|that,det|the($1,n|stool($1)),$0)
making  det|the($1,n|stool($1)),$0)
making  n|stool($1)
making  $1
making  $0)
sentence is  you read the book .
making  lambda $0_{ev}.Q(aux|do&PAST(v|eat(pro|you,pro|it,$0),$0),$0)
making  Q(aux|do&PAST(v|eat(pro|you,pro|it,$0),$0),$0)
making  aux|do&PAST(v|eat(pro|you,pro|it,$0),$0),$0)
making  v|eat(pro|you,pro|it,$0)
making  pro|you
making  pro|it
making  $0
making  $0
making  $0)
Is Q
sentence is  you read the book .
making  lambda $0_{ev}.v|eat&PAST(pro|you,pro|it,$0)
making  v|eat&PAST(pro|you,pro|it,$0)
making  pro|you
making  pro|it
making  $0
sentence is  you read the book .

got training pair
Sent : you read the book .
Cat : S:lambda $0_{ev}.eq(pro|it,det|a($1,n|baby($1)),$0)
Cat : S:lambda $0_{ev}.not(aux|can(v|read&ZERO(n:prop|Mommy,$0),$0),$0)
Cat : St:adj|busy(pro|I)
Cat : S:lambda $0_{ev}.v|read&ZERO(pro|you,det|the($1,n|book($1)),$0)
Cat : S:lambda $0_{ev}.eq(pro:dem|that,det|the($1,n|stool($1)),$0)
Cat : Syn:lambda $0_{ev}.Q(aux|do&PAST(v|eat(pro|you,pro|it,$0),$0),$0)
Cat : S:lambda $0_{ev}.v|eat&PAST(pro|you,pro|it,$0)
sentence is  ['you', 'read', 'the', 'book']
sem is  lambda $0_{ev}.eq(pro|it,det|a($1,n|baby($1)),$0)
sem is  lambda $0_{ev}.not(aux|can(v|read&ZERO(n:prop|Mommy,$0),$0),$0)
sem is  adj|busy(pro|I)
sem is  lambda $0_{ev}.v|read&ZERO(pro|you,det|the($1,n|book($1)),$0)
sem is  lambda $0_{ev}.eq(pro:dem|that,det|the($1,n|stool($1)),$0)
sem is  lambda $0_{ev}.Q(aux|do&PAST(v|eat(pro|you,pro|it,$0),$0),$0)
sem is  lambda $0_{ev}.v|eat&PAST(pro|you,pro|it,$0)
size of chart is  993
got chart
norm score is  -31.0055914499
doing updates with learning rate  0.0323103536745
Deleting 0 entries of the total 1993
done io
WATCH	you read the book .
WATCH	23	((S\NP)\NP)	0.647952032076
WATCH	23	((S\NP)/NP)	0.004051020686
WATCH	23	((S/NP)/NP)	0.346571383668
WATCH	23	((S/NP)\NP)	0.00142556356924
getting topparses
outputting cat probs
done with sent


making  lambda $0_{ev}.not(aux|can(v|read&ZERO(n:prop|Mommy,$0),$0),$0)
making  not(aux|can(v|read&ZERO(n:prop|Mommy,$0),$0),$0)
making  aux|can(v|read&ZERO(n:prop|Mommy,$0),$0),$0)
making  v|read&ZERO(n:prop|Mommy,$0)
making  n:prop|Mommy
making  $0
making  $0
making  $0)
sentence is  that 's the stool .
making  adj|busy(pro|I)
making  pro|I
sentence is  that 's the stool .
making  lambda $0_{ev}.v|read&ZERO(pro|you,det|the($1,n|book($1)),$0)
making  v|read&ZERO(pro|you,det|the($1,n|book($1)),$0)
making  pro|you
making  det|the($1,n|book($1))
making  n|book($1)
making  $1
making  $0
sentence is  that 's the stool .
making  lambda $0_{ev}.eq(pro:dem|that,det|the($1,n|stool($1)),$0)
making  eq(pro:dem|that,det|the($1,n|stool($1)),$0)
making  pro:dem|that,det|the($1,n|stool($1)),$0)
making  det|the($1,n|stool($1)),$0)
making  n|stool($1)
making  $1
making  $0)
sentence is  that 's the stool .
making  lambda $0_{ev}.Q(aux|do&PAST(v|eat(pro|you,pro|it,$0),$0),$0)
making  Q(aux|do&PAST(v|eat(pro|you,pro|it,$0),$0),$0)
making  aux|do&PAST(v|eat(pro|you,pro|it,$0),$0),$0)
making  v|eat(pro|you,pro|it,$0)
making  pro|you
making  pro|it
making  $0
making  $0
making  $0)
Is Q
sentence is  that 's the stool .
making  lambda $0_{ev}.v|eat&PAST(pro|you,pro|it,$0)
making  v|eat&PAST(pro|you,pro|it,$0)
making  pro|you
making  pro|it
making  $0
sentence is  that 's the stool .
making  lambda $0_{e}.n|milk($0)
making  n|milk($0)
making  $0
sentence is  that 's the stool .

got training pair
Sent : that 's the stool .
Cat : S:lambda $0_{ev}.not(aux|can(v|read&ZERO(n:prop|Mommy,$0),$0),$0)
Cat : St:adj|busy(pro|I)
Cat : S:lambda $0_{ev}.v|read&ZERO(pro|you,det|the($1,n|book($1)),$0)
Cat : S:lambda $0_{ev}.eq(pro:dem|that,det|the($1,n|stool($1)),$0)
Cat : Syn:lambda $0_{ev}.Q(aux|do&PAST(v|eat(pro|you,pro|it,$0),$0),$0)
Cat : S:lambda $0_{ev}.v|eat&PAST(pro|you,pro|it,$0)
Cat : Swh:lambda $0_{e}.n|milk($0)
sentence is  ['that', "'s", 'the', 'stool']
sem is  lambda $0_{ev}.not(aux|can(v|read&ZERO(n:prop|Mommy,$0),$0),$0)
sem is  adj|busy(pro|I)
sem is  lambda $0_{ev}.v|read&ZERO(pro|you,det|the($1,n|book($1)),$0)
sem is  lambda $0_{ev}.eq(pro:dem|that,det|the($1,n|stool($1)),$0)
sem is  lambda $0_{ev}.Q(aux|do&PAST(v|eat(pro|you,pro|it,$0),$0),$0)
sem is  lambda $0_{ev}.v|eat&PAST(pro|you,pro|it,$0)
sem is  lambda $0_{e}.n|milk($0)
size of chart is  911
got chart
norm score is  -27.0503068035
doing updates with learning rate  0.0319605779545
Deleting 0 entries of the total 2541
done io
WATCH	that 's the stool .
WATCH	24	((S\NP)\NP)	0.640128693269
WATCH	24	((S\NP)/NP)	0.00398228758984
WATCH	24	((S/NP)/NP)	0.354443567374
WATCH	24	((S/NP)\NP)	0.00144545176735
getting topparses
outputting cat probs
done with sent


making  adj|busy(pro|I)
making  pro|I
sentence is  did you eat it ?
making  lambda $0_{ev}.v|read&ZERO(pro|you,det|the($1,n|book($1)),$0)
making  v|read&ZERO(pro|you,det|the($1,n|book($1)),$0)
making  pro|you
making  det|the($1,n|book($1))
making  n|book($1)
making  $1
making  $0
sentence is  did you eat it ?
making  lambda $0_{ev}.eq(pro:dem|that,det|the($1,n|stool($1)),$0)
making  eq(pro:dem|that,det|the($1,n|stool($1)),$0)
making  pro:dem|that,det|the($1,n|stool($1)),$0)
making  det|the($1,n|stool($1)),$0)
making  n|stool($1)
making  $1
making  $0)
sentence is  did you eat it ?
making  lambda $0_{ev}.Q(aux|do&PAST(v|eat(pro|you,pro|it,$0),$0),$0)
making  Q(aux|do&PAST(v|eat(pro|you,pro|it,$0),$0),$0)
making  aux|do&PAST(v|eat(pro|you,pro|it,$0),$0),$0)
making  v|eat(pro|you,pro|it,$0)
making  pro|you
making  pro|it
making  $0
making  $0
making  $0)
Is Q
sentence is  did you eat it ?
making  lambda $0_{ev}.v|eat&PAST(pro|you,pro|it,$0)
making  v|eat&PAST(pro|you,pro|it,$0)
making  pro|you
making  pro|it
making  $0
sentence is  did you eat it ?
making  lambda $0_{e}.n|milk($0)
making  n|milk($0)
making  $0
sentence is  did you eat it ?
making  lambda $0_{ev}.not(aux|do(v|want(pro|you,lambda $1_{e}.n|milk($1),$0),$0),$0)
making  not(aux|do(v|want(pro|you,lambda $1_{e}.n|milk($1),$0),$0),$0)
making  aux|do(v|want(pro|you,lambda $1_{e}.n|milk($1),$0),$0),$0)
making  v|want(pro|you,lambda $1_{e}.n|milk($1),$0)
making  pro|you
making  lambda $1_{e}.n|milk($1)
making  n|milk($1)
making  $1
making  $0
making  $0
making  $0)
sentence is  did you eat it ?

got training pair
Sent : did you eat it ?
Cat : St:adj|busy(pro|I)
Cat : S:lambda $0_{ev}.v|read&ZERO(pro|you,det|the($1,n|book($1)),$0)
Cat : S:lambda $0_{ev}.eq(pro:dem|that,det|the($1,n|stool($1)),$0)
Cat : Syn:lambda $0_{ev}.Q(aux|do&PAST(v|eat(pro|you,pro|it,$0),$0),$0)
Cat : S:lambda $0_{ev}.v|eat&PAST(pro|you,pro|it,$0)
Cat : Swh:lambda $0_{e}.n|milk($0)
Cat : S:lambda $0_{ev}.not(aux|do(v|want(pro|you,lambda $1_{e}.n|milk($1),$0),$0),$0)
sentence is  ['did', 'you', 'eat', 'it']
sem is  adj|busy(pro|I)
sem is  lambda $0_{ev}.v|read&ZERO(pro|you,det|the($1,n|book($1)),$0)
sem is  lambda $0_{ev}.eq(pro:dem|that,det|the($1,n|stool($1)),$0)
sem is  lambda $0_{ev}.Q(aux|do&PAST(v|eat(pro|you,pro|it,$0),$0),$0)
sem is  lambda $0_{ev}.v|eat&PAST(pro|you,pro|it,$0)
sem is  lambda $0_{e}.n|milk($0)
sem is  lambda $0_{ev}.not(aux|do(v|want(pro|you,lambda $1_{e}.n|milk($1),$0),$0),$0)
size of chart is  1032
got chart
norm score is  -25.6474902678
doing updates with learning rate  0.0316192081304
Deleting 0 entries of the total 3201
done io
WATCH	did you eat it ?
WATCH	25	((S\NP)\NP)	0.617872323109
WATCH	25	((S\NP)/NP)	0.00383360732931
WATCH	25	((S/NP)/NP)	0.376923551661
WATCH	25	((S/NP)\NP)	0.00137051790067
getting topparses
outputting cat probs
done with sent


making  lambda $0_{ev}.v|read&ZERO(pro|you,det|the($1,n|book($1)),$0)
making  v|read&ZERO(pro|you,det|the($1,n|book($1)),$0)
making  pro|you
making  det|the($1,n|book($1))
making  n|book($1)
making  $1
making  $0
sentence is  you ate it .
making  lambda $0_{ev}.eq(pro:dem|that,det|the($1,n|stool($1)),$0)
making  eq(pro:dem|that,det|the($1,n|stool($1)),$0)
making  pro:dem|that,det|the($1,n|stool($1)),$0)
making  det|the($1,n|stool($1)),$0)
making  n|stool($1)
making  $1
making  $0)
sentence is  you ate it .
making  lambda $0_{ev}.Q(aux|do&PAST(v|eat(pro|you,pro|it,$0),$0),$0)
making  Q(aux|do&PAST(v|eat(pro|you,pro|it,$0),$0),$0)
making  aux|do&PAST(v|eat(pro|you,pro|it,$0),$0),$0)
making  v|eat(pro|you,pro|it,$0)
making  pro|you
making  pro|it
making  $0
making  $0
making  $0)
Is Q
sentence is  you ate it .
making  lambda $0_{ev}.v|eat&PAST(pro|you,pro|it,$0)
making  v|eat&PAST(pro|you,pro|it,$0)
making  pro|you
making  pro|it
making  $0
sentence is  you ate it .
making  lambda $0_{e}.n|milk($0)
making  n|milk($0)
making  $0
sentence is  you ate it .
making  lambda $0_{ev}.not(aux|do(v|want(pro|you,lambda $1_{e}.n|milk($1),$0),$0),$0)
making  not(aux|do(v|want(pro|you,lambda $1_{e}.n|milk($1),$0),$0),$0)
making  aux|do(v|want(pro|you,lambda $1_{e}.n|milk($1),$0),$0),$0)
making  v|want(pro|you,lambda $1_{e}.n|milk($1),$0)
making  pro|you
making  lambda $1_{e}.n|milk($1)
making  n|milk($1)
making  $1
making  $0
making  $0
making  $0)
sentence is  you ate it .
making  lambda $0_{ev}.and(aux|have(part|have&PERF(pro|you,qn|some($1,n|juice($1)),$0),$0),adv:int|just($0))
making  and(aux|have(part|have&PERF(pro|you,qn|some($1,n|juice($1)),$0),$0),adv:int|just($0))
making  aux|have(part|have&PERF(pro|you,qn|some($1,n|juice($1)),$0),$0)
making  part|have&PERF(pro|you,qn|some($1,n|juice($1)),$0)
making  pro|you
making  qn|some($1,n|juice($1))
making  n|juice($1)
making  $1
making  $0
making  $0
making  adv:int|just($0)
making  $0
sentence is  you ate it .

got training pair
Sent : you ate it .
Cat : S:lambda $0_{ev}.v|read&ZERO(pro|you,det|the($1,n|book($1)),$0)
Cat : S:lambda $0_{ev}.eq(pro:dem|that,det|the($1,n|stool($1)),$0)
Cat : Syn:lambda $0_{ev}.Q(aux|do&PAST(v|eat(pro|you,pro|it,$0),$0),$0)
Cat : S:lambda $0_{ev}.v|eat&PAST(pro|you,pro|it,$0)
Cat : Swh:lambda $0_{e}.n|milk($0)
Cat : S:lambda $0_{ev}.not(aux|do(v|want(pro|you,lambda $1_{e}.n|milk($1),$0),$0),$0)
Cat : S:lambda $0_{ev}.and(aux|have(part|have&PERF(pro|you,qn|some($1,n|juice($1)),$0),$0),adv:int|just($0))
sentence is  ['you', 'ate', 'it']
sem is  lambda $0_{ev}.v|read&ZERO(pro|you,det|the($1,n|book($1)),$0)
sem is  lambda $0_{ev}.eq(pro:dem|that,det|the($1,n|stool($1)),$0)
sem is  lambda $0_{ev}.Q(aux|do&PAST(v|eat(pro|you,pro|it,$0),$0),$0)
sem is  lambda $0_{ev}.v|eat&PAST(pro|you,pro|it,$0)
sem is  lambda $0_{e}.n|milk($0)
sem is  lambda $0_{ev}.not(aux|do(v|want(pro|you,lambda $1_{e}.n|milk($1),$0),$0),$0)
sem is  lambda $0_{ev}.and(aux|have(part|have&PERF(pro|you,qn|some($1,n|juice($1)),$0),$0),adv:int|just($0))
size of chart is  490
got chart
norm score is  -17.1670098751
doing updates with learning rate  0.0312859340997
Deleting 0 entries of the total 3466
done io
WATCH	you ate it .
WATCH	26	((S\NP)\NP)	0.65421256987
WATCH	26	((S\NP)/NP)	0.00475910438038
WATCH	26	((S/NP)/NP)	0.339803859027
WATCH	26	((S/NP)\NP)	0.00122446672245
getting topparses
outputting cat probs
done with sent


making  lambda $0_{ev}.eq(pro:dem|that,det|the($1,n|stool($1)),$0)
making  eq(pro:dem|that,det|the($1,n|stool($1)),$0)
making  pro:dem|that,det|the($1,n|stool($1)),$0)
making  det|the($1,n|stool($1)),$0)
making  n|stool($1)
making  $1
making  $0)
sentence is  milk ?
making  lambda $0_{ev}.Q(aux|do&PAST(v|eat(pro|you,pro|it,$0),$0),$0)
making  Q(aux|do&PAST(v|eat(pro|you,pro|it,$0),$0),$0)
making  aux|do&PAST(v|eat(pro|you,pro|it,$0),$0),$0)
making  v|eat(pro|you,pro|it,$0)
making  pro|you
making  pro|it
making  $0
making  $0
making  $0)
Is Q
sentence is  milk ?
making  lambda $0_{ev}.v|eat&PAST(pro|you,pro|it,$0)
making  v|eat&PAST(pro|you,pro|it,$0)
making  pro|you
making  pro|it
making  $0
sentence is  milk ?
making  lambda $0_{e}.n|milk($0)
making  n|milk($0)
making  $0
sentence is  milk ?
making  lambda $0_{ev}.not(aux|do(v|want(pro|you,lambda $1_{e}.n|milk($1),$0),$0),$0)
making  not(aux|do(v|want(pro|you,lambda $1_{e}.n|milk($1),$0),$0),$0)
making  aux|do(v|want(pro|you,lambda $1_{e}.n|milk($1),$0),$0),$0)
making  v|want(pro|you,lambda $1_{e}.n|milk($1),$0)
making  pro|you
making  lambda $1_{e}.n|milk($1)
making  n|milk($1)
making  $1
making  $0
making  $0
making  $0)
sentence is  milk ?
making  lambda $0_{ev}.and(aux|have(part|have&PERF(pro|you,qn|some($1,n|juice($1)),$0),$0),adv:int|just($0))
making  and(aux|have(part|have&PERF(pro|you,qn|some($1,n|juice($1)),$0),$0),adv:int|just($0))
making  aux|have(part|have&PERF(pro|you,qn|some($1,n|juice($1)),$0),$0)
making  part|have&PERF(pro|you,qn|some($1,n|juice($1)),$0)
making  pro|you
making  qn|some($1,n|juice($1))
making  n|juice($1)
making  $1
making  $0
making  $0
making  adv:int|just($0)
making  $0
sentence is  milk ?
making  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  eq($0,pro:dem|that,$1)
making  $0,pro:dem|that,$1)
making  pro:dem|that,$1)
making  $1)
sentence is  milk ?

got training pair
Sent : milk ?
Cat : S:lambda $0_{ev}.eq(pro:dem|that,det|the($1,n|stool($1)),$0)
Cat : Syn:lambda $0_{ev}.Q(aux|do&PAST(v|eat(pro|you,pro|it,$0),$0),$0)
Cat : S:lambda $0_{ev}.v|eat&PAST(pro|you,pro|it,$0)
Cat : Swh:lambda $0_{e}.n|milk($0)
Cat : S:lambda $0_{ev}.not(aux|do(v|want(pro|you,lambda $1_{e}.n|milk($1),$0),$0),$0)
Cat : S:lambda $0_{ev}.and(aux|have(part|have&PERF(pro|you,qn|some($1,n|juice($1)),$0),$0),adv:int|just($0))
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
sentence is  ['milk']
sem is  lambda $0_{ev}.eq(pro:dem|that,det|the($1,n|stool($1)),$0)
sem is  lambda $0_{ev}.Q(aux|do&PAST(v|eat(pro|you,pro|it,$0),$0),$0)
sem is  lambda $0_{ev}.v|eat&PAST(pro|you,pro|it,$0)
sem is  lambda $0_{e}.n|milk($0)
sem is  lambda $0_{ev}.not(aux|do(v|want(pro|you,lambda $1_{e}.n|milk($1),$0),$0),$0)
sem is  lambda $0_{ev}.and(aux|have(part|have&PERF(pro|you,qn|some($1,n|juice($1)),$0),$0),adv:int|just($0))
sem is  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
size of chart is  7
got chart
norm score is  -11.9239144599
doing updates with learning rate  0.0309604610838
Deleting 0 entries of the total 3473
done io
WATCH	milk ?
WATCH	27	((S\NP)\NP)	0.654242059633
WATCH	27	((S\NP)/NP)	0.00473913889772
WATCH	27	((S/NP)/NP)	0.33980537609
WATCH	27	((S/NP)\NP)	0.00121342537896
getting topparses
outputting cat probs
done with sent


making  lambda $0_{ev}.Q(aux|do&PAST(v|eat(pro|you,pro|it,$0),$0),$0)
making  Q(aux|do&PAST(v|eat(pro|you,pro|it,$0),$0),$0)
making  aux|do&PAST(v|eat(pro|you,pro|it,$0),$0),$0)
making  v|eat(pro|you,pro|it,$0)
making  pro|you
making  pro|it
making  $0
making  $0
making  $0)
Is Q
sentence is  you don 't want milk .
making  lambda $0_{ev}.v|eat&PAST(pro|you,pro|it,$0)
making  v|eat&PAST(pro|you,pro|it,$0)
making  pro|you
making  pro|it
making  $0
sentence is  you don 't want milk .
making  lambda $0_{e}.n|milk($0)
making  n|milk($0)
making  $0
sentence is  you don 't want milk .
making  lambda $0_{ev}.not(aux|do(v|want(pro|you,lambda $1_{e}.n|milk($1),$0),$0),$0)
making  not(aux|do(v|want(pro|you,lambda $1_{e}.n|milk($1),$0),$0),$0)
making  aux|do(v|want(pro|you,lambda $1_{e}.n|milk($1),$0),$0),$0)
making  v|want(pro|you,lambda $1_{e}.n|milk($1),$0)
making  pro|you
making  lambda $1_{e}.n|milk($1)
making  n|milk($1)
making  $1
making  $0
making  $0
making  $0)
sentence is  you don 't want milk .
making  lambda $0_{ev}.and(aux|have(part|have&PERF(pro|you,qn|some($1,n|juice($1)),$0),$0),adv:int|just($0))
making  and(aux|have(part|have&PERF(pro|you,qn|some($1,n|juice($1)),$0),$0),adv:int|just($0))
making  aux|have(part|have&PERF(pro|you,qn|some($1,n|juice($1)),$0),$0)
making  part|have&PERF(pro|you,qn|some($1,n|juice($1)),$0)
making  pro|you
making  qn|some($1,n|juice($1))
making  n|juice($1)
making  $1
making  $0
making  $0
making  adv:int|just($0)
making  $0
sentence is  you don 't want milk .
making  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  eq($0,pro:dem|that,$1)
making  $0,pro:dem|that,$1)
making  pro:dem|that,$1)
making  $1)
sentence is  you don 't want milk .
making  lambda $0_{ev}.v|drink(pro|you,det|the($1,n|water($1)),$0)
making  v|drink(pro|you,det|the($1,n|water($1)),$0)
making  pro|you
making  det|the($1,n|water($1))
making  n|water($1)
making  $1
making  $0
sentence is  you don 't want milk .

got training pair
Sent : you don 't want milk .
Cat : Syn:lambda $0_{ev}.Q(aux|do&PAST(v|eat(pro|you,pro|it,$0),$0),$0)
Cat : S:lambda $0_{ev}.v|eat&PAST(pro|you,pro|it,$0)
Cat : Swh:lambda $0_{e}.n|milk($0)
Cat : S:lambda $0_{ev}.not(aux|do(v|want(pro|you,lambda $1_{e}.n|milk($1),$0),$0),$0)
Cat : S:lambda $0_{ev}.and(aux|have(part|have&PERF(pro|you,qn|some($1,n|juice($1)),$0),$0),adv:int|just($0))
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
Cat : S:lambda $0_{ev}.v|drink(pro|you,det|the($1,n|water($1)),$0)
sentence is  ['you', 'don', "'t", 'want', 'milk']
sem is  lambda $0_{ev}.Q(aux|do&PAST(v|eat(pro|you,pro|it,$0),$0),$0)
sem is  lambda $0_{ev}.v|eat&PAST(pro|you,pro|it,$0)
sem is  lambda $0_{e}.n|milk($0)
sem is  lambda $0_{ev}.not(aux|do(v|want(pro|you,lambda $1_{e}.n|milk($1),$0),$0),$0)
sem is  lambda $0_{ev}.and(aux|have(part|have&PERF(pro|you,qn|some($1,n|juice($1)),$0),$0),adv:int|just($0))
sem is  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
sem is  lambda $0_{ev}.v|drink(pro|you,det|the($1,n|water($1)),$0)
size of chart is  4107
got chart
norm score is  -30.0544766473
doing updates with learning rate  0.030642508684
Deleting 0 entries of the total 5703
done io
WATCH	you don 't want milk .
WATCH	28	((S\NP)\NP)	0.678578833246
WATCH	28	((S\NP)/NP)	0.00486110744472
WATCH	28	((S/NP)/NP)	0.31544394827
WATCH	28	((S/NP)\NP)	0.00111611103856
getting topparses
outputting cat probs
done with sent


making  lambda $0_{ev}.v|eat&PAST(pro|you,pro|it,$0)
making  v|eat&PAST(pro|you,pro|it,$0)
making  pro|you
making  pro|it
making  $0
sentence is  you 've just had some juice .
making  lambda $0_{e}.n|milk($0)
making  n|milk($0)
making  $0
sentence is  you 've just had some juice .
making  lambda $0_{ev}.not(aux|do(v|want(pro|you,lambda $1_{e}.n|milk($1),$0),$0),$0)
making  not(aux|do(v|want(pro|you,lambda $1_{e}.n|milk($1),$0),$0),$0)
making  aux|do(v|want(pro|you,lambda $1_{e}.n|milk($1),$0),$0),$0)
making  v|want(pro|you,lambda $1_{e}.n|milk($1),$0)
making  pro|you
making  lambda $1_{e}.n|milk($1)
making  n|milk($1)
making  $1
making  $0
making  $0
making  $0)
sentence is  you 've just had some juice .
making  lambda $0_{ev}.and(aux|have(part|have&PERF(pro|you,qn|some($1,n|juice($1)),$0),$0),adv:int|just($0))
making  and(aux|have(part|have&PERF(pro|you,qn|some($1,n|juice($1)),$0),$0),adv:int|just($0))
making  aux|have(part|have&PERF(pro|you,qn|some($1,n|juice($1)),$0),$0)
making  part|have&PERF(pro|you,qn|some($1,n|juice($1)),$0)
making  pro|you
making  qn|some($1,n|juice($1))
making  n|juice($1)
making  $1
making  $0
making  $0
making  adv:int|just($0)
making  $0
sentence is  you 've just had some juice .
making  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  eq($0,pro:dem|that,$1)
making  $0,pro:dem|that,$1)
making  pro:dem|that,$1)
making  $1)
sentence is  you 've just had some juice .
making  lambda $0_{ev}.v|drink(pro|you,det|the($1,n|water($1)),$0)
making  v|drink(pro|you,det|the($1,n|water($1)),$0)
making  pro|you
making  det|the($1,n|water($1))
making  n|water($1)
making  $1
making  $0
sentence is  you 've just had some juice .
making  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  eq($0,pro:dem|that,$1)
making  $0,pro:dem|that,$1)
making  pro:dem|that,$1)
making  $1)
sentence is  you 've just had some juice .

got training pair
Sent : you 've just had some juice .
Cat : S:lambda $0_{ev}.v|eat&PAST(pro|you,pro|it,$0)
Cat : Swh:lambda $0_{e}.n|milk($0)
Cat : S:lambda $0_{ev}.not(aux|do(v|want(pro|you,lambda $1_{e}.n|milk($1),$0),$0),$0)
Cat : S:lambda $0_{ev}.and(aux|have(part|have&PERF(pro|you,qn|some($1,n|juice($1)),$0),$0),adv:int|just($0))
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
Cat : S:lambda $0_{ev}.v|drink(pro|you,det|the($1,n|water($1)),$0)
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
sentence is  ['you', "'ve", 'just', 'had', 'some', 'juice']
sem is  lambda $0_{ev}.v|eat&PAST(pro|you,pro|it,$0)
sem is  lambda $0_{e}.n|milk($0)
sem is  lambda $0_{ev}.not(aux|do(v|want(pro|you,lambda $1_{e}.n|milk($1),$0),$0),$0)
sem is  lambda $0_{ev}.and(aux|have(part|have&PERF(pro|you,qn|some($1,n|juice($1)),$0),$0),adv:int|just($0))
sem is  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
sem is  lambda $0_{ev}.v|drink(pro|you,det|the($1,n|water($1)),$0)
sem is  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
size of chart is  6670
got chart
norm score is  -51.6673015966
doing updates with learning rate  0.0303318100061
Deleting 0 entries of the total 8830
done io
WATCH	you 've just had some juice .
WATCH	29	((S\NP)\NP)	0.679704706509
WATCH	29	((S\NP)/NP)	0.0048946930212
WATCH	29	((S/NP)/NP)	0.314301622774
WATCH	29	((S/NP)\NP)	0.00109897769645
getting topparses
outputting cat probs
done with sent


making  lambda $0_{e}.n|milk($0)
making  n|milk($0)
making  $0
sentence is  what is that ?
making  lambda $0_{ev}.not(aux|do(v|want(pro|you,lambda $1_{e}.n|milk($1),$0),$0),$0)
making  not(aux|do(v|want(pro|you,lambda $1_{e}.n|milk($1),$0),$0),$0)
making  aux|do(v|want(pro|you,lambda $1_{e}.n|milk($1),$0),$0),$0)
making  v|want(pro|you,lambda $1_{e}.n|milk($1),$0)
making  pro|you
making  lambda $1_{e}.n|milk($1)
making  n|milk($1)
making  $1
making  $0
making  $0
making  $0)
sentence is  what is that ?
making  lambda $0_{ev}.and(aux|have(part|have&PERF(pro|you,qn|some($1,n|juice($1)),$0),$0),adv:int|just($0))
making  and(aux|have(part|have&PERF(pro|you,qn|some($1,n|juice($1)),$0),$0),adv:int|just($0))
making  aux|have(part|have&PERF(pro|you,qn|some($1,n|juice($1)),$0),$0)
making  part|have&PERF(pro|you,qn|some($1,n|juice($1)),$0)
making  pro|you
making  qn|some($1,n|juice($1))
making  n|juice($1)
making  $1
making  $0
making  $0
making  adv:int|just($0)
making  $0
sentence is  what is that ?
making  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  eq($0,pro:dem|that,$1)
making  $0,pro:dem|that,$1)
making  pro:dem|that,$1)
making  $1)
sentence is  what is that ?
making  lambda $0_{ev}.v|drink(pro|you,det|the($1,n|water($1)),$0)
making  v|drink(pro|you,det|the($1,n|water($1)),$0)
making  pro|you
making  det|the($1,n|water($1))
making  n|water($1)
making  $1
making  $0
sentence is  what is that ?
making  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  eq($0,pro:dem|that,$1)
making  $0,pro:dem|that,$1)
making  pro:dem|that,$1)
making  $1)
sentence is  what is that ?
making  lambda $0_{e}.n|coffee($0)
making  n|coffee($0)
making  $0
sentence is  what is that ?

got training pair
Sent : what is that ?
Cat : Swh:lambda $0_{e}.n|milk($0)
Cat : S:lambda $0_{ev}.not(aux|do(v|want(pro|you,lambda $1_{e}.n|milk($1),$0),$0),$0)
Cat : S:lambda $0_{ev}.and(aux|have(part|have&PERF(pro|you,qn|some($1,n|juice($1)),$0),$0),adv:int|just($0))
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
Cat : S:lambda $0_{ev}.v|drink(pro|you,det|the($1,n|water($1)),$0)
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
Cat : Swh:lambda $0_{e}.n|coffee($0)
sentence is  ['what', 'is', 'that']
sem is  lambda $0_{e}.n|milk($0)
sem is  lambda $0_{ev}.not(aux|do(v|want(pro|you,lambda $1_{e}.n|milk($1),$0),$0),$0)
sem is  lambda $0_{ev}.and(aux|have(part|have&PERF(pro|you,qn|some($1,n|juice($1)),$0),$0),adv:int|just($0))
sem is  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
sem is  lambda $0_{ev}.v|drink(pro|you,det|the($1,n|water($1)),$0)
sem is  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
sem is  lambda $0_{e}.n|coffee($0)
size of chart is  374
got chart
norm score is  -19.9825079835
doing updates with learning rate  0.0300281108495
Deleting 0 entries of the total 9115
done io
WATCH	what is that ?
WATCH	30	((S\NP)\NP)	0.676881538691
WATCH	30	((S\NP)/NP)	0.00443535554502
WATCH	30	((S/NP)/NP)	0.317707128598
WATCH	30	((S/NP)\NP)	0.000975977165971
getting topparses
outputting cat probs
done with sent


making  lambda $0_{ev}.not(aux|do(v|want(pro|you,lambda $1_{e}.n|milk($1),$0),$0),$0)
making  not(aux|do(v|want(pro|you,lambda $1_{e}.n|milk($1),$0),$0),$0)
making  aux|do(v|want(pro|you,lambda $1_{e}.n|milk($1),$0),$0),$0)
making  v|want(pro|you,lambda $1_{e}.n|milk($1),$0)
making  pro|you
making  lambda $1_{e}.n|milk($1)
making  n|milk($1)
making  $1
making  $0
making  $0
making  $0)
sentence is  drink the water .
making  lambda $0_{ev}.and(aux|have(part|have&PERF(pro|you,qn|some($1,n|juice($1)),$0),$0),adv:int|just($0))
making  and(aux|have(part|have&PERF(pro|you,qn|some($1,n|juice($1)),$0),$0),adv:int|just($0))
making  aux|have(part|have&PERF(pro|you,qn|some($1,n|juice($1)),$0),$0)
making  part|have&PERF(pro|you,qn|some($1,n|juice($1)),$0)
making  pro|you
making  qn|some($1,n|juice($1))
making  n|juice($1)
making  $1
making  $0
making  $0
making  adv:int|just($0)
making  $0
sentence is  drink the water .
making  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  eq($0,pro:dem|that,$1)
making  $0,pro:dem|that,$1)
making  pro:dem|that,$1)
making  $1)
sentence is  drink the water .
making  lambda $0_{ev}.v|drink(pro|you,det|the($1,n|water($1)),$0)
making  v|drink(pro|you,det|the($1,n|water($1)),$0)
making  pro|you
making  det|the($1,n|water($1))
making  n|water($1)
making  $1
making  $0
sentence is  drink the water .
making  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  eq($0,pro:dem|that,$1)
making  $0,pro:dem|that,$1)
making  pro:dem|that,$1)
making  $1)
sentence is  drink the water .
making  lambda $0_{e}.n|coffee($0)
making  n|coffee($0)
making  $0
sentence is  drink the water .
making  lambda $0_{ev}.aux|be&3S(part|drink-PROG(pro|he,pro:poss:det|his($1,n|coffee($1)),$0),$0)
making  aux|be&3S(part|drink-PROG(pro|he,pro:poss:det|his($1,n|coffee($1)),$0),$0)
making  part|drink-PROG(pro|he,pro:poss:det|his($1,n|coffee($1)),$0)
making  pro|he
making  pro:poss:det|his($1,n|coffee($1))
making  n|coffee($1)
making  $1
making  $0
making  $0
sentence is  drink the water .

got training pair
Sent : drink the water .
Cat : S:lambda $0_{ev}.not(aux|do(v|want(pro|you,lambda $1_{e}.n|milk($1),$0),$0),$0)
Cat : S:lambda $0_{ev}.and(aux|have(part|have&PERF(pro|you,qn|some($1,n|juice($1)),$0),$0),adv:int|just($0))
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
Cat : S:lambda $0_{ev}.v|drink(pro|you,det|the($1,n|water($1)),$0)
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
Cat : Swh:lambda $0_{e}.n|coffee($0)
Cat : S:lambda $0_{ev}.aux|be&3S(part|drink-PROG(pro|he,pro:poss:det|his($1,n|coffee($1)),$0),$0)
sentence is  ['drink', 'the', 'water']
sem is  lambda $0_{ev}.not(aux|do(v|want(pro|you,lambda $1_{e}.n|milk($1),$0),$0),$0)
sem is  lambda $0_{ev}.and(aux|have(part|have&PERF(pro|you,qn|some($1,n|juice($1)),$0),$0),adv:int|just($0))
sem is  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
sem is  lambda $0_{ev}.v|drink(pro|you,det|the($1,n|water($1)),$0)
sem is  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
sem is  lambda $0_{e}.n|coffee($0)
sem is  lambda $0_{ev}.aux|be&3S(part|drink-PROG(pro|he,pro:poss:det|his($1,n|coffee($1)),$0),$0)
size of chart is  452
got chart
norm score is  -23.6346838602
doing updates with learning rate  0.0297311689541
Deleting 8591 entries of the total 9474
done io
WATCH	drink the water .
WATCH	31	((S\NP)\NP)	0.679020749236
WATCH	31	((S\NP)/NP)	0.004430519868
WATCH	31	((S/NP)/NP)	0.315589516829
WATCH	31	((S/NP)\NP)	0.000959214066095
getting topparses
outputting cat probs
done with sent


making  lambda $0_{ev}.and(aux|have(part|have&PERF(pro|you,qn|some($1,n|juice($1)),$0),$0),adv:int|just($0))
making  and(aux|have(part|have&PERF(pro|you,qn|some($1,n|juice($1)),$0),$0),adv:int|just($0))
making  aux|have(part|have&PERF(pro|you,qn|some($1,n|juice($1)),$0),$0)
making  part|have&PERF(pro|you,qn|some($1,n|juice($1)),$0)
making  pro|you
making  qn|some($1,n|juice($1))
making  n|juice($1)
making  $1
making  $0
making  $0
making  adv:int|just($0)
making  $0
sentence is  what is that ?
making  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  eq($0,pro:dem|that,$1)
making  $0,pro:dem|that,$1)
making  pro:dem|that,$1)
making  $1)
sentence is  what is that ?
making  lambda $0_{ev}.v|drink(pro|you,det|the($1,n|water($1)),$0)
making  v|drink(pro|you,det|the($1,n|water($1)),$0)
making  pro|you
making  det|the($1,n|water($1))
making  n|water($1)
making  $1
making  $0
sentence is  what is that ?
making  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  eq($0,pro:dem|that,$1)
making  $0,pro:dem|that,$1)
making  pro:dem|that,$1)
making  $1)
sentence is  what is that ?
making  lambda $0_{e}.n|coffee($0)
making  n|coffee($0)
making  $0
sentence is  what is that ?
making  lambda $0_{ev}.aux|be&3S(part|drink-PROG(pro|he,pro:poss:det|his($1,n|coffee($1)),$0),$0)
making  aux|be&3S(part|drink-PROG(pro|he,pro:poss:det|his($1,n|coffee($1)),$0),$0)
making  part|drink-PROG(pro|he,pro:poss:det|his($1,n|coffee($1)),$0)
making  pro|he
making  pro:poss:det|his($1,n|coffee($1))
making  n|coffee($1)
making  $1
making  $0
making  $0
sentence is  what is that ?
making  lambda $0_{ev}.v|go(pro|you,$0)
making  v|go(pro|you,$0)
making  pro|you
making  $0
sentence is  what is that ?

got training pair
Sent : what is that ?
Cat : S:lambda $0_{ev}.and(aux|have(part|have&PERF(pro|you,qn|some($1,n|juice($1)),$0),$0),adv:int|just($0))
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
Cat : S:lambda $0_{ev}.v|drink(pro|you,det|the($1,n|water($1)),$0)
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
Cat : Swh:lambda $0_{e}.n|coffee($0)
Cat : S:lambda $0_{ev}.aux|be&3S(part|drink-PROG(pro|he,pro:poss:det|his($1,n|coffee($1)),$0),$0)
Cat : S:lambda $0_{ev}.v|go(pro|you,$0)
sentence is  ['what', 'is', 'that']
sem is  lambda $0_{ev}.and(aux|have(part|have&PERF(pro|you,qn|some($1,n|juice($1)),$0),$0),adv:int|just($0))
sem is  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
sem is  lambda $0_{ev}.v|drink(pro|you,det|the($1,n|water($1)),$0)
sem is  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
sem is  lambda $0_{e}.n|coffee($0)
sem is  lambda $0_{ev}.aux|be&3S(part|drink-PROG(pro|he,pro:poss:det|his($1,n|coffee($1)),$0),$0)
sem is  lambda $0_{ev}.v|go(pro|you,$0)
size of chart is  383
got chart
norm score is  -11.9051741689
doing updates with learning rate  0.0294407533
Deleting 0 entries of the total 1182
done io
WATCH	what is that ?
WATCH	32	((S\NP)\NP)	0.701238732412
WATCH	32	((S\NP)/NP)	0.00403251052617
WATCH	32	((S/NP)/NP)	0.293874831946
WATCH	32	((S/NP)\NP)	0.000853925116441
getting topparses
outputting cat probs
done with sent


making  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  eq($0,pro:dem|that,$1)
making  $0,pro:dem|that,$1)
making  pro:dem|that,$1)
making  $1)
sentence is  coffee .
making  lambda $0_{ev}.v|drink(pro|you,det|the($1,n|water($1)),$0)
making  v|drink(pro|you,det|the($1,n|water($1)),$0)
making  pro|you
making  det|the($1,n|water($1))
making  n|water($1)
making  $1
making  $0
sentence is  coffee .
making  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  eq($0,pro:dem|that,$1)
making  $0,pro:dem|that,$1)
making  pro:dem|that,$1)
making  $1)
sentence is  coffee .
making  lambda $0_{e}.n|coffee($0)
making  n|coffee($0)
making  $0
sentence is  coffee .
making  lambda $0_{ev}.aux|be&3S(part|drink-PROG(pro|he,pro:poss:det|his($1,n|coffee($1)),$0),$0)
making  aux|be&3S(part|drink-PROG(pro|he,pro:poss:det|his($1,n|coffee($1)),$0),$0)
making  part|drink-PROG(pro|he,pro:poss:det|his($1,n|coffee($1)),$0)
making  pro|he
making  pro:poss:det|his($1,n|coffee($1))
making  n|coffee($1)
making  $1
making  $0
making  $0
sentence is  coffee .
making  lambda $0_{ev}.v|go(pro|you,$0)
making  v|go(pro|you,$0)
making  pro|you
making  $0
sentence is  coffee .
making  lambda $0_{ev}.and(aux|will(v|have(pro|we,det|a($1,n|cookie($1)),$0),$0),adv|later($0))
making  and(aux|will(v|have(pro|we,det|a($1,n|cookie($1)),$0),$0),adv|later($0))
making  aux|will(v|have(pro|we,det|a($1,n|cookie($1)),$0),$0)
making  v|have(pro|we,det|a($1,n|cookie($1)),$0)
making  pro|we
making  det|a($1,n|cookie($1))
making  n|cookie($1)
making  $1
making  $0
making  $0
making  adv|later($0)
making  $0
sentence is  coffee .

got training pair
Sent : coffee .
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
Cat : S:lambda $0_{ev}.v|drink(pro|you,det|the($1,n|water($1)),$0)
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
Cat : Swh:lambda $0_{e}.n|coffee($0)
Cat : S:lambda $0_{ev}.aux|be&3S(part|drink-PROG(pro|he,pro:poss:det|his($1,n|coffee($1)),$0),$0)
Cat : S:lambda $0_{ev}.v|go(pro|you,$0)
Cat : S:lambda $0_{ev}.and(aux|will(v|have(pro|we,det|a($1,n|cookie($1)),$0),$0),adv|later($0))
sentence is  ['coffee']
sem is  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
sem is  lambda $0_{ev}.v|drink(pro|you,det|the($1,n|water($1)),$0)
sem is  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
sem is  lambda $0_{e}.n|coffee($0)
sem is  lambda $0_{ev}.aux|be&3S(part|drink-PROG(pro|he,pro:poss:det|his($1,n|coffee($1)),$0),$0)
sem is  lambda $0_{ev}.v|go(pro|you,$0)
sem is  lambda $0_{ev}.and(aux|will(v|have(pro|we,det|a($1,n|cookie($1)),$0),$0),adv|later($0))
size of chart is  6
got chart
norm score is  -10.6669869097
doing updates with learning rate  0.0291566434574
Deleting 0 entries of the total 1188
done io
WATCH	coffee .
WATCH	33	((S\NP)\NP)	0.701266602162
WATCH	33	((S\NP)/NP)	0.00401694386593
WATCH	33	((S/NP)/NP)	0.293871124285
WATCH	33	((S/NP)\NP)	0.000845329687437
getting topparses
outputting cat probs
done with sent


making  lambda $0_{ev}.v|drink(pro|you,det|the($1,n|water($1)),$0)
making  v|drink(pro|you,det|the($1,n|water($1)),$0)
making  pro|you
making  det|the($1,n|water($1))
making  n|water($1)
making  $1
making  $0
sentence is  he 's drinking his coffee .
making  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  eq($0,pro:dem|that,$1)
making  $0,pro:dem|that,$1)
making  pro:dem|that,$1)
making  $1)
sentence is  he 's drinking his coffee .
making  lambda $0_{e}.n|coffee($0)
making  n|coffee($0)
making  $0
sentence is  he 's drinking his coffee .
making  lambda $0_{ev}.aux|be&3S(part|drink-PROG(pro|he,pro:poss:det|his($1,n|coffee($1)),$0),$0)
making  aux|be&3S(part|drink-PROG(pro|he,pro:poss:det|his($1,n|coffee($1)),$0),$0)
making  part|drink-PROG(pro|he,pro:poss:det|his($1,n|coffee($1)),$0)
making  pro|he
making  pro:poss:det|his($1,n|coffee($1))
making  n|coffee($1)
making  $1
making  $0
making  $0
sentence is  he 's drinking his coffee .
making  lambda $0_{ev}.v|go(pro|you,$0)
making  v|go(pro|you,$0)
making  pro|you
making  $0
sentence is  he 's drinking his coffee .
making  lambda $0_{ev}.and(aux|will(v|have(pro|we,det|a($1,n|cookie($1)),$0),$0),adv|later($0))
making  and(aux|will(v|have(pro|we,det|a($1,n|cookie($1)),$0),$0),adv|later($0))
making  aux|will(v|have(pro|we,det|a($1,n|cookie($1)),$0),$0)
making  v|have(pro|we,det|a($1,n|cookie($1)),$0)
making  pro|we
making  det|a($1,n|cookie($1))
making  n|cookie($1)
making  $1
making  $0
making  $0
making  adv|later($0)
making  $0
sentence is  he 's drinking his coffee .
making  lambda $0_{ev}.and(aux|will(v|have(pro|we,det|a($1,n|cookie($1)),$0),$0),adv|later($0))
making  and(aux|will(v|have(pro|we,det|a($1,n|cookie($1)),$0),$0),adv|later($0))
making  aux|will(v|have(pro|we,det|a($1,n|cookie($1)),$0),$0)
making  v|have(pro|we,det|a($1,n|cookie($1)),$0)
making  pro|we
making  det|a($1,n|cookie($1))
making  n|cookie($1)
making  $1
making  $0
making  $0
making  adv|later($0)
making  $0
sentence is  he 's drinking his coffee .

got training pair
Sent : he 's drinking his coffee .
Cat : S:lambda $0_{ev}.v|drink(pro|you,det|the($1,n|water($1)),$0)
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
Cat : Swh:lambda $0_{e}.n|coffee($0)
Cat : S:lambda $0_{ev}.aux|be&3S(part|drink-PROG(pro|he,pro:poss:det|his($1,n|coffee($1)),$0),$0)
Cat : S:lambda $0_{ev}.v|go(pro|you,$0)
Cat : S:lambda $0_{ev}.and(aux|will(v|have(pro|we,det|a($1,n|cookie($1)),$0),$0),adv|later($0))
Cat : S:lambda $0_{ev}.and(aux|will(v|have(pro|we,det|a($1,n|cookie($1)),$0),$0),adv|later($0))
sentence is  ['he', "'s", 'drinking', 'his', 'coffee']
sem is  lambda $0_{ev}.v|drink(pro|you,det|the($1,n|water($1)),$0)
sem is  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
sem is  lambda $0_{e}.n|coffee($0)
sem is  lambda $0_{ev}.aux|be&3S(part|drink-PROG(pro|he,pro:poss:det|his($1,n|coffee($1)),$0),$0)
sem is  lambda $0_{ev}.v|go(pro|you,$0)
sem is  lambda $0_{ev}.and(aux|will(v|have(pro|we,det|a($1,n|cookie($1)),$0),$0),adv|later($0))
sem is  lambda $0_{ev}.and(aux|will(v|have(pro|we,det|a($1,n|cookie($1)),$0),$0),adv|later($0))
size of chart is  3468
got chart
norm score is  -37.3092864858
doing updates with learning rate  0.02887862898
Deleting 0 entries of the total 3217
done io
WATCH	he 's drinking his coffee .
WATCH	34	((S\NP)\NP)	0.70355647863
WATCH	34	((S\NP)/NP)	0.00385453359876
WATCH	34	((S/NP)/NP)	0.29178567493
WATCH	34	((S/NP)\NP)	0.000803312841371
getting topparses
outputting cat probs
done with sent


making  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  eq($0,pro:dem|that,$1)
making  $0,pro:dem|that,$1)
making  pro:dem|that,$1)
making  $1)
sentence is  you go .
making  lambda $0_{e}.n|coffee($0)
making  n|coffee($0)
making  $0
sentence is  you go .
making  lambda $0_{ev}.aux|be&3S(part|drink-PROG(pro|he,pro:poss:det|his($1,n|coffee($1)),$0),$0)
making  aux|be&3S(part|drink-PROG(pro|he,pro:poss:det|his($1,n|coffee($1)),$0),$0)
making  part|drink-PROG(pro|he,pro:poss:det|his($1,n|coffee($1)),$0)
making  pro|he
making  pro:poss:det|his($1,n|coffee($1))
making  n|coffee($1)
making  $1
making  $0
making  $0
sentence is  you go .
making  lambda $0_{ev}.v|go(pro|you,$0)
making  v|go(pro|you,$0)
making  pro|you
making  $0
sentence is  you go .
making  lambda $0_{ev}.and(aux|will(v|have(pro|we,det|a($1,n|cookie($1)),$0),$0),adv|later($0))
making  and(aux|will(v|have(pro|we,det|a($1,n|cookie($1)),$0),$0),adv|later($0))
making  aux|will(v|have(pro|we,det|a($1,n|cookie($1)),$0),$0)
making  v|have(pro|we,det|a($1,n|cookie($1)),$0)
making  pro|we
making  det|a($1,n|cookie($1))
making  n|cookie($1)
making  $1
making  $0
making  $0
making  adv|later($0)
making  $0
sentence is  you go .
making  lambda $0_{ev}.and(aux|will(v|have(pro|we,det|a($1,n|cookie($1)),$0),$0),adv|later($0))
making  and(aux|will(v|have(pro|we,det|a($1,n|cookie($1)),$0),$0),adv|later($0))
making  aux|will(v|have(pro|we,det|a($1,n|cookie($1)),$0),$0)
making  v|have(pro|we,det|a($1,n|cookie($1)),$0)
making  pro|we
making  det|a($1,n|cookie($1))
making  n|cookie($1)
making  $1
making  $0
making  $0
making  adv|later($0)
making  $0
sentence is  you go .
making  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  eq($0,pro:dem|that,$1)
making  $0,pro:dem|that,$1)
making  pro:dem|that,$1)
making  $1)
sentence is  you go .

got training pair
Sent : you go .
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
Cat : Swh:lambda $0_{e}.n|coffee($0)
Cat : S:lambda $0_{ev}.aux|be&3S(part|drink-PROG(pro|he,pro:poss:det|his($1,n|coffee($1)),$0),$0)
Cat : S:lambda $0_{ev}.v|go(pro|you,$0)
Cat : S:lambda $0_{ev}.and(aux|will(v|have(pro|we,det|a($1,n|cookie($1)),$0),$0),adv|later($0))
Cat : S:lambda $0_{ev}.and(aux|will(v|have(pro|we,det|a($1,n|cookie($1)),$0),$0),adv|later($0))
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
sentence is  ['you', 'go']
sem is  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
sem is  lambda $0_{e}.n|coffee($0)
sem is  lambda $0_{ev}.aux|be&3S(part|drink-PROG(pro|he,pro:poss:det|his($1,n|coffee($1)),$0),$0)
sem is  lambda $0_{ev}.v|go(pro|you,$0)
sem is  lambda $0_{ev}.and(aux|will(v|have(pro|we,det|a($1,n|cookie($1)),$0),$0),adv|later($0))
sem is  lambda $0_{ev}.and(aux|will(v|have(pro|we,det|a($1,n|cookie($1)),$0),$0),adv|later($0))
sem is  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
size of chart is  71
got chart
norm score is  -11.8136207708
doing updates with learning rate  0.0286065088411
Deleting 0 entries of the total 3282
done io
WATCH	you go .
WATCH	35	((S\NP)\NP)	0.706924387697
WATCH	35	((S\NP)/NP)	0.00385763445115
WATCH	35	((S/NP)/NP)	0.288432133935
WATCH	35	((S/NP)\NP)	0.000785843916663
getting topparses
outputting cat probs
done with sent


making  lambda $0_{e}.n|coffee($0)
making  n|coffee($0)
making  $0
sentence is  later we 'll have a cookie .
making  lambda $0_{ev}.aux|be&3S(part|drink-PROG(pro|he,pro:poss:det|his($1,n|coffee($1)),$0),$0)
making  aux|be&3S(part|drink-PROG(pro|he,pro:poss:det|his($1,n|coffee($1)),$0),$0)
making  part|drink-PROG(pro|he,pro:poss:det|his($1,n|coffee($1)),$0)
making  pro|he
making  pro:poss:det|his($1,n|coffee($1))
making  n|coffee($1)
making  $1
making  $0
making  $0
sentence is  later we 'll have a cookie .
making  lambda $0_{ev}.v|go(pro|you,$0)
making  v|go(pro|you,$0)
making  pro|you
making  $0
sentence is  later we 'll have a cookie .
making  lambda $0_{ev}.and(aux|will(v|have(pro|we,det|a($1,n|cookie($1)),$0),$0),adv|later($0))
making  and(aux|will(v|have(pro|we,det|a($1,n|cookie($1)),$0),$0),adv|later($0))
making  aux|will(v|have(pro|we,det|a($1,n|cookie($1)),$0),$0)
making  v|have(pro|we,det|a($1,n|cookie($1)),$0)
making  pro|we
making  det|a($1,n|cookie($1))
making  n|cookie($1)
making  $1
making  $0
making  $0
making  adv|later($0)
making  $0
sentence is  later we 'll have a cookie .
making  lambda $0_{ev}.and(aux|will(v|have(pro|we,det|a($1,n|cookie($1)),$0),$0),adv|later($0))
making  and(aux|will(v|have(pro|we,det|a($1,n|cookie($1)),$0),$0),adv|later($0))
making  aux|will(v|have(pro|we,det|a($1,n|cookie($1)),$0),$0)
making  v|have(pro|we,det|a($1,n|cookie($1)),$0)
making  pro|we
making  det|a($1,n|cookie($1))
making  n|cookie($1)
making  $1
making  $0
making  $0
making  adv|later($0)
making  $0
sentence is  later we 'll have a cookie .
making  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  eq($0,pro:dem|that,$1)
making  $0,pro:dem|that,$1)
making  pro:dem|that,$1)
making  $1)
sentence is  later we 'll have a cookie .
making  lambda $0_{ev}.Q(pro:poss:det|your($1,n|hat($1)),$0)
making  Q(pro:poss:det|your($1,n|hat($1)),$0)
making  pro:poss:det|your($1,n|hat($1)),$0)
making  n|hat($1)
making  $1
making  $0)
Is Q
sentence is  later we 'll have a cookie .

got training pair
Sent : later we 'll have a cookie .
Cat : Swh:lambda $0_{e}.n|coffee($0)
Cat : S:lambda $0_{ev}.aux|be&3S(part|drink-PROG(pro|he,pro:poss:det|his($1,n|coffee($1)),$0),$0)
Cat : S:lambda $0_{ev}.v|go(pro|you,$0)
Cat : S:lambda $0_{ev}.and(aux|will(v|have(pro|we,det|a($1,n|cookie($1)),$0),$0),adv|later($0))
Cat : S:lambda $0_{ev}.and(aux|will(v|have(pro|we,det|a($1,n|cookie($1)),$0),$0),adv|later($0))
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
Cat : Syn:lambda $0_{ev}.Q(pro:poss:det|your($1,n|hat($1)),$0)
sentence is  ['later', 'we', "'ll", 'have', 'a', 'cookie', '.']
sem is  lambda $0_{e}.n|coffee($0)
sem is  lambda $0_{ev}.aux|be&3S(part|drink-PROG(pro|he,pro:poss:det|his($1,n|coffee($1)),$0),$0)
sem is  lambda $0_{ev}.v|go(pro|you,$0)
sem is  lambda $0_{ev}.and(aux|will(v|have(pro|we,det|a($1,n|cookie($1)),$0),$0),adv|later($0))
sem is  lambda $0_{ev}.and(aux|will(v|have(pro|we,det|a($1,n|cookie($1)),$0),$0),adv|later($0))
sem is  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
sem is  lambda $0_{ev}.Q(pro:poss:det|your($1,n|hat($1)),$0)
size of chart is  10626
got chart
norm score is  -61.5349026205
doing updates with learning rate  0.0283400909068
Deleting 0 entries of the total 7857
done io
WATCH	later we 'll have a cookie .
WATCH	36	((S\NP)\NP)	0.702086511162
WATCH	36	((S\NP)/NP)	0.00362398597746
WATCH	36	((S/NP)/NP)	0.293528953076
WATCH	36	((S/NP)\NP)	0.000760549784892
getting topparses
outputting cat probs
done with sent


making  lambda $0_{ev}.aux|be&3S(part|drink-PROG(pro|he,pro:poss:det|his($1,n|coffee($1)),$0),$0)
making  aux|be&3S(part|drink-PROG(pro|he,pro:poss:det|his($1,n|coffee($1)),$0),$0)
making  part|drink-PROG(pro|he,pro:poss:det|his($1,n|coffee($1)),$0)
making  pro|he
making  pro:poss:det|his($1,n|coffee($1))
making  n|coffee($1)
making  $1
making  $0
making  $0
sentence is  we 'll have a cookie later .
making  lambda $0_{ev}.v|go(pro|you,$0)
making  v|go(pro|you,$0)
making  pro|you
making  $0
sentence is  we 'll have a cookie later .
making  lambda $0_{ev}.and(aux|will(v|have(pro|we,det|a($1,n|cookie($1)),$0),$0),adv|later($0))
making  and(aux|will(v|have(pro|we,det|a($1,n|cookie($1)),$0),$0),adv|later($0))
making  aux|will(v|have(pro|we,det|a($1,n|cookie($1)),$0),$0)
making  v|have(pro|we,det|a($1,n|cookie($1)),$0)
making  pro|we
making  det|a($1,n|cookie($1))
making  n|cookie($1)
making  $1
making  $0
making  $0
making  adv|later($0)
making  $0
sentence is  we 'll have a cookie later .
making  lambda $0_{ev}.and(aux|will(v|have(pro|we,det|a($1,n|cookie($1)),$0),$0),adv|later($0))
making  and(aux|will(v|have(pro|we,det|a($1,n|cookie($1)),$0),$0),adv|later($0))
making  aux|will(v|have(pro|we,det|a($1,n|cookie($1)),$0),$0)
making  v|have(pro|we,det|a($1,n|cookie($1)),$0)
making  pro|we
making  det|a($1,n|cookie($1))
making  n|cookie($1)
making  $1
making  $0
making  $0
making  adv|later($0)
making  $0
sentence is  we 'll have a cookie later .
making  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  eq($0,pro:dem|that,$1)
making  $0,pro:dem|that,$1)
making  pro:dem|that,$1)
making  $1)
sentence is  we 'll have a cookie later .
making  lambda $0_{ev}.Q(pro:poss:det|your($1,n|hat($1)),$0)
making  Q(pro:poss:det|your($1,n|hat($1)),$0)
making  pro:poss:det|your($1,n|hat($1)),$0)
making  n|hat($1)
making  $1
making  $0)
Is Q
sentence is  we 'll have a cookie later .
making  lambda $0_{e}.lambda $1_{ev}.and(aux|do&PAST(v|do(pro|you,$0,$1),$1),prep|with(pro|it,$1))
making  lambda $1_{ev}.and(aux|do&PAST(v|do(pro|you,$0,$1),$1),prep|with(pro|it,$1))
making  and(aux|do&PAST(v|do(pro|you,$0,$1),$1),prep|with(pro|it,$1))
making  aux|do&PAST(v|do(pro|you,$0,$1),$1)
making  v|do(pro|you,$0,$1)
making  pro|you
making  $0
making  $1
making  $1
making  prep|with(pro|it,$1)
making  pro|it
making  $1
sentence is  we 'll have a cookie later .

got training pair
Sent : we 'll have a cookie later .
Cat : S:lambda $0_{ev}.aux|be&3S(part|drink-PROG(pro|he,pro:poss:det|his($1,n|coffee($1)),$0),$0)
Cat : S:lambda $0_{ev}.v|go(pro|you,$0)
Cat : S:lambda $0_{ev}.and(aux|will(v|have(pro|we,det|a($1,n|cookie($1)),$0),$0),adv|later($0))
Cat : S:lambda $0_{ev}.and(aux|will(v|have(pro|we,det|a($1,n|cookie($1)),$0),$0),adv|later($0))
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
Cat : Syn:lambda $0_{ev}.Q(pro:poss:det|your($1,n|hat($1)),$0)
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.and(aux|do&PAST(v|do(pro|you,$0,$1),$1),prep|with(pro|it,$1))
sentence is  ['we', "'ll", 'have', 'a', 'cookie', 'later']
sem is  lambda $0_{ev}.aux|be&3S(part|drink-PROG(pro|he,pro:poss:det|his($1,n|coffee($1)),$0),$0)
sem is  lambda $0_{ev}.v|go(pro|you,$0)
sem is  lambda $0_{ev}.and(aux|will(v|have(pro|we,det|a($1,n|cookie($1)),$0),$0),adv|later($0))
sem is  lambda $0_{ev}.and(aux|will(v|have(pro|we,det|a($1,n|cookie($1)),$0),$0),adv|later($0))
sem is  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
sem is  lambda $0_{ev}.Q(pro:poss:det|your($1,n|hat($1)),$0)
sem is  lambda $0_{e}.lambda $1_{ev}.and(aux|do&PAST(v|do(pro|you,$0,$1),$1),prep|with(pro|it,$1))
types dont match 2 :  (Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|with(pro|it,$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|with(pro|it,$1)) (S/NP):lambda $0_{e}.lambda $1_{ev}.aux|do&PAST(v|do(pro|you,$0,$1),$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|with(pro|it,$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
types dont match 2 :  (Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|with(pro|it,$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|with(pro|it,$1)) (S\NP):lambda $0_{e}.lambda $1_{ev}.aux|do&PAST(v|do(pro|you,$0,$1),$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|with(pro|it,$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
types dont match 2 :  (Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|with(pro|it,$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|with(pro|it,$1)) (S/NP):lambda $0_{e}.lambda $1_{ev}.aux|do&PAST(v|do(pro|you,$0,$1),$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|with(pro|it,$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
types dont match 2 :  (Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|with(pro|it,$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|with(pro|it,$1)) (S\NP):lambda $0_{e}.lambda $1_{ev}.aux|do&PAST(v|do(pro|you,$0,$1),$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|with(pro|it,$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
types dont match 2 :  (Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and(aux|do&PAST($0($1),$1),prep|with(pro|it,$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and(aux|do&PAST($0($1),$1),prep|with(pro|it,$1)) (S/NP):lambda $0_{e}.lambda $1_{ev}.v|do(pro|you,$0,$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and(aux|do&PAST($0($1),$1),prep|with(pro|it,$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
types dont match 2 :  (Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and(aux|do&PAST($0($1),$1),prep|with(pro|it,$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and(aux|do&PAST($0($1),$1),prep|with(pro|it,$1)) (S\NP):lambda $0_{e}.lambda $1_{ev}.v|do(pro|you,$0,$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and(aux|do&PAST($0($1),$1),prep|with(pro|it,$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
size of chart is  10734
got chart
norm score is  -28.5592885127
doing updates with learning rate  0.0280791914453
Deleting 0 entries of the total 9096
done io
WATCH	we 'll have a cookie later .
WATCH	37	((S\NP)\NP)	0.714709481811
WATCH	37	((S\NP)/NP)	0.00331778251845
WATCH	37	((S/NP)/NP)	0.281283022862
WATCH	37	((S/NP)\NP)	0.000689712808048
getting topparses
outputting cat probs
done with sent


making  lambda $0_{ev}.v|go(pro|you,$0)
making  v|go(pro|you,$0)
making  pro|you
making  $0
sentence is  what 's that ?
making  lambda $0_{ev}.and(aux|will(v|have(pro|we,det|a($1,n|cookie($1)),$0),$0),adv|later($0))
making  and(aux|will(v|have(pro|we,det|a($1,n|cookie($1)),$0),$0),adv|later($0))
making  aux|will(v|have(pro|we,det|a($1,n|cookie($1)),$0),$0)
making  v|have(pro|we,det|a($1,n|cookie($1)),$0)
making  pro|we
making  det|a($1,n|cookie($1))
making  n|cookie($1)
making  $1
making  $0
making  $0
making  adv|later($0)
making  $0
sentence is  what 's that ?
making  lambda $0_{ev}.and(aux|will(v|have(pro|we,det|a($1,n|cookie($1)),$0),$0),adv|later($0))
making  and(aux|will(v|have(pro|we,det|a($1,n|cookie($1)),$0),$0),adv|later($0))
making  aux|will(v|have(pro|we,det|a($1,n|cookie($1)),$0),$0)
making  v|have(pro|we,det|a($1,n|cookie($1)),$0)
making  pro|we
making  det|a($1,n|cookie($1))
making  n|cookie($1)
making  $1
making  $0
making  $0
making  adv|later($0)
making  $0
sentence is  what 's that ?
making  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  eq($0,pro:dem|that,$1)
making  $0,pro:dem|that,$1)
making  pro:dem|that,$1)
making  $1)
sentence is  what 's that ?
making  lambda $0_{ev}.Q(pro:poss:det|your($1,n|hat($1)),$0)
making  Q(pro:poss:det|your($1,n|hat($1)),$0)
making  pro:poss:det|your($1,n|hat($1)),$0)
making  n|hat($1)
making  $1
making  $0)
Is Q
sentence is  what 's that ?
making  lambda $0_{e}.lambda $1_{ev}.and(aux|do&PAST(v|do(pro|you,$0,$1),$1),prep|with(pro|it,$1))
making  lambda $1_{ev}.and(aux|do&PAST(v|do(pro|you,$0,$1),$1),prep|with(pro|it,$1))
making  and(aux|do&PAST(v|do(pro|you,$0,$1),$1),prep|with(pro|it,$1))
making  aux|do&PAST(v|do(pro|you,$0,$1),$1)
making  v|do(pro|you,$0,$1)
making  pro|you
making  $0
making  $1
making  $1
making  prep|with(pro|it,$1)
making  pro|it
making  $1
sentence is  what 's that ?
making  lambda $0_{ev}.v|give(pro|you,lambda $1_{e}.n|doll-DIM($1),pro:poss:det|her($2,n|bottle($2)),$0)
making  v|give(pro|you,lambda $1_{e}.n|doll-DIM($1),pro:poss:det|her($2,n|bottle($2)),$0)
making  pro|you
making  lambda $1_{e}.n|doll-DIM($1)
making  n|doll-DIM($1)
making  $1
making  pro:poss:det|her($2,n|bottle($2))
making  n|bottle($2)
making  $2
making  $0
sentence is  what 's that ?

got training pair
Sent : what 's that ?
Cat : S:lambda $0_{ev}.v|go(pro|you,$0)
Cat : S:lambda $0_{ev}.and(aux|will(v|have(pro|we,det|a($1,n|cookie($1)),$0),$0),adv|later($0))
Cat : S:lambda $0_{ev}.and(aux|will(v|have(pro|we,det|a($1,n|cookie($1)),$0),$0),adv|later($0))
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
Cat : Syn:lambda $0_{ev}.Q(pro:poss:det|your($1,n|hat($1)),$0)
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.and(aux|do&PAST(v|do(pro|you,$0,$1),$1),prep|with(pro|it,$1))
Cat : S:lambda $0_{ev}.v|give(pro|you,lambda $1_{e}.n|doll-DIM($1),pro:poss:det|her($2,n|bottle($2)),$0)
sentence is  ['what', "'s", 'that']
sem is  lambda $0_{ev}.v|go(pro|you,$0)
sem is  lambda $0_{ev}.and(aux|will(v|have(pro|we,det|a($1,n|cookie($1)),$0),$0),adv|later($0))
sem is  lambda $0_{ev}.and(aux|will(v|have(pro|we,det|a($1,n|cookie($1)),$0),$0),adv|later($0))
sem is  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
sem is  lambda $0_{ev}.Q(pro:poss:det|your($1,n|hat($1)),$0)
sem is  lambda $0_{e}.lambda $1_{ev}.and(aux|do&PAST(v|do(pro|you,$0,$1),$1),prep|with(pro|it,$1))
types dont match 2 :  (Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|with(pro|it,$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|with(pro|it,$1)) (S/NP):lambda $0_{e}.lambda $1_{ev}.aux|do&PAST(v|do(pro|you,$0,$1),$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|with(pro|it,$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
types dont match 2 :  (Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|with(pro|it,$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|with(pro|it,$1)) (S\NP):lambda $0_{e}.lambda $1_{ev}.aux|do&PAST(v|do(pro|you,$0,$1),$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|with(pro|it,$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
types dont match 2 :  (Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|with(pro|it,$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|with(pro|it,$1)) (S/NP):lambda $0_{e}.lambda $1_{ev}.aux|do&PAST(v|do(pro|you,$0,$1),$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|with(pro|it,$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
types dont match 2 :  (Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|with(pro|it,$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|with(pro|it,$1)) (S\NP):lambda $0_{e}.lambda $1_{ev}.aux|do&PAST(v|do(pro|you,$0,$1),$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|with(pro|it,$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
types dont match 2 :  (Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and(aux|do&PAST($0($1),$1),prep|with(pro|it,$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and(aux|do&PAST($0($1),$1),prep|with(pro|it,$1)) (S/NP):lambda $0_{e}.lambda $1_{ev}.v|do(pro|you,$0,$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and(aux|do&PAST($0($1),$1),prep|with(pro|it,$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
types dont match 2 :  (Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and(aux|do&PAST($0($1),$1),prep|with(pro|it,$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and(aux|do&PAST($0($1),$1),prep|with(pro|it,$1)) (S\NP):lambda $0_{e}.lambda $1_{ev}.v|do(pro|you,$0,$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and(aux|do&PAST($0($1),$1),prep|with(pro|it,$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
sem is  lambda $0_{ev}.v|give(pro|you,lambda $1_{e}.n|doll-DIM($1),pro:poss:det|her($2,n|bottle($2)),$0)
size of chart is  603
got chart
norm score is  -22.0368810386
doing updates with learning rate  0.0278236346674
Deleting 0 entries of the total 9433
done io
WATCH	what 's that ?
WATCH	38	((S\NP)\NP)	0.716490952767
WATCH	38	((S\NP)/NP)	0.00331084507623
WATCH	38	((S/NP)/NP)	0.279520622775
WATCH	38	((S/NP)\NP)	0.000677579382355
getting topparses
outputting cat probs
done with sent


making  lambda $0_{ev}.and(aux|will(v|have(pro|we,det|a($1,n|cookie($1)),$0),$0),adv|later($0))
making  and(aux|will(v|have(pro|we,det|a($1,n|cookie($1)),$0),$0),adv|later($0))
making  aux|will(v|have(pro|we,det|a($1,n|cookie($1)),$0),$0)
making  v|have(pro|we,det|a($1,n|cookie($1)),$0)
making  pro|we
making  det|a($1,n|cookie($1))
making  n|cookie($1)
making  $1
making  $0
making  $0
making  adv|later($0)
making  $0
sentence is  your hat ?
making  lambda $0_{ev}.and(aux|will(v|have(pro|we,det|a($1,n|cookie($1)),$0),$0),adv|later($0))
making  and(aux|will(v|have(pro|we,det|a($1,n|cookie($1)),$0),$0),adv|later($0))
making  aux|will(v|have(pro|we,det|a($1,n|cookie($1)),$0),$0)
making  v|have(pro|we,det|a($1,n|cookie($1)),$0)
making  pro|we
making  det|a($1,n|cookie($1))
making  n|cookie($1)
making  $1
making  $0
making  $0
making  adv|later($0)
making  $0
sentence is  your hat ?
making  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  eq($0,pro:dem|that,$1)
making  $0,pro:dem|that,$1)
making  pro:dem|that,$1)
making  $1)
sentence is  your hat ?
making  lambda $0_{ev}.Q(pro:poss:det|your($1,n|hat($1)),$0)
making  Q(pro:poss:det|your($1,n|hat($1)),$0)
making  pro:poss:det|your($1,n|hat($1)),$0)
making  n|hat($1)
making  $1
making  $0)
Is Q
sentence is  your hat ?
making  lambda $0_{e}.lambda $1_{ev}.and(aux|do&PAST(v|do(pro|you,$0,$1),$1),prep|with(pro|it,$1))
making  lambda $1_{ev}.and(aux|do&PAST(v|do(pro|you,$0,$1),$1),prep|with(pro|it,$1))
making  and(aux|do&PAST(v|do(pro|you,$0,$1),$1),prep|with(pro|it,$1))
making  aux|do&PAST(v|do(pro|you,$0,$1),$1)
making  v|do(pro|you,$0,$1)
making  pro|you
making  $0
making  $1
making  $1
making  prep|with(pro|it,$1)
making  pro|it
making  $1
sentence is  your hat ?
making  lambda $0_{ev}.v|give(pro|you,lambda $1_{e}.n|doll-DIM($1),pro:poss:det|her($2,n|bottle($2)),$0)
making  v|give(pro|you,lambda $1_{e}.n|doll-DIM($1),pro:poss:det|her($2,n|bottle($2)),$0)
making  pro|you
making  lambda $1_{e}.n|doll-DIM($1)
making  n|doll-DIM($1)
making  $1
making  pro:poss:det|her($2,n|bottle($2))
making  n|bottle($2)
making  $2
making  $0
sentence is  your hat ?
making  lambda $0_{e}.lambda $1_{ev}.aux|be&PRES(part|do-PROG(pro|you,$0,$1),$1)
making  lambda $1_{ev}.aux|be&PRES(part|do-PROG(pro|you,$0,$1),$1)
making  aux|be&PRES(part|do-PROG(pro|you,$0,$1),$1)
making  part|do-PROG(pro|you,$0,$1)
making  pro|you
making  $0
making  $1
making  $1
sentence is  your hat ?

got training pair
Sent : your hat ?
Cat : S:lambda $0_{ev}.and(aux|will(v|have(pro|we,det|a($1,n|cookie($1)),$0),$0),adv|later($0))
Cat : S:lambda $0_{ev}.and(aux|will(v|have(pro|we,det|a($1,n|cookie($1)),$0),$0),adv|later($0))
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
Cat : Syn:lambda $0_{ev}.Q(pro:poss:det|your($1,n|hat($1)),$0)
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.and(aux|do&PAST(v|do(pro|you,$0,$1),$1),prep|with(pro|it,$1))
Cat : S:lambda $0_{ev}.v|give(pro|you,lambda $1_{e}.n|doll-DIM($1),pro:poss:det|her($2,n|bottle($2)),$0)
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.aux|be&PRES(part|do-PROG(pro|you,$0,$1),$1)
sentence is  ['your', 'hat']
sem is  lambda $0_{ev}.and(aux|will(v|have(pro|we,det|a($1,n|cookie($1)),$0),$0),adv|later($0))
sem is  lambda $0_{ev}.and(aux|will(v|have(pro|we,det|a($1,n|cookie($1)),$0),$0),adv|later($0))
sem is  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
sem is  lambda $0_{ev}.Q(pro:poss:det|your($1,n|hat($1)),$0)
sem is  lambda $0_{e}.lambda $1_{ev}.and(aux|do&PAST(v|do(pro|you,$0,$1),$1),prep|with(pro|it,$1))
types dont match 2 :  (Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|with(pro|it,$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|with(pro|it,$1)) (S/NP):lambda $0_{e}.lambda $1_{ev}.aux|do&PAST(v|do(pro|you,$0,$1),$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|with(pro|it,$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
types dont match 2 :  (Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|with(pro|it,$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|with(pro|it,$1)) (S\NP):lambda $0_{e}.lambda $1_{ev}.aux|do&PAST(v|do(pro|you,$0,$1),$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|with(pro|it,$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
types dont match 2 :  (Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|with(pro|it,$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|with(pro|it,$1)) (S/NP):lambda $0_{e}.lambda $1_{ev}.aux|do&PAST(v|do(pro|you,$0,$1),$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|with(pro|it,$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
types dont match 2 :  (Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|with(pro|it,$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|with(pro|it,$1)) (S\NP):lambda $0_{e}.lambda $1_{ev}.aux|do&PAST(v|do(pro|you,$0,$1),$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|with(pro|it,$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
types dont match 2 :  (Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and(aux|do&PAST($0($1),$1),prep|with(pro|it,$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and(aux|do&PAST($0($1),$1),prep|with(pro|it,$1)) (S/NP):lambda $0_{e}.lambda $1_{ev}.v|do(pro|you,$0,$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and(aux|do&PAST($0($1),$1),prep|with(pro|it,$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
types dont match 2 :  (Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and(aux|do&PAST($0($1),$1),prep|with(pro|it,$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and(aux|do&PAST($0($1),$1),prep|with(pro|it,$1)) (S\NP):lambda $0_{e}.lambda $1_{ev}.v|do(pro|you,$0,$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and(aux|do&PAST($0($1),$1),prep|with(pro|it,$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
sem is  lambda $0_{ev}.v|give(pro|you,lambda $1_{e}.n|doll-DIM($1),pro:poss:det|her($2,n|bottle($2)),$0)
sem is  lambda $0_{e}.lambda $1_{ev}.aux|be&PRES(part|do-PROG(pro|you,$0,$1),$1)
types dont match 2 :  (Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|be&PRES($0($1),$1)   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|be&PRES($0($1),$1) (S/NP):lambda $0_{e}.lambda $1_{ev}.part|do-PROG(pro|you,$0,$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|be&PRES($0($1),$1)   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
types dont match 2 :  (Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|be&PRES($0($1),$1)   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|be&PRES($0($1),$1) (S\NP):lambda $0_{e}.lambda $1_{ev}.part|do-PROG(pro|you,$0,$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|be&PRES($0($1),$1)   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
size of chart is  120
got chart
norm score is  -16.1781504072
doing updates with learning rate  0.0275732522983
Deleting 0 entries of the total 9530
done io
WATCH	your hat ?
WATCH	39	((S\NP)\NP)	0.717062413848
WATCH	39	((S\NP)/NP)	0.00329954135939
WATCH	39	((S/NP)/NP)	0.278969205904
WATCH	39	((S/NP)\NP)	0.00066883888911
getting topparses
outputting cat probs
done with sent


making  lambda $0_{ev}.and(aux|will(v|have(pro|we,det|a($1,n|cookie($1)),$0),$0),adv|later($0))
making  and(aux|will(v|have(pro|we,det|a($1,n|cookie($1)),$0),$0),adv|later($0))
making  aux|will(v|have(pro|we,det|a($1,n|cookie($1)),$0),$0)
making  v|have(pro|we,det|a($1,n|cookie($1)),$0)
making  pro|we
making  det|a($1,n|cookie($1))
making  n|cookie($1)
making  $1
making  $0
making  $0
making  adv|later($0)
making  $0
sentence is  and what did you do with it ?
making  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  eq($0,pro:dem|that,$1)
making  $0,pro:dem|that,$1)
making  pro:dem|that,$1)
making  $1)
sentence is  and what did you do with it ?
making  lambda $0_{ev}.Q(pro:poss:det|your($1,n|hat($1)),$0)
making  Q(pro:poss:det|your($1,n|hat($1)),$0)
making  pro:poss:det|your($1,n|hat($1)),$0)
making  n|hat($1)
making  $1
making  $0)
Is Q
sentence is  and what did you do with it ?
making  lambda $0_{e}.lambda $1_{ev}.and(aux|do&PAST(v|do(pro|you,$0,$1),$1),prep|with(pro|it,$1))
making  lambda $1_{ev}.and(aux|do&PAST(v|do(pro|you,$0,$1),$1),prep|with(pro|it,$1))
making  and(aux|do&PAST(v|do(pro|you,$0,$1),$1),prep|with(pro|it,$1))
making  aux|do&PAST(v|do(pro|you,$0,$1),$1)
making  v|do(pro|you,$0,$1)
making  pro|you
making  $0
making  $1
making  $1
making  prep|with(pro|it,$1)
making  pro|it
making  $1
sentence is  and what did you do with it ?
making  lambda $0_{ev}.v|give(pro|you,lambda $1_{e}.n|doll-DIM($1),pro:poss:det|her($2,n|bottle($2)),$0)
making  v|give(pro|you,lambda $1_{e}.n|doll-DIM($1),pro:poss:det|her($2,n|bottle($2)),$0)
making  pro|you
making  lambda $1_{e}.n|doll-DIM($1)
making  n|doll-DIM($1)
making  $1
making  pro:poss:det|her($2,n|bottle($2))
making  n|bottle($2)
making  $2
making  $0
sentence is  and what did you do with it ?
making  lambda $0_{e}.lambda $1_{ev}.aux|be&PRES(part|do-PROG(pro|you,$0,$1),$1)
making  lambda $1_{ev}.aux|be&PRES(part|do-PROG(pro|you,$0,$1),$1)
making  aux|be&PRES(part|do-PROG(pro|you,$0,$1),$1)
making  part|do-PROG(pro|you,$0,$1)
making  pro|you
making  $0
making  $1
making  $1
sentence is  and what did you do with it ?
making  lambda $0_{e}.lambda $1_{ev}.aux|be&PRES(part|do-PROG(pro|you,$0,$1),$1)
making  lambda $1_{ev}.aux|be&PRES(part|do-PROG(pro|you,$0,$1),$1)
making  aux|be&PRES(part|do-PROG(pro|you,$0,$1),$1)
making  part|do-PROG(pro|you,$0,$1)
making  pro|you
making  $0
making  $1
making  $1
sentence is  and what did you do with it ?

got training pair
Sent : and what did you do with it ?
Cat : S:lambda $0_{ev}.and(aux|will(v|have(pro|we,det|a($1,n|cookie($1)),$0),$0),adv|later($0))
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
Cat : Syn:lambda $0_{ev}.Q(pro:poss:det|your($1,n|hat($1)),$0)
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.and(aux|do&PAST(v|do(pro|you,$0,$1),$1),prep|with(pro|it,$1))
Cat : S:lambda $0_{ev}.v|give(pro|you,lambda $1_{e}.n|doll-DIM($1),pro:poss:det|her($2,n|bottle($2)),$0)
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.aux|be&PRES(part|do-PROG(pro|you,$0,$1),$1)
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.aux|be&PRES(part|do-PROG(pro|you,$0,$1),$1)
sentence is  ['and', 'what', 'did', 'you', 'do', 'with', 'it']
sem is  lambda $0_{ev}.and(aux|will(v|have(pro|we,det|a($1,n|cookie($1)),$0),$0),adv|later($0))
sem is  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
sem is  lambda $0_{ev}.Q(pro:poss:det|your($1,n|hat($1)),$0)
sem is  lambda $0_{e}.lambda $1_{ev}.and(aux|do&PAST(v|do(pro|you,$0,$1),$1),prep|with(pro|it,$1))
types dont match 2 :  (Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|with(pro|it,$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|with(pro|it,$1)) (S/NP):lambda $0_{e}.lambda $1_{ev}.aux|do&PAST(v|do(pro|you,$0,$1),$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|with(pro|it,$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
types dont match 2 :  (Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|with(pro|it,$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|with(pro|it,$1)) (S\NP):lambda $0_{e}.lambda $1_{ev}.aux|do&PAST(v|do(pro|you,$0,$1),$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|with(pro|it,$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
types dont match 2 :  (Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|with(pro|it,$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|with(pro|it,$1)) (S/NP):lambda $0_{e}.lambda $1_{ev}.aux|do&PAST(v|do(pro|you,$0,$1),$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|with(pro|it,$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
types dont match 2 :  (Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|with(pro|it,$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|with(pro|it,$1)) (S\NP):lambda $0_{e}.lambda $1_{ev}.aux|do&PAST(v|do(pro|you,$0,$1),$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|with(pro|it,$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
types dont match 2 :  (Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and(aux|do&PAST($0($1),$1),prep|with(pro|it,$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and(aux|do&PAST($0($1),$1),prep|with(pro|it,$1)) (S/NP):lambda $0_{e}.lambda $1_{ev}.v|do(pro|you,$0,$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and(aux|do&PAST($0($1),$1),prep|with(pro|it,$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
types dont match 2 :  (Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and(aux|do&PAST($0($1),$1),prep|with(pro|it,$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and(aux|do&PAST($0($1),$1),prep|with(pro|it,$1)) (S\NP):lambda $0_{e}.lambda $1_{ev}.v|do(pro|you,$0,$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and(aux|do&PAST($0($1),$1),prep|with(pro|it,$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
sem is  lambda $0_{ev}.v|give(pro|you,lambda $1_{e}.n|doll-DIM($1),pro:poss:det|her($2,n|bottle($2)),$0)
sem is  lambda $0_{e}.lambda $1_{ev}.aux|be&PRES(part|do-PROG(pro|you,$0,$1),$1)
types dont match 2 :  (Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|be&PRES($0($1),$1)   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|be&PRES($0($1),$1) (S/NP):lambda $0_{e}.lambda $1_{ev}.part|do-PROG(pro|you,$0,$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|be&PRES($0($1),$1)   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
types dont match 2 :  (Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|be&PRES($0($1),$1)   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|be&PRES($0($1),$1) (S\NP):lambda $0_{e}.lambda $1_{ev}.part|do-PROG(pro|you,$0,$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|be&PRES($0($1),$1)   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
sem is  lambda $0_{e}.lambda $1_{ev}.aux|be&PRES(part|do-PROG(pro|you,$0,$1),$1)
size of chart is  18922
got chart
norm score is  -54.3208685528
doing updates with learning rate  0.0273278831761
Deleting 0 entries of the total 15420
done io
WATCH	and what did you do with it ?
WATCH	40	((S\NP)\NP)	0.708413609899
WATCH	40	((S\NP)/NP)	0.003126552327
WATCH	40	((S/NP)/NP)	0.287781358454
WATCH	40	((S/NP)\NP)	0.000678479320191
getting topparses
outputting cat probs
done with sent


making  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  eq($0,pro:dem|that,$1)
making  $0,pro:dem|that,$1)
making  pro:dem|that,$1)
making  $1)
sentence is  give dolly her bottle .
making  lambda $0_{ev}.Q(pro:poss:det|your($1,n|hat($1)),$0)
making  Q(pro:poss:det|your($1,n|hat($1)),$0)
making  pro:poss:det|your($1,n|hat($1)),$0)
making  n|hat($1)
making  $1
making  $0)
Is Q
sentence is  give dolly her bottle .
making  lambda $0_{e}.lambda $1_{ev}.and(aux|do&PAST(v|do(pro|you,$0,$1),$1),prep|with(pro|it,$1))
making  lambda $1_{ev}.and(aux|do&PAST(v|do(pro|you,$0,$1),$1),prep|with(pro|it,$1))
making  and(aux|do&PAST(v|do(pro|you,$0,$1),$1),prep|with(pro|it,$1))
making  aux|do&PAST(v|do(pro|you,$0,$1),$1)
making  v|do(pro|you,$0,$1)
making  pro|you
making  $0
making  $1
making  $1
making  prep|with(pro|it,$1)
making  pro|it
making  $1
sentence is  give dolly her bottle .
making  lambda $0_{ev}.v|give(pro|you,lambda $1_{e}.n|doll-DIM($1),pro:poss:det|her($2,n|bottle($2)),$0)
making  v|give(pro|you,lambda $1_{e}.n|doll-DIM($1),pro:poss:det|her($2,n|bottle($2)),$0)
making  pro|you
making  lambda $1_{e}.n|doll-DIM($1)
making  n|doll-DIM($1)
making  $1
making  pro:poss:det|her($2,n|bottle($2))
making  n|bottle($2)
making  $2
making  $0
sentence is  give dolly her bottle .
making  lambda $0_{e}.lambda $1_{ev}.aux|be&PRES(part|do-PROG(pro|you,$0,$1),$1)
making  lambda $1_{ev}.aux|be&PRES(part|do-PROG(pro|you,$0,$1),$1)
making  aux|be&PRES(part|do-PROG(pro|you,$0,$1),$1)
making  part|do-PROG(pro|you,$0,$1)
making  pro|you
making  $0
making  $1
making  $1
sentence is  give dolly her bottle .
making  lambda $0_{e}.lambda $1_{ev}.aux|be&PRES(part|do-PROG(pro|you,$0,$1),$1)
making  lambda $1_{ev}.aux|be&PRES(part|do-PROG(pro|you,$0,$1),$1)
making  aux|be&PRES(part|do-PROG(pro|you,$0,$1),$1)
making  part|do-PROG(pro|you,$0,$1)
making  pro|you
making  $0
making  $1
making  $1
sentence is  give dolly her bottle .
making  lambda $0_{e}.n|bottle($0)
making  n|bottle($0)
making  $0
sentence is  give dolly her bottle .

got training pair
Sent : give dolly her bottle .
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
Cat : Syn:lambda $0_{ev}.Q(pro:poss:det|your($1,n|hat($1)),$0)
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.and(aux|do&PAST(v|do(pro|you,$0,$1),$1),prep|with(pro|it,$1))
Cat : S:lambda $0_{ev}.v|give(pro|you,lambda $1_{e}.n|doll-DIM($1),pro:poss:det|her($2,n|bottle($2)),$0)
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.aux|be&PRES(part|do-PROG(pro|you,$0,$1),$1)
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.aux|be&PRES(part|do-PROG(pro|you,$0,$1),$1)
Cat : Swh:lambda $0_{e}.n|bottle($0)
sentence is  ['give', 'dolly', 'her', 'bottle']
sem is  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
sem is  lambda $0_{ev}.Q(pro:poss:det|your($1,n|hat($1)),$0)
sem is  lambda $0_{e}.lambda $1_{ev}.and(aux|do&PAST(v|do(pro|you,$0,$1),$1),prep|with(pro|it,$1))
types dont match 2 :  (Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|with(pro|it,$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|with(pro|it,$1)) (S/NP):lambda $0_{e}.lambda $1_{ev}.aux|do&PAST(v|do(pro|you,$0,$1),$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|with(pro|it,$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
types dont match 2 :  (Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|with(pro|it,$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|with(pro|it,$1)) (S\NP):lambda $0_{e}.lambda $1_{ev}.aux|do&PAST(v|do(pro|you,$0,$1),$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|with(pro|it,$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
types dont match 2 :  (Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|with(pro|it,$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|with(pro|it,$1)) (S/NP):lambda $0_{e}.lambda $1_{ev}.aux|do&PAST(v|do(pro|you,$0,$1),$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|with(pro|it,$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
types dont match 2 :  (Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|with(pro|it,$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|with(pro|it,$1)) (S\NP):lambda $0_{e}.lambda $1_{ev}.aux|do&PAST(v|do(pro|you,$0,$1),$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|with(pro|it,$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
types dont match 2 :  (Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and(aux|do&PAST($0($1),$1),prep|with(pro|it,$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and(aux|do&PAST($0($1),$1),prep|with(pro|it,$1)) (S/NP):lambda $0_{e}.lambda $1_{ev}.v|do(pro|you,$0,$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and(aux|do&PAST($0($1),$1),prep|with(pro|it,$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
types dont match 2 :  (Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and(aux|do&PAST($0($1),$1),prep|with(pro|it,$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and(aux|do&PAST($0($1),$1),prep|with(pro|it,$1)) (S\NP):lambda $0_{e}.lambda $1_{ev}.v|do(pro|you,$0,$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and(aux|do&PAST($0($1),$1),prep|with(pro|it,$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
sem is  lambda $0_{ev}.v|give(pro|you,lambda $1_{e}.n|doll-DIM($1),pro:poss:det|her($2,n|bottle($2)),$0)
sem is  lambda $0_{e}.lambda $1_{ev}.aux|be&PRES(part|do-PROG(pro|you,$0,$1),$1)
types dont match 2 :  (Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|be&PRES($0($1),$1)   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|be&PRES($0($1),$1) (S/NP):lambda $0_{e}.lambda $1_{ev}.part|do-PROG(pro|you,$0,$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|be&PRES($0($1),$1)   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
types dont match 2 :  (Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|be&PRES($0($1),$1)   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|be&PRES($0($1),$1) (S\NP):lambda $0_{e}.lambda $1_{ev}.part|do-PROG(pro|you,$0,$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|be&PRES($0($1),$1)   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
sem is  lambda $0_{e}.lambda $1_{ev}.aux|be&PRES(part|do-PROG(pro|you,$0,$1),$1)
sem is  lambda $0_{e}.n|bottle($0)
size of chart is  1661
got chart
norm score is  -41.7782009738
doing updates with learning rate  0.0270873728761
Deleting 15060 entries of the total 16185
done io
WATCH	give dolly her bottle .
WATCH	41	((S\NP)\NP)	0.702846632971
WATCH	41	((S\NP)/NP)	0.0030480826373
WATCH	41	((S/NP)/NP)	0.293423012038
WATCH	41	((S/NP)\NP)	0.00068227235345
getting topparses
outputting cat probs
done with sent


making  lambda $0_{ev}.Q(pro:poss:det|your($1,n|hat($1)),$0)
making  Q(pro:poss:det|your($1,n|hat($1)),$0)
making  pro:poss:det|your($1,n|hat($1)),$0)
making  n|hat($1)
making  $1
making  $0)
Is Q
sentence is  what are you doing ?
making  lambda $0_{e}.lambda $1_{ev}.and(aux|do&PAST(v|do(pro|you,$0,$1),$1),prep|with(pro|it,$1))
making  lambda $1_{ev}.and(aux|do&PAST(v|do(pro|you,$0,$1),$1),prep|with(pro|it,$1))
making  and(aux|do&PAST(v|do(pro|you,$0,$1),$1),prep|with(pro|it,$1))
making  aux|do&PAST(v|do(pro|you,$0,$1),$1)
making  v|do(pro|you,$0,$1)
making  pro|you
making  $0
making  $1
making  $1
making  prep|with(pro|it,$1)
making  pro|it
making  $1
sentence is  what are you doing ?
making  lambda $0_{ev}.v|give(pro|you,lambda $1_{e}.n|doll-DIM($1),pro:poss:det|her($2,n|bottle($2)),$0)
making  v|give(pro|you,lambda $1_{e}.n|doll-DIM($1),pro:poss:det|her($2,n|bottle($2)),$0)
making  pro|you
making  lambda $1_{e}.n|doll-DIM($1)
making  n|doll-DIM($1)
making  $1
making  pro:poss:det|her($2,n|bottle($2))
making  n|bottle($2)
making  $2
making  $0
sentence is  what are you doing ?
making  lambda $0_{e}.lambda $1_{ev}.aux|be&PRES(part|do-PROG(pro|you,$0,$1),$1)
making  lambda $1_{ev}.aux|be&PRES(part|do-PROG(pro|you,$0,$1),$1)
making  aux|be&PRES(part|do-PROG(pro|you,$0,$1),$1)
making  part|do-PROG(pro|you,$0,$1)
making  pro|you
making  $0
making  $1
making  $1
sentence is  what are you doing ?
making  lambda $0_{e}.lambda $1_{ev}.aux|be&PRES(part|do-PROG(pro|you,$0,$1),$1)
making  lambda $1_{ev}.aux|be&PRES(part|do-PROG(pro|you,$0,$1),$1)
making  aux|be&PRES(part|do-PROG(pro|you,$0,$1),$1)
making  part|do-PROG(pro|you,$0,$1)
making  pro|you
making  $0
making  $1
making  $1
sentence is  what are you doing ?
making  lambda $0_{e}.n|bottle($0)
making  n|bottle($0)
making  $0
sentence is  what are you doing ?
making  lambda $0_{ev}.Q(det|the($1,n|hat($1)),$0)
making  Q(det|the($1,n|hat($1)),$0)
making  det|the($1,n|hat($1)),$0)
making  n|hat($1)
making  $1
making  $0)
Is Q
sentence is  what are you doing ?

got training pair
Sent : what are you doing ?
Cat : Syn:lambda $0_{ev}.Q(pro:poss:det|your($1,n|hat($1)),$0)
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.and(aux|do&PAST(v|do(pro|you,$0,$1),$1),prep|with(pro|it,$1))
Cat : S:lambda $0_{ev}.v|give(pro|you,lambda $1_{e}.n|doll-DIM($1),pro:poss:det|her($2,n|bottle($2)),$0)
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.aux|be&PRES(part|do-PROG(pro|you,$0,$1),$1)
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.aux|be&PRES(part|do-PROG(pro|you,$0,$1),$1)
Cat : Swh:lambda $0_{e}.n|bottle($0)
Cat : Syn:lambda $0_{ev}.Q(det|the($1,n|hat($1)),$0)
sentence is  ['what', 'are', 'you', 'doing', '?']
sem is  lambda $0_{ev}.Q(pro:poss:det|your($1,n|hat($1)),$0)
sem is  lambda $0_{e}.lambda $1_{ev}.and(aux|do&PAST(v|do(pro|you,$0,$1),$1),prep|with(pro|it,$1))
types dont match 2 :  (Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|with(pro|it,$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|with(pro|it,$1)) (S/NP):lambda $0_{e}.lambda $1_{ev}.aux|do&PAST(v|do(pro|you,$0,$1),$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|with(pro|it,$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
types dont match 2 :  (Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|with(pro|it,$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|with(pro|it,$1)) (S\NP):lambda $0_{e}.lambda $1_{ev}.aux|do&PAST(v|do(pro|you,$0,$1),$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|with(pro|it,$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
types dont match 2 :  (Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|with(pro|it,$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|with(pro|it,$1)) (S/NP):lambda $0_{e}.lambda $1_{ev}.aux|do&PAST(v|do(pro|you,$0,$1),$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|with(pro|it,$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
types dont match 2 :  (Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|with(pro|it,$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|with(pro|it,$1)) (S\NP):lambda $0_{e}.lambda $1_{ev}.aux|do&PAST(v|do(pro|you,$0,$1),$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|with(pro|it,$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
types dont match 2 :  (Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and(aux|do&PAST($0($1),$1),prep|with(pro|it,$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and(aux|do&PAST($0($1),$1),prep|with(pro|it,$1)) (S/NP):lambda $0_{e}.lambda $1_{ev}.v|do(pro|you,$0,$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and(aux|do&PAST($0($1),$1),prep|with(pro|it,$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
types dont match 2 :  (Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and(aux|do&PAST($0($1),$1),prep|with(pro|it,$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and(aux|do&PAST($0($1),$1),prep|with(pro|it,$1)) (S\NP):lambda $0_{e}.lambda $1_{ev}.v|do(pro|you,$0,$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and(aux|do&PAST($0($1),$1),prep|with(pro|it,$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
sem is  lambda $0_{ev}.v|give(pro|you,lambda $1_{e}.n|doll-DIM($1),pro:poss:det|her($2,n|bottle($2)),$0)
sem is  lambda $0_{e}.lambda $1_{ev}.aux|be&PRES(part|do-PROG(pro|you,$0,$1),$1)
types dont match 2 :  (Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|be&PRES($0($1),$1)   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|be&PRES($0($1),$1) (S/NP):lambda $0_{e}.lambda $1_{ev}.part|do-PROG(pro|you,$0,$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|be&PRES($0($1),$1)   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
types dont match 2 :  (Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|be&PRES($0($1),$1)   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|be&PRES($0($1),$1) (S\NP):lambda $0_{e}.lambda $1_{ev}.part|do-PROG(pro|you,$0,$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|be&PRES($0($1),$1)   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
sem is  lambda $0_{e}.lambda $1_{ev}.aux|be&PRES(part|do-PROG(pro|you,$0,$1),$1)
sem is  lambda $0_{e}.n|bottle($0)
sem is  lambda $0_{ev}.Q(det|the($1,n|hat($1)),$0)
size of chart is  3928
got chart
norm score is  -36.1594192421
doing updates with learning rate  0.0268515733591
Deleting 0 entries of the total 2567
done io
WATCH	what are you doing ?
WATCH	42	((S\NP)\NP)	0.710901898972
WATCH	42	((S\NP)/NP)	0.00288345459881
WATCH	42	((S/NP)/NP)	0.285561360042
WATCH	42	((S/NP)\NP)	0.000653286387281
getting topparses
outputting cat probs
done with sent


making  lambda $0_{e}.lambda $1_{ev}.and(aux|do&PAST(v|do(pro|you,$0,$1),$1),prep|with(pro|it,$1))
making  lambda $1_{ev}.and(aux|do&PAST(v|do(pro|you,$0,$1),$1),prep|with(pro|it,$1))
making  and(aux|do&PAST(v|do(pro|you,$0,$1),$1),prep|with(pro|it,$1))
making  aux|do&PAST(v|do(pro|you,$0,$1),$1)
making  v|do(pro|you,$0,$1)
making  pro|you
making  $0
making  $1
making  $1
making  prep|with(pro|it,$1)
making  pro|it
making  $1
sentence is  what are you doing ?
making  lambda $0_{ev}.v|give(pro|you,lambda $1_{e}.n|doll-DIM($1),pro:poss:det|her($2,n|bottle($2)),$0)
making  v|give(pro|you,lambda $1_{e}.n|doll-DIM($1),pro:poss:det|her($2,n|bottle($2)),$0)
making  pro|you
making  lambda $1_{e}.n|doll-DIM($1)
making  n|doll-DIM($1)
making  $1
making  pro:poss:det|her($2,n|bottle($2))
making  n|bottle($2)
making  $2
making  $0
sentence is  what are you doing ?
making  lambda $0_{e}.lambda $1_{ev}.aux|be&PRES(part|do-PROG(pro|you,$0,$1),$1)
making  lambda $1_{ev}.aux|be&PRES(part|do-PROG(pro|you,$0,$1),$1)
making  aux|be&PRES(part|do-PROG(pro|you,$0,$1),$1)
making  part|do-PROG(pro|you,$0,$1)
making  pro|you
making  $0
making  $1
making  $1
sentence is  what are you doing ?
making  lambda $0_{e}.lambda $1_{ev}.aux|be&PRES(part|do-PROG(pro|you,$0,$1),$1)
making  lambda $1_{ev}.aux|be&PRES(part|do-PROG(pro|you,$0,$1),$1)
making  aux|be&PRES(part|do-PROG(pro|you,$0,$1),$1)
making  part|do-PROG(pro|you,$0,$1)
making  pro|you
making  $0
making  $1
making  $1
sentence is  what are you doing ?
making  lambda $0_{e}.n|bottle($0)
making  n|bottle($0)
making  $0
sentence is  what are you doing ?
making  lambda $0_{ev}.Q(det|the($1,n|hat($1)),$0)
making  Q(det|the($1,n|hat($1)),$0)
making  det|the($1,n|hat($1)),$0)
making  n|hat($1)
making  $1
making  $0)
Is Q
sentence is  what are you doing ?
making  lambda $0_{ev}.not(aux|do&3S(v|have(pro|he,det|a($1,n|hat($1)),$0),$0),$0)
making  not(aux|do&3S(v|have(pro|he,det|a($1,n|hat($1)),$0),$0),$0)
making  aux|do&3S(v|have(pro|he,det|a($1,n|hat($1)),$0),$0),$0)
making  v|have(pro|he,det|a($1,n|hat($1)),$0)
making  pro|he
making  det|a($1,n|hat($1))
making  n|hat($1)
making  $1
making  $0
making  $0
making  $0)
sentence is  what are you doing ?

got training pair
Sent : what are you doing ?
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.and(aux|do&PAST(v|do(pro|you,$0,$1),$1),prep|with(pro|it,$1))
Cat : S:lambda $0_{ev}.v|give(pro|you,lambda $1_{e}.n|doll-DIM($1),pro:poss:det|her($2,n|bottle($2)),$0)
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.aux|be&PRES(part|do-PROG(pro|you,$0,$1),$1)
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.aux|be&PRES(part|do-PROG(pro|you,$0,$1),$1)
Cat : Swh:lambda $0_{e}.n|bottle($0)
Cat : Syn:lambda $0_{ev}.Q(det|the($1,n|hat($1)),$0)
Cat : S:lambda $0_{ev}.not(aux|do&3S(v|have(pro|he,det|a($1,n|hat($1)),$0),$0),$0)
sentence is  ['what', 'are', 'you', 'doing']
sem is  lambda $0_{e}.lambda $1_{ev}.and(aux|do&PAST(v|do(pro|you,$0,$1),$1),prep|with(pro|it,$1))
types dont match 2 :  (Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|with(pro|it,$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|with(pro|it,$1)) (S/NP):lambda $0_{e}.lambda $1_{ev}.aux|do&PAST(v|do(pro|you,$0,$1),$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|with(pro|it,$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
types dont match 2 :  (Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|with(pro|it,$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|with(pro|it,$1)) (S\NP):lambda $0_{e}.lambda $1_{ev}.aux|do&PAST(v|do(pro|you,$0,$1),$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|with(pro|it,$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
types dont match 2 :  (Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|with(pro|it,$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|with(pro|it,$1)) (S/NP):lambda $0_{e}.lambda $1_{ev}.aux|do&PAST(v|do(pro|you,$0,$1),$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|with(pro|it,$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
types dont match 2 :  (Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|with(pro|it,$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|with(pro|it,$1)) (S\NP):lambda $0_{e}.lambda $1_{ev}.aux|do&PAST(v|do(pro|you,$0,$1),$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|with(pro|it,$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
types dont match 2 :  (Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and(aux|do&PAST($0($1),$1),prep|with(pro|it,$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and(aux|do&PAST($0($1),$1),prep|with(pro|it,$1)) (S/NP):lambda $0_{e}.lambda $1_{ev}.v|do(pro|you,$0,$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and(aux|do&PAST($0($1),$1),prep|with(pro|it,$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
types dont match 2 :  (Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and(aux|do&PAST($0($1),$1),prep|with(pro|it,$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and(aux|do&PAST($0($1),$1),prep|with(pro|it,$1)) (S\NP):lambda $0_{e}.lambda $1_{ev}.v|do(pro|you,$0,$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and(aux|do&PAST($0($1),$1),prep|with(pro|it,$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
sem is  lambda $0_{ev}.v|give(pro|you,lambda $1_{e}.n|doll-DIM($1),pro:poss:det|her($2,n|bottle($2)),$0)
sem is  lambda $0_{e}.lambda $1_{ev}.aux|be&PRES(part|do-PROG(pro|you,$0,$1),$1)
types dont match 2 :  (Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|be&PRES($0($1),$1)   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|be&PRES($0($1),$1) (S/NP):lambda $0_{e}.lambda $1_{ev}.part|do-PROG(pro|you,$0,$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|be&PRES($0($1),$1)   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
types dont match 2 :  (Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|be&PRES($0($1),$1)   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|be&PRES($0($1),$1) (S\NP):lambda $0_{e}.lambda $1_{ev}.part|do-PROG(pro|you,$0,$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|be&PRES($0($1),$1)   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
sem is  lambda $0_{e}.lambda $1_{ev}.aux|be&PRES(part|do-PROG(pro|you,$0,$1),$1)
sem is  lambda $0_{e}.n|bottle($0)
sem is  lambda $0_{ev}.Q(det|the($1,n|hat($1)),$0)
sem is  lambda $0_{ev}.not(aux|do&3S(v|have(pro|he,det|a($1,n|hat($1)),$0),$0),$0)
size of chart is  2019
got chart
norm score is  -15.6734480398
doing updates with learning rate  0.0266203426413
Deleting 0 entries of the total 2877
done io
WATCH	what are you doing ?
WATCH	43	((S\NP)\NP)	0.731845443693
WATCH	43	((S\NP)/NP)	0.00266071204125
WATCH	43	((S/NP)/NP)	0.264894846515
WATCH	43	((S/NP)\NP)	0.00059899775018
getting topparses
outputting cat probs
done with sent


making  lambda $0_{ev}.v|give(pro|you,lambda $1_{e}.n|doll-DIM($1),pro:poss:det|her($2,n|bottle($2)),$0)
making  v|give(pro|you,lambda $1_{e}.n|doll-DIM($1),pro:poss:det|her($2,n|bottle($2)),$0)
making  pro|you
making  lambda $1_{e}.n|doll-DIM($1)
making  n|doll-DIM($1)
making  $1
making  pro:poss:det|her($2,n|bottle($2))
making  n|bottle($2)
making  $2
making  $0
sentence is  bottle ?
making  lambda $0_{e}.lambda $1_{ev}.aux|be&PRES(part|do-PROG(pro|you,$0,$1),$1)
making  lambda $1_{ev}.aux|be&PRES(part|do-PROG(pro|you,$0,$1),$1)
making  aux|be&PRES(part|do-PROG(pro|you,$0,$1),$1)
making  part|do-PROG(pro|you,$0,$1)
making  pro|you
making  $0
making  $1
making  $1
sentence is  bottle ?
making  lambda $0_{e}.lambda $1_{ev}.aux|be&PRES(part|do-PROG(pro|you,$0,$1),$1)
making  lambda $1_{ev}.aux|be&PRES(part|do-PROG(pro|you,$0,$1),$1)
making  aux|be&PRES(part|do-PROG(pro|you,$0,$1),$1)
making  part|do-PROG(pro|you,$0,$1)
making  pro|you
making  $0
making  $1
making  $1
sentence is  bottle ?
making  lambda $0_{e}.n|bottle($0)
making  n|bottle($0)
making  $0
sentence is  bottle ?
making  lambda $0_{ev}.Q(det|the($1,n|hat($1)),$0)
making  Q(det|the($1,n|hat($1)),$0)
making  det|the($1,n|hat($1)),$0)
making  n|hat($1)
making  $1
making  $0)
Is Q
sentence is  bottle ?
making  lambda $0_{ev}.not(aux|do&3S(v|have(pro|he,det|a($1,n|hat($1)),$0),$0),$0)
making  not(aux|do&3S(v|have(pro|he,det|a($1,n|hat($1)),$0),$0),$0)
making  aux|do&3S(v|have(pro|he,det|a($1,n|hat($1)),$0),$0),$0)
making  v|have(pro|he,det|a($1,n|hat($1)),$0)
making  pro|he
making  det|a($1,n|hat($1))
making  n|hat($1)
making  $1
making  $0
making  $0
making  $0)
sentence is  bottle ?
making  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  eq($0,pro:dem|that,$1)
making  $0,pro:dem|that,$1)
making  pro:dem|that,$1)
making  $1)
sentence is  bottle ?

got training pair
Sent : bottle ?
Cat : S:lambda $0_{ev}.v|give(pro|you,lambda $1_{e}.n|doll-DIM($1),pro:poss:det|her($2,n|bottle($2)),$0)
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.aux|be&PRES(part|do-PROG(pro|you,$0,$1),$1)
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.aux|be&PRES(part|do-PROG(pro|you,$0,$1),$1)
Cat : Swh:lambda $0_{e}.n|bottle($0)
Cat : Syn:lambda $0_{ev}.Q(det|the($1,n|hat($1)),$0)
Cat : S:lambda $0_{ev}.not(aux|do&3S(v|have(pro|he,det|a($1,n|hat($1)),$0),$0),$0)
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
sentence is  ['bottle']
sem is  lambda $0_{ev}.v|give(pro|you,lambda $1_{e}.n|doll-DIM($1),pro:poss:det|her($2,n|bottle($2)),$0)
sem is  lambda $0_{e}.lambda $1_{ev}.aux|be&PRES(part|do-PROG(pro|you,$0,$1),$1)
sem is  lambda $0_{e}.lambda $1_{ev}.aux|be&PRES(part|do-PROG(pro|you,$0,$1),$1)
sem is  lambda $0_{e}.n|bottle($0)
sem is  lambda $0_{ev}.Q(det|the($1,n|hat($1)),$0)
sem is  lambda $0_{ev}.not(aux|do&3S(v|have(pro|he,det|a($1,n|hat($1)),$0),$0),$0)
sem is  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
size of chart is  6
got chart
norm score is  -9.82804099421
doing updates with learning rate  0.026393544485
Deleting 0 entries of the total 2883
done io
WATCH	bottle ?
WATCH	44	((S\NP)\NP)	0.73187200175
WATCH	44	((S\NP)/NP)	0.00264873143309
WATCH	44	((S/NP)/NP)	0.26488732528
WATCH	44	((S/NP)\NP)	0.00059194153697
getting topparses
outputting cat probs
done with sent


making  lambda $0_{e}.lambda $1_{ev}.aux|be&PRES(part|do-PROG(pro|you,$0,$1),$1)
making  lambda $1_{ev}.aux|be&PRES(part|do-PROG(pro|you,$0,$1),$1)
making  aux|be&PRES(part|do-PROG(pro|you,$0,$1),$1)
making  part|do-PROG(pro|you,$0,$1)
making  pro|you
making  $0
making  $1
making  $1
sentence is  the hat ?
making  lambda $0_{e}.lambda $1_{ev}.aux|be&PRES(part|do-PROG(pro|you,$0,$1),$1)
making  lambda $1_{ev}.aux|be&PRES(part|do-PROG(pro|you,$0,$1),$1)
making  aux|be&PRES(part|do-PROG(pro|you,$0,$1),$1)
making  part|do-PROG(pro|you,$0,$1)
making  pro|you
making  $0
making  $1
making  $1
sentence is  the hat ?
making  lambda $0_{e}.n|bottle($0)
making  n|bottle($0)
making  $0
sentence is  the hat ?
making  lambda $0_{ev}.Q(det|the($1,n|hat($1)),$0)
making  Q(det|the($1,n|hat($1)),$0)
making  det|the($1,n|hat($1)),$0)
making  n|hat($1)
making  $1
making  $0)
Is Q
sentence is  the hat ?
making  lambda $0_{ev}.not(aux|do&3S(v|have(pro|he,det|a($1,n|hat($1)),$0),$0),$0)
making  not(aux|do&3S(v|have(pro|he,det|a($1,n|hat($1)),$0),$0),$0)
making  aux|do&3S(v|have(pro|he,det|a($1,n|hat($1)),$0),$0),$0)
making  v|have(pro|he,det|a($1,n|hat($1)),$0)
making  pro|he
making  det|a($1,n|hat($1))
making  n|hat($1)
making  $1
making  $0
making  $0
making  $0)
sentence is  the hat ?
making  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  eq($0,pro:dem|that,$1)
making  $0,pro:dem|that,$1)
making  pro:dem|that,$1)
making  $1)
sentence is  the hat ?
making  lambda $0_{e}.n|soldier-PL($0)
making  n|soldier-PL($0)
making  $0
sentence is  the hat ?

got training pair
Sent : the hat ?
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.aux|be&PRES(part|do-PROG(pro|you,$0,$1),$1)
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.aux|be&PRES(part|do-PROG(pro|you,$0,$1),$1)
Cat : Swh:lambda $0_{e}.n|bottle($0)
Cat : Syn:lambda $0_{ev}.Q(det|the($1,n|hat($1)),$0)
Cat : S:lambda $0_{ev}.not(aux|do&3S(v|have(pro|he,det|a($1,n|hat($1)),$0),$0),$0)
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
Cat : Swh:lambda $0_{e}.n|soldier-PL($0)
sentence is  ['the', 'hat']
sem is  lambda $0_{e}.lambda $1_{ev}.aux|be&PRES(part|do-PROG(pro|you,$0,$1),$1)
types dont match 2 :  (Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|be&PRES($0($1),$1)   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|be&PRES($0($1),$1) (S/NP):lambda $0_{e}.lambda $1_{ev}.part|do-PROG(pro|you,$0,$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|be&PRES($0($1),$1)   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
types dont match 2 :  (Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|be&PRES($0($1),$1)   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|be&PRES($0($1),$1) (S\NP):lambda $0_{e}.lambda $1_{ev}.part|do-PROG(pro|you,$0,$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|be&PRES($0($1),$1)   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
sem is  lambda $0_{e}.lambda $1_{ev}.aux|be&PRES(part|do-PROG(pro|you,$0,$1),$1)
sem is  lambda $0_{e}.n|bottle($0)
sem is  lambda $0_{ev}.Q(det|the($1,n|hat($1)),$0)
sem is  lambda $0_{ev}.not(aux|do&3S(v|have(pro|he,det|a($1,n|hat($1)),$0),$0),$0)
sem is  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
sem is  lambda $0_{e}.n|soldier-PL($0)
size of chart is  74
got chart
norm score is  -15.9951756156
doing updates with learning rate  0.0261710481075
Deleting 0 entries of the total 2942
done io
WATCH	the hat ?
WATCH	45	((S\NP)\NP)	0.725600754147
WATCH	45	((S\NP)/NP)	0.00261392515249
WATCH	45	((S/NP)/NP)	0.271186537693
WATCH	45	((S/NP)\NP)	0.000598783008012
getting topparses
outputting cat probs
done with sent


making  lambda $0_{e}.lambda $1_{ev}.aux|be&PRES(part|do-PROG(pro|you,$0,$1),$1)
making  lambda $1_{ev}.aux|be&PRES(part|do-PROG(pro|you,$0,$1),$1)
making  aux|be&PRES(part|do-PROG(pro|you,$0,$1),$1)
making  part|do-PROG(pro|you,$0,$1)
making  pro|you
making  $0
making  $1
making  $1
sentence is  he doesn 't have a hat .
making  lambda $0_{e}.n|bottle($0)
making  n|bottle($0)
making  $0
sentence is  he doesn 't have a hat .
making  lambda $0_{ev}.Q(det|the($1,n|hat($1)),$0)
making  Q(det|the($1,n|hat($1)),$0)
making  det|the($1,n|hat($1)),$0)
making  n|hat($1)
making  $1
making  $0)
Is Q
sentence is  he doesn 't have a hat .
making  lambda $0_{ev}.not(aux|do&3S(v|have(pro|he,det|a($1,n|hat($1)),$0),$0),$0)
making  not(aux|do&3S(v|have(pro|he,det|a($1,n|hat($1)),$0),$0),$0)
making  aux|do&3S(v|have(pro|he,det|a($1,n|hat($1)),$0),$0),$0)
making  v|have(pro|he,det|a($1,n|hat($1)),$0)
making  pro|he
making  det|a($1,n|hat($1))
making  n|hat($1)
making  $1
making  $0
making  $0
making  $0)
sentence is  he doesn 't have a hat .
making  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  eq($0,pro:dem|that,$1)
making  $0,pro:dem|that,$1)
making  pro:dem|that,$1)
making  $1)
sentence is  he doesn 't have a hat .
making  lambda $0_{e}.n|soldier-PL($0)
making  n|soldier-PL($0)
making  $0
sentence is  he doesn 't have a hat .
making  lambda $0_{ev}.and(v|bring(pro|you,pro|it,$0),adv:loc|here($0))
making  and(v|bring(pro|you,pro|it,$0),adv:loc|here($0))
making  v|bring(pro|you,pro|it,$0)
making  pro|you
making  pro|it
making  $0
making  adv:loc|here($0)
making  $0
sentence is  he doesn 't have a hat .

got training pair
Sent : he doesn 't have a hat .
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.aux|be&PRES(part|do-PROG(pro|you,$0,$1),$1)
Cat : Swh:lambda $0_{e}.n|bottle($0)
Cat : Syn:lambda $0_{ev}.Q(det|the($1,n|hat($1)),$0)
Cat : S:lambda $0_{ev}.not(aux|do&3S(v|have(pro|he,det|a($1,n|hat($1)),$0),$0),$0)
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
Cat : Swh:lambda $0_{e}.n|soldier-PL($0)
Cat : S:lambda $0_{ev}.and(v|bring(pro|you,pro|it,$0),adv:loc|here($0))
sentence is  ['he', 'doesn', "'t", 'have', 'a', 'hat']
sem is  lambda $0_{e}.lambda $1_{ev}.aux|be&PRES(part|do-PROG(pro|you,$0,$1),$1)
types dont match 2 :  (Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|be&PRES($0($1),$1)   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|be&PRES($0($1),$1) (S/NP):lambda $0_{e}.lambda $1_{ev}.part|do-PROG(pro|you,$0,$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|be&PRES($0($1),$1)   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
types dont match 2 :  (Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|be&PRES($0($1),$1)   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|be&PRES($0($1),$1) (S\NP):lambda $0_{e}.lambda $1_{ev}.part|do-PROG(pro|you,$0,$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|be&PRES($0($1),$1)   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
sem is  lambda $0_{e}.n|bottle($0)
sem is  lambda $0_{ev}.Q(det|the($1,n|hat($1)),$0)
sem is  lambda $0_{ev}.not(aux|do&3S(v|have(pro|he,det|a($1,n|hat($1)),$0),$0),$0)
sem is  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
sem is  lambda $0_{e}.n|soldier-PL($0)
sem is  lambda $0_{ev}.and(v|bring(pro|you,pro|it,$0),adv:loc|here($0))
size of chart is  4981
got chart
norm score is  -42.3390172878
doing updates with learning rate  0.0259527279087
Deleting 0 entries of the total 5278
done io
WATCH	he doesn 't have a hat .
WATCH	46	((S\NP)\NP)	0.734937555728
WATCH	46	((S\NP)/NP)	0.00263511695907
WATCH	46	((S/NP)/NP)	0.26182560266
WATCH	46	((S/NP)\NP)	0.000601724653461
getting topparses
outputting cat probs
done with sent


making  lambda $0_{e}.n|bottle($0)
making  n|bottle($0)
making  $0
sentence is  what is that ?
making  lambda $0_{ev}.Q(det|the($1,n|hat($1)),$0)
making  Q(det|the($1,n|hat($1)),$0)
making  det|the($1,n|hat($1)),$0)
making  n|hat($1)
making  $1
making  $0)
Is Q
sentence is  what is that ?
making  lambda $0_{ev}.not(aux|do&3S(v|have(pro|he,det|a($1,n|hat($1)),$0),$0),$0)
making  not(aux|do&3S(v|have(pro|he,det|a($1,n|hat($1)),$0),$0),$0)
making  aux|do&3S(v|have(pro|he,det|a($1,n|hat($1)),$0),$0),$0)
making  v|have(pro|he,det|a($1,n|hat($1)),$0)
making  pro|he
making  det|a($1,n|hat($1))
making  n|hat($1)
making  $1
making  $0
making  $0
making  $0)
sentence is  what is that ?
making  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  eq($0,pro:dem|that,$1)
making  $0,pro:dem|that,$1)
making  pro:dem|that,$1)
making  $1)
sentence is  what is that ?
making  lambda $0_{e}.n|soldier-PL($0)
making  n|soldier-PL($0)
making  $0
sentence is  what is that ?
making  lambda $0_{ev}.and(v|bring(pro|you,pro|it,$0),adv:loc|here($0))
making  and(v|bring(pro|you,pro|it,$0),adv:loc|here($0))
making  v|bring(pro|you,pro|it,$0)
making  pro|you
making  pro|it
making  $0
making  adv:loc|here($0)
making  $0
sentence is  what is that ?
making  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  eq($0,pro:dem|that,$1)
making  $0,pro:dem|that,$1)
making  pro:dem|that,$1)
making  $1)
sentence is  what is that ?

got training pair
Sent : what is that ?
Cat : Swh:lambda $0_{e}.n|bottle($0)
Cat : Syn:lambda $0_{ev}.Q(det|the($1,n|hat($1)),$0)
Cat : S:lambda $0_{ev}.not(aux|do&3S(v|have(pro|he,det|a($1,n|hat($1)),$0),$0),$0)
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
Cat : Swh:lambda $0_{e}.n|soldier-PL($0)
Cat : S:lambda $0_{ev}.and(v|bring(pro|you,pro|it,$0),adv:loc|here($0))
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
sentence is  ['what', 'is', 'that']
sem is  lambda $0_{e}.n|bottle($0)
sem is  lambda $0_{ev}.Q(det|the($1,n|hat($1)),$0)
sem is  lambda $0_{ev}.not(aux|do&3S(v|have(pro|he,det|a($1,n|hat($1)),$0),$0),$0)
sem is  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
sem is  lambda $0_{e}.n|soldier-PL($0)
sem is  lambda $0_{ev}.and(v|bring(pro|you,pro|it,$0),adv:loc|here($0))
sem is  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
size of chart is  332
got chart
norm score is  -20.6871887327
doing updates with learning rate  0.0257384632137
Deleting 0 entries of the total 5485
done io
WATCH	what is that ?
WATCH	47	((S\NP)\NP)	0.736923163902
WATCH	47	((S\NP)/NP)	0.0026282300404
WATCH	47	((S/NP)/NP)	0.259859179994
WATCH	47	((S/NP)\NP)	0.000589426063274
getting topparses
outputting cat probs
done with sent


making  lambda $0_{ev}.Q(det|the($1,n|hat($1)),$0)
making  Q(det|the($1,n|hat($1)),$0)
making  det|the($1,n|hat($1)),$0)
making  n|hat($1)
making  $1
making  $0)
Is Q
sentence is  soldiers .
making  lambda $0_{ev}.not(aux|do&3S(v|have(pro|he,det|a($1,n|hat($1)),$0),$0),$0)
making  not(aux|do&3S(v|have(pro|he,det|a($1,n|hat($1)),$0),$0),$0)
making  aux|do&3S(v|have(pro|he,det|a($1,n|hat($1)),$0),$0),$0)
making  v|have(pro|he,det|a($1,n|hat($1)),$0)
making  pro|he
making  det|a($1,n|hat($1))
making  n|hat($1)
making  $1
making  $0
making  $0
making  $0)
sentence is  soldiers .
making  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  eq($0,pro:dem|that,$1)
making  $0,pro:dem|that,$1)
making  pro:dem|that,$1)
making  $1)
sentence is  soldiers .
making  lambda $0_{e}.n|soldier-PL($0)
making  n|soldier-PL($0)
making  $0
sentence is  soldiers .
making  lambda $0_{ev}.and(v|bring(pro|you,pro|it,$0),adv:loc|here($0))
making  and(v|bring(pro|you,pro|it,$0),adv:loc|here($0))
making  v|bring(pro|you,pro|it,$0)
making  pro|you
making  pro|it
making  $0
making  adv:loc|here($0)
making  $0
sentence is  soldiers .
making  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  eq($0,pro:dem|that,$1)
making  $0,pro:dem|that,$1)
making  pro:dem|that,$1)
making  $1)
sentence is  soldiers .
making  lambda $0_{ev}.eq(pro:dem|that,and(n:prop|Jack,n:prop|Jill),$0)
making  eq(pro:dem|that,and(n:prop|Jack,n:prop|Jill),$0)
making  pro:dem|that,and(n:prop|Jack,n:prop|Jill),$0)
making  and(n:prop|Jack,n:prop|Jill),$0)
making  n:prop|Jack
making  n:prop|Jill
making  $0)
sentence is  soldiers .

got training pair
Sent : soldiers .
Cat : Syn:lambda $0_{ev}.Q(det|the($1,n|hat($1)),$0)
Cat : S:lambda $0_{ev}.not(aux|do&3S(v|have(pro|he,det|a($1,n|hat($1)),$0),$0),$0)
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
Cat : Swh:lambda $0_{e}.n|soldier-PL($0)
Cat : S:lambda $0_{ev}.and(v|bring(pro|you,pro|it,$0),adv:loc|here($0))
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
Cat : S:lambda $0_{ev}.eq(pro:dem|that,and(n:prop|Jack,n:prop|Jill),$0)
sentence is  ['soldiers']
sem is  lambda $0_{ev}.Q(det|the($1,n|hat($1)),$0)
sem is  lambda $0_{ev}.not(aux|do&3S(v|have(pro|he,det|a($1,n|hat($1)),$0),$0),$0)
sem is  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
sem is  lambda $0_{e}.n|soldier-PL($0)
sem is  lambda $0_{ev}.and(v|bring(pro|you,pro|it,$0),adv:loc|here($0))
sem is  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
sem is  lambda $0_{ev}.eq(pro:dem|that,and(n:prop|Jack,n:prop|Jill),$0)
size of chart is  6
got chart
norm score is  -10.5430044807
doing updates with learning rate  0.025528138032
Deleting 0 entries of the total 5491
done io
WATCH	soldiers .
WATCH	48	((S\NP)\NP)	0.736944186523
WATCH	48	((S\NP)/NP)	0.0026156057094
WATCH	48	((S/NP)/NP)	0.259858172905
WATCH	48	((S/NP)\NP)	0.00058203486195
getting topparses
outputting cat probs
done with sent


making  lambda $0_{ev}.not(aux|do&3S(v|have(pro|he,det|a($1,n|hat($1)),$0),$0),$0)
making  not(aux|do&3S(v|have(pro|he,det|a($1,n|hat($1)),$0),$0),$0)
making  aux|do&3S(v|have(pro|he,det|a($1,n|hat($1)),$0),$0),$0)
making  v|have(pro|he,det|a($1,n|hat($1)),$0)
making  pro|he
making  det|a($1,n|hat($1))
making  n|hat($1)
making  $1
making  $0
making  $0
making  $0)
sentence is  bring it here .
making  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  eq($0,pro:dem|that,$1)
making  $0,pro:dem|that,$1)
making  pro:dem|that,$1)
making  $1)
sentence is  bring it here .
making  lambda $0_{e}.n|soldier-PL($0)
making  n|soldier-PL($0)
making  $0
sentence is  bring it here .
making  lambda $0_{ev}.and(v|bring(pro|you,pro|it,$0),adv:loc|here($0))
making  and(v|bring(pro|you,pro|it,$0),adv:loc|here($0))
making  v|bring(pro|you,pro|it,$0)
making  pro|you
making  pro|it
making  $0
making  adv:loc|here($0)
making  $0
sentence is  bring it here .
making  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  eq($0,pro:dem|that,$1)
making  $0,pro:dem|that,$1)
making  pro:dem|that,$1)
making  $1)
sentence is  bring it here .
making  lambda $0_{ev}.eq(pro:dem|that,and(n:prop|Jack,n:prop|Jill),$0)
making  eq(pro:dem|that,and(n:prop|Jack,n:prop|Jill),$0)
making  pro:dem|that,and(n:prop|Jack,n:prop|Jill),$0)
making  and(n:prop|Jack,n:prop|Jill),$0)
making  n:prop|Jack
making  n:prop|Jill
making  $0)
sentence is  bring it here .
making  lambda $0_{ev}.not(aux|do&3S(v|have(pro|he,det|a($1,n|hat($1)),$0),$0),$0)
making  not(aux|do&3S(v|have(pro|he,det|a($1,n|hat($1)),$0),$0),$0)
making  aux|do&3S(v|have(pro|he,det|a($1,n|hat($1)),$0),$0),$0)
making  v|have(pro|he,det|a($1,n|hat($1)),$0)
making  pro|he
making  det|a($1,n|hat($1))
making  n|hat($1)
making  $1
making  $0
making  $0
making  $0)
sentence is  bring it here .

got training pair
Sent : bring it here .
Cat : S:lambda $0_{ev}.not(aux|do&3S(v|have(pro|he,det|a($1,n|hat($1)),$0),$0),$0)
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
Cat : Swh:lambda $0_{e}.n|soldier-PL($0)
Cat : S:lambda $0_{ev}.and(v|bring(pro|you,pro|it,$0),adv:loc|here($0))
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
Cat : S:lambda $0_{ev}.eq(pro:dem|that,and(n:prop|Jack,n:prop|Jill),$0)
Cat : S:lambda $0_{ev}.not(aux|do&3S(v|have(pro|he,det|a($1,n|hat($1)),$0),$0),$0)
sentence is  ['bring', 'it', 'here']
sem is  lambda $0_{ev}.not(aux|do&3S(v|have(pro|he,det|a($1,n|hat($1)),$0),$0),$0)
sem is  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
sem is  lambda $0_{e}.n|soldier-PL($0)
sem is  lambda $0_{ev}.and(v|bring(pro|you,pro|it,$0),adv:loc|here($0))
sem is  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
sem is  lambda $0_{ev}.eq(pro:dem|that,and(n:prop|Jack,n:prop|Jill),$0)
sem is  lambda $0_{ev}.not(aux|do&3S(v|have(pro|he,det|a($1,n|hat($1)),$0),$0),$0)
size of chart is  358
got chart
norm score is  -20.7871626902
doing updates with learning rate  0.0253216408296
Deleting 0 entries of the total 5778
done io
WATCH	bring it here .
WATCH	49	((S\NP)\NP)	0.73621068672
WATCH	49	((S\NP)/NP)	0.00249461631336
WATCH	49	((S/NP)/NP)	0.260757088404
WATCH	49	((S/NP)\NP)	0.00053760856292
getting topparses
outputting cat probs
done with sent


making  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  eq($0,pro:dem|that,$1)
making  $0,pro:dem|that,$1)
making  pro:dem|that,$1)
making  $1)
sentence is  what 's that ?
making  lambda $0_{e}.n|soldier-PL($0)
making  n|soldier-PL($0)
making  $0
sentence is  what 's that ?
making  lambda $0_{ev}.and(v|bring(pro|you,pro|it,$0),adv:loc|here($0))
making  and(v|bring(pro|you,pro|it,$0),adv:loc|here($0))
making  v|bring(pro|you,pro|it,$0)
making  pro|you
making  pro|it
making  $0
making  adv:loc|here($0)
making  $0
sentence is  what 's that ?
making  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  eq($0,pro:dem|that,$1)
making  $0,pro:dem|that,$1)
making  pro:dem|that,$1)
making  $1)
sentence is  what 's that ?
making  lambda $0_{ev}.eq(pro:dem|that,and(n:prop|Jack,n:prop|Jill),$0)
making  eq(pro:dem|that,and(n:prop|Jack,n:prop|Jill),$0)
making  pro:dem|that,and(n:prop|Jack,n:prop|Jill),$0)
making  and(n:prop|Jack,n:prop|Jill),$0)
making  n:prop|Jack
making  n:prop|Jill
making  $0)
sentence is  what 's that ?
making  lambda $0_{ev}.not(aux|do&3S(v|have(pro|he,det|a($1,n|hat($1)),$0),$0),$0)
making  not(aux|do&3S(v|have(pro|he,det|a($1,n|hat($1)),$0),$0),$0)
making  aux|do&3S(v|have(pro|he,det|a($1,n|hat($1)),$0),$0),$0)
making  v|have(pro|he,det|a($1,n|hat($1)),$0)
making  pro|he
making  det|a($1,n|hat($1))
making  n|hat($1)
making  $1
making  $0
making  $0
making  $0)
sentence is  what 's that ?
making  lambda $0_{ev}.v|have&3S(n:prop|Eve,det|a($1,n|hat($1)),$0)
making  v|have&3S(n:prop|Eve,det|a($1,n|hat($1)),$0)
making  n:prop|Eve
making  det|a($1,n|hat($1))
making  n|hat($1)
making  $1
making  $0
sentence is  what 's that ?

got training pair
Sent : what 's that ?
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
Cat : Swh:lambda $0_{e}.n|soldier-PL($0)
Cat : S:lambda $0_{ev}.and(v|bring(pro|you,pro|it,$0),adv:loc|here($0))
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
Cat : S:lambda $0_{ev}.eq(pro:dem|that,and(n:prop|Jack,n:prop|Jill),$0)
Cat : S:lambda $0_{ev}.not(aux|do&3S(v|have(pro|he,det|a($1,n|hat($1)),$0),$0),$0)
Cat : S:lambda $0_{ev}.v|have&3S(n:prop|Eve,det|a($1,n|hat($1)),$0)
sentence is  ['what', "'s", 'that']
sem is  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
sem is  lambda $0_{e}.n|soldier-PL($0)
sem is  lambda $0_{ev}.and(v|bring(pro|you,pro|it,$0),adv:loc|here($0))
sem is  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
sem is  lambda $0_{ev}.eq(pro:dem|that,and(n:prop|Jack,n:prop|Jill),$0)
sem is  lambda $0_{ev}.not(aux|do&3S(v|have(pro|he,det|a($1,n|hat($1)),$0),$0),$0)
sem is  lambda $0_{ev}.v|have&3S(n:prop|Eve,det|a($1,n|hat($1)),$0)
size of chart is  401
got chart
norm score is  -20.6096102259
doing updates with learning rate  0.0251188643151
Deleting 0 entries of the total 5987
done io
WATCH	what 's that ?
WATCH	50	((S\NP)\NP)	0.737906318488
WATCH	50	((S\NP)/NP)	0.00247615230185
WATCH	50	((S/NP)/NP)	0.259092448438
WATCH	50	((S/NP)\NP)	0.000525080771705
getting topparses
outputting cat probs
done with sent


making  lambda $0_{e}.n|soldier-PL($0)
making  n|soldier-PL($0)
making  $0
sentence is  that 's Jack and Jill .
making  lambda $0_{ev}.and(v|bring(pro|you,pro|it,$0),adv:loc|here($0))
making  and(v|bring(pro|you,pro|it,$0),adv:loc|here($0))
making  v|bring(pro|you,pro|it,$0)
making  pro|you
making  pro|it
making  $0
making  adv:loc|here($0)
making  $0
sentence is  that 's Jack and Jill .
making  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  eq($0,pro:dem|that,$1)
making  $0,pro:dem|that,$1)
making  pro:dem|that,$1)
making  $1)
sentence is  that 's Jack and Jill .
making  lambda $0_{ev}.eq(pro:dem|that,and(n:prop|Jack,n:prop|Jill),$0)
making  eq(pro:dem|that,and(n:prop|Jack,n:prop|Jill),$0)
making  pro:dem|that,and(n:prop|Jack,n:prop|Jill),$0)
making  and(n:prop|Jack,n:prop|Jill),$0)
making  n:prop|Jack
making  n:prop|Jill
making  $0)
sentence is  that 's Jack and Jill .
making  lambda $0_{ev}.not(aux|do&3S(v|have(pro|he,det|a($1,n|hat($1)),$0),$0),$0)
making  not(aux|do&3S(v|have(pro|he,det|a($1,n|hat($1)),$0),$0),$0)
making  aux|do&3S(v|have(pro|he,det|a($1,n|hat($1)),$0),$0),$0)
making  v|have(pro|he,det|a($1,n|hat($1)),$0)
making  pro|he
making  det|a($1,n|hat($1))
making  n|hat($1)
making  $1
making  $0
making  $0
making  $0)
sentence is  that 's Jack and Jill .
making  lambda $0_{ev}.v|have&3S(n:prop|Eve,det|a($1,n|hat($1)),$0)
making  v|have&3S(n:prop|Eve,det|a($1,n|hat($1)),$0)
making  n:prop|Eve
making  det|a($1,n|hat($1))
making  n|hat($1)
making  $1
making  $0
sentence is  that 's Jack and Jill .
making  lambda $0_{ev}.aux|be&PRES(and(part|go-PROG(pro|you,$0),v|find(pro|you,pro|it,$0)),$0)
making  aux|be&PRES(and(part|go-PROG(pro|you,$0),v|find(pro|you,pro|it,$0)),$0)
making  and(part|go-PROG(pro|you,$0),v|find(pro|you,pro|it,$0))
making  part|go-PROG(pro|you,$0)
making  pro|you
making  $0
making  v|find(pro|you,pro|it,$0)
making  pro|you
making  pro|it
making  $0
making  $0
sentence is  that 's Jack and Jill .

got training pair
Sent : that 's Jack and Jill .
Cat : Swh:lambda $0_{e}.n|soldier-PL($0)
Cat : S:lambda $0_{ev}.and(v|bring(pro|you,pro|it,$0),adv:loc|here($0))
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
Cat : S:lambda $0_{ev}.eq(pro:dem|that,and(n:prop|Jack,n:prop|Jill),$0)
Cat : S:lambda $0_{ev}.not(aux|do&3S(v|have(pro|he,det|a($1,n|hat($1)),$0),$0),$0)
Cat : S:lambda $0_{ev}.v|have&3S(n:prop|Eve,det|a($1,n|hat($1)),$0)
Cat : S:lambda $0_{ev}.aux|be&PRES(and(part|go-PROG(pro|you,$0),v|find(pro|you,pro|it,$0)),$0)
sentence is  ['that', "'s", 'Jack', 'and', 'Jill']
sem is  lambda $0_{e}.n|soldier-PL($0)
sem is  lambda $0_{ev}.and(v|bring(pro|you,pro|it,$0),adv:loc|here($0))
sem is  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
sem is  lambda $0_{ev}.eq(pro:dem|that,and(n:prop|Jack,n:prop|Jill),$0)
sem is  lambda $0_{ev}.not(aux|do&3S(v|have(pro|he,det|a($1,n|hat($1)),$0),$0),$0)
sem is  lambda $0_{ev}.v|have&3S(n:prop|Eve,det|a($1,n|hat($1)),$0)
sem is  lambda $0_{ev}.aux|be&PRES(and(part|go-PROG(pro|you,$0),v|find(pro|you,pro|it,$0)),$0)
size of chart is  5079
got chart
norm score is  -36.4276916536
doing updates with learning rate  0.0249197052378
Deleting 7383 entries of the total 8700
done io
WATCH	that 's Jack and Jill .
WATCH	51	((S\NP)\NP)	0.744801001981
WATCH	51	((S\NP)/NP)	0.00231965232908
WATCH	51	((S/NP)/NP)	0.252387313339
WATCH	51	((S/NP)\NP)	0.000492032350781
getting topparses
outputting cat probs
done with sent


making  lambda $0_{ev}.and(v|bring(pro|you,pro|it,$0),adv:loc|here($0))
making  and(v|bring(pro|you,pro|it,$0),adv:loc|here($0))
making  v|bring(pro|you,pro|it,$0)
making  pro|you
making  pro|it
making  $0
making  adv:loc|here($0)
making  $0
sentence is  he doesn 't have a hat .
making  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  eq($0,pro:dem|that,$1)
making  $0,pro:dem|that,$1)
making  pro:dem|that,$1)
making  $1)
sentence is  he doesn 't have a hat .
making  lambda $0_{ev}.eq(pro:dem|that,and(n:prop|Jack,n:prop|Jill),$0)
making  eq(pro:dem|that,and(n:prop|Jack,n:prop|Jill),$0)
making  pro:dem|that,and(n:prop|Jack,n:prop|Jill),$0)
making  and(n:prop|Jack,n:prop|Jill),$0)
making  n:prop|Jack
making  n:prop|Jill
making  $0)
sentence is  he doesn 't have a hat .
making  lambda $0_{ev}.not(aux|do&3S(v|have(pro|he,det|a($1,n|hat($1)),$0),$0),$0)
making  not(aux|do&3S(v|have(pro|he,det|a($1,n|hat($1)),$0),$0),$0)
making  aux|do&3S(v|have(pro|he,det|a($1,n|hat($1)),$0),$0),$0)
making  v|have(pro|he,det|a($1,n|hat($1)),$0)
making  pro|he
making  det|a($1,n|hat($1))
making  n|hat($1)
making  $1
making  $0
making  $0
making  $0)
sentence is  he doesn 't have a hat .
making  lambda $0_{ev}.v|have&3S(n:prop|Eve,det|a($1,n|hat($1)),$0)
making  v|have&3S(n:prop|Eve,det|a($1,n|hat($1)),$0)
making  n:prop|Eve
making  det|a($1,n|hat($1))
making  n|hat($1)
making  $1
making  $0
sentence is  he doesn 't have a hat .
making  lambda $0_{ev}.aux|be&PRES(and(part|go-PROG(pro|you,$0),v|find(pro|you,pro|it,$0)),$0)
making  aux|be&PRES(and(part|go-PROG(pro|you,$0),v|find(pro|you,pro|it,$0)),$0)
making  and(part|go-PROG(pro|you,$0),v|find(pro|you,pro|it,$0))
making  part|go-PROG(pro|you,$0)
making  pro|you
making  $0
making  v|find(pro|you,pro|it,$0)
making  pro|you
making  pro|it
making  $0
making  $0
sentence is  he doesn 't have a hat .
making  lambda $0_{ev}.adv:loc|there($0)
making  adv:loc|there($0)
making  $0
sentence is  he doesn 't have a hat .

got training pair
Sent : he doesn 't have a hat .
Cat : S:lambda $0_{ev}.and(v|bring(pro|you,pro|it,$0),adv:loc|here($0))
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
Cat : S:lambda $0_{ev}.eq(pro:dem|that,and(n:prop|Jack,n:prop|Jill),$0)
Cat : S:lambda $0_{ev}.not(aux|do&3S(v|have(pro|he,det|a($1,n|hat($1)),$0),$0),$0)
Cat : S:lambda $0_{ev}.v|have&3S(n:prop|Eve,det|a($1,n|hat($1)),$0)
Cat : S:lambda $0_{ev}.aux|be&PRES(and(part|go-PROG(pro|you,$0),v|find(pro|you,pro|it,$0)),$0)
Cat : S:lambda $0_{ev}.adv:loc|there($0)
sentence is  ['he', 'doesn', "'t", 'have', 'a', 'hat']
sem is  lambda $0_{ev}.and(v|bring(pro|you,pro|it,$0),adv:loc|here($0))
sem is  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
sem is  lambda $0_{ev}.eq(pro:dem|that,and(n:prop|Jack,n:prop|Jill),$0)
sem is  lambda $0_{ev}.not(aux|do&3S(v|have(pro|he,det|a($1,n|hat($1)),$0),$0),$0)
sem is  lambda $0_{ev}.v|have&3S(n:prop|Eve,det|a($1,n|hat($1)),$0)
sem is  lambda $0_{ev}.aux|be&PRES(and(part|go-PROG(pro|you,$0),v|find(pro|you,pro|it,$0)),$0)
sem is  lambda $0_{ev}.adv:loc|there($0)
size of chart is  9725
got chart
norm score is  -25.5094665002
doing updates with learning rate  0.0247240641974
Deleting 0 entries of the total 5939
done io
WATCH	he doesn 't have a hat .
WATCH	52	((S\NP)\NP)	0.728281550815
WATCH	52	((S\NP)/NP)	0.00225682619896
WATCH	52	((S/NP)/NP)	0.268985602113
WATCH	52	((S/NP)\NP)	0.000476020872431
getting topparses
outputting cat probs
done with sent


making  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  eq($0,pro:dem|that,$1)
making  $0,pro:dem|that,$1)
making  pro:dem|that,$1)
making  $1)
sentence is  Eve has a hat .
making  lambda $0_{ev}.eq(pro:dem|that,and(n:prop|Jack,n:prop|Jill),$0)
making  eq(pro:dem|that,and(n:prop|Jack,n:prop|Jill),$0)
making  pro:dem|that,and(n:prop|Jack,n:prop|Jill),$0)
making  and(n:prop|Jack,n:prop|Jill),$0)
making  n:prop|Jack
making  n:prop|Jill
making  $0)
sentence is  Eve has a hat .
making  lambda $0_{ev}.not(aux|do&3S(v|have(pro|he,det|a($1,n|hat($1)),$0),$0),$0)
making  not(aux|do&3S(v|have(pro|he,det|a($1,n|hat($1)),$0),$0),$0)
making  aux|do&3S(v|have(pro|he,det|a($1,n|hat($1)),$0),$0),$0)
making  v|have(pro|he,det|a($1,n|hat($1)),$0)
making  pro|he
making  det|a($1,n|hat($1))
making  n|hat($1)
making  $1
making  $0
making  $0
making  $0)
sentence is  Eve has a hat .
making  lambda $0_{ev}.v|have&3S(n:prop|Eve,det|a($1,n|hat($1)),$0)
making  v|have&3S(n:prop|Eve,det|a($1,n|hat($1)),$0)
making  n:prop|Eve
making  det|a($1,n|hat($1))
making  n|hat($1)
making  $1
making  $0
sentence is  Eve has a hat .
making  lambda $0_{ev}.aux|be&PRES(and(part|go-PROG(pro|you,$0),v|find(pro|you,pro|it,$0)),$0)
making  aux|be&PRES(and(part|go-PROG(pro|you,$0),v|find(pro|you,pro|it,$0)),$0)
making  and(part|go-PROG(pro|you,$0),v|find(pro|you,pro|it,$0))
making  part|go-PROG(pro|you,$0)
making  pro|you
making  $0
making  v|find(pro|you,pro|it,$0)
making  pro|you
making  pro|it
making  $0
making  $0
sentence is  Eve has a hat .
making  lambda $0_{ev}.adv:loc|there($0)
making  adv:loc|there($0)
making  $0
sentence is  Eve has a hat .
making  lambda $0_{e}.n|man($0)
making  n|man($0)
making  $0
sentence is  Eve has a hat .

got training pair
Sent : Eve has a hat .
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
Cat : S:lambda $0_{ev}.eq(pro:dem|that,and(n:prop|Jack,n:prop|Jill),$0)
Cat : S:lambda $0_{ev}.not(aux|do&3S(v|have(pro|he,det|a($1,n|hat($1)),$0),$0),$0)
Cat : S:lambda $0_{ev}.v|have&3S(n:prop|Eve,det|a($1,n|hat($1)),$0)
Cat : S:lambda $0_{ev}.aux|be&PRES(and(part|go-PROG(pro|you,$0),v|find(pro|you,pro|it,$0)),$0)
Cat : S:lambda $0_{ev}.adv:loc|there($0)
Cat : Swh:lambda $0_{e}.n|man($0)
sentence is  ['Eve', 'has', 'a', 'hat']
sem is  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
sem is  lambda $0_{ev}.eq(pro:dem|that,and(n:prop|Jack,n:prop|Jill),$0)
sem is  lambda $0_{ev}.not(aux|do&3S(v|have(pro|he,det|a($1,n|hat($1)),$0),$0),$0)
sem is  lambda $0_{ev}.v|have&3S(n:prop|Eve,det|a($1,n|hat($1)),$0)
sem is  lambda $0_{ev}.aux|be&PRES(and(part|go-PROG(pro|you,$0),v|find(pro|you,pro|it,$0)),$0)
sem is  lambda $0_{ev}.adv:loc|there($0)
sem is  lambda $0_{e}.n|man($0)
size of chart is  1728
got chart
norm score is  -25.4798875909
doing updates with learning rate  0.0245318454645
Deleting 0 entries of the total 6644
done io
WATCH	Eve has a hat .
WATCH	53	((S\NP)\NP)	0.685501388277
WATCH	53	((S\NP)/NP)	0.00211443141198
WATCH	53	((S/NP)/NP)	0.311941549737
WATCH	53	((S/NP)\NP)	0.000442630574633
getting topparses
outputting cat probs
done with sent


making  lambda $0_{ev}.eq(pro:dem|that,and(n:prop|Jack,n:prop|Jill),$0)
making  eq(pro:dem|that,and(n:prop|Jack,n:prop|Jill),$0)
making  pro:dem|that,and(n:prop|Jack,n:prop|Jill),$0)
making  and(n:prop|Jack,n:prop|Jill),$0)
making  n:prop|Jack
making  n:prop|Jill
making  $0)
sentence is  you 're gonna find it .
making  lambda $0_{ev}.not(aux|do&3S(v|have(pro|he,det|a($1,n|hat($1)),$0),$0),$0)
making  not(aux|do&3S(v|have(pro|he,det|a($1,n|hat($1)),$0),$0),$0)
making  aux|do&3S(v|have(pro|he,det|a($1,n|hat($1)),$0),$0),$0)
making  v|have(pro|he,det|a($1,n|hat($1)),$0)
making  pro|he
making  det|a($1,n|hat($1))
making  n|hat($1)
making  $1
making  $0
making  $0
making  $0)
sentence is  you 're gonna find it .
making  lambda $0_{ev}.v|have&3S(n:prop|Eve,det|a($1,n|hat($1)),$0)
making  v|have&3S(n:prop|Eve,det|a($1,n|hat($1)),$0)
making  n:prop|Eve
making  det|a($1,n|hat($1))
making  n|hat($1)
making  $1
making  $0
sentence is  you 're gonna find it .
making  lambda $0_{ev}.aux|be&PRES(and(part|go-PROG(pro|you,$0),v|find(pro|you,pro|it,$0)),$0)
making  aux|be&PRES(and(part|go-PROG(pro|you,$0),v|find(pro|you,pro|it,$0)),$0)
making  and(part|go-PROG(pro|you,$0),v|find(pro|you,pro|it,$0))
making  part|go-PROG(pro|you,$0)
making  pro|you
making  $0
making  v|find(pro|you,pro|it,$0)
making  pro|you
making  pro|it
making  $0
making  $0
sentence is  you 're gonna find it .
making  lambda $0_{ev}.adv:loc|there($0)
making  adv:loc|there($0)
making  $0
sentence is  you 're gonna find it .
making  lambda $0_{e}.n|man($0)
making  n|man($0)
making  $0
sentence is  you 're gonna find it .
making  lambda $0_{e}.lambda $1_{ev}.eq($0,det|that($2,n|man($2)),$1)
making  lambda $1_{ev}.eq($0,det|that($2,n|man($2)),$1)
making  eq($0,det|that($2,n|man($2)),$1)
making  $0,det|that($2,n|man($2)),$1)
making  det|that($2,n|man($2)),$1)
making  n|man($2)
making  $2
making  $1)
sentence is  you 're gonna find it .

got training pair
Sent : you 're gonna find it .
Cat : S:lambda $0_{ev}.eq(pro:dem|that,and(n:prop|Jack,n:prop|Jill),$0)
Cat : S:lambda $0_{ev}.not(aux|do&3S(v|have(pro|he,det|a($1,n|hat($1)),$0),$0),$0)
Cat : S:lambda $0_{ev}.v|have&3S(n:prop|Eve,det|a($1,n|hat($1)),$0)
Cat : S:lambda $0_{ev}.aux|be&PRES(and(part|go-PROG(pro|you,$0),v|find(pro|you,pro|it,$0)),$0)
Cat : S:lambda $0_{ev}.adv:loc|there($0)
Cat : Swh:lambda $0_{e}.n|man($0)
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.eq($0,det|that($2,n|man($2)),$1)
sentence is  ['you', "'re", 'gonna', 'find', 'it']
sem is  lambda $0_{ev}.eq(pro:dem|that,and(n:prop|Jack,n:prop|Jill),$0)
sem is  lambda $0_{ev}.not(aux|do&3S(v|have(pro|he,det|a($1,n|hat($1)),$0),$0),$0)
sem is  lambda $0_{ev}.v|have&3S(n:prop|Eve,det|a($1,n|hat($1)),$0)
sem is  lambda $0_{ev}.aux|be&PRES(and(part|go-PROG(pro|you,$0),v|find(pro|you,pro|it,$0)),$0)
sem is  lambda $0_{ev}.adv:loc|there($0)
sem is  lambda $0_{e}.n|man($0)
sem is  lambda $0_{e}.lambda $1_{ev}.eq($0,det|that($2,n|man($2)),$1)
size of chart is  4813
got chart
norm score is  -34.3783687329
doing updates with learning rate  0.0243429568107
Deleting 0 entries of the total 9280
done io
WATCH	you 're gonna find it .
WATCH	54	((S\NP)\NP)	0.680272779583
WATCH	54	((S\NP)/NP)	0.00208647692945
WATCH	54	((S/NP)/NP)	0.317196767049
WATCH	54	((S/NP)\NP)	0.000443976438733
getting topparses
outputting cat probs
done with sent


making  lambda $0_{ev}.not(aux|do&3S(v|have(pro|he,det|a($1,n|hat($1)),$0),$0),$0)
making  not(aux|do&3S(v|have(pro|he,det|a($1,n|hat($1)),$0),$0),$0)
making  aux|do&3S(v|have(pro|he,det|a($1,n|hat($1)),$0),$0),$0)
making  v|have(pro|he,det|a($1,n|hat($1)),$0)
making  pro|he
making  det|a($1,n|hat($1))
making  n|hat($1)
making  $1
making  $0
making  $0
making  $0)
sentence is  there .
making  lambda $0_{ev}.v|have&3S(n:prop|Eve,det|a($1,n|hat($1)),$0)
making  v|have&3S(n:prop|Eve,det|a($1,n|hat($1)),$0)
making  n:prop|Eve
making  det|a($1,n|hat($1))
making  n|hat($1)
making  $1
making  $0
sentence is  there .
making  lambda $0_{ev}.aux|be&PRES(and(part|go-PROG(pro|you,$0),v|find(pro|you,pro|it,$0)),$0)
making  aux|be&PRES(and(part|go-PROG(pro|you,$0),v|find(pro|you,pro|it,$0)),$0)
making  and(part|go-PROG(pro|you,$0),v|find(pro|you,pro|it,$0))
making  part|go-PROG(pro|you,$0)
making  pro|you
making  $0
making  v|find(pro|you,pro|it,$0)
making  pro|you
making  pro|it
making  $0
making  $0
sentence is  there .
making  lambda $0_{ev}.adv:loc|there($0)
making  adv:loc|there($0)
making  $0
sentence is  there .
making  lambda $0_{e}.n|man($0)
making  n|man($0)
making  $0
sentence is  there .
making  lambda $0_{e}.lambda $1_{ev}.eq($0,det|that($2,n|man($2)),$1)
making  lambda $1_{ev}.eq($0,det|that($2,n|man($2)),$1)
making  eq($0,det|that($2,n|man($2)),$1)
making  $0,det|that($2,n|man($2)),$1)
making  det|that($2,n|man($2)),$1)
making  n|man($2)
making  $2
making  $1)
sentence is  there .
making  lambda $0_{ev}.Q(n:prop|Eve,$0)
making  Q(n:prop|Eve,$0)
making  n:prop|Eve,$0)
making  $0)
Is Q
sentence is  there .

got training pair
Sent : there .
Cat : S:lambda $0_{ev}.not(aux|do&3S(v|have(pro|he,det|a($1,n|hat($1)),$0),$0),$0)
Cat : S:lambda $0_{ev}.v|have&3S(n:prop|Eve,det|a($1,n|hat($1)),$0)
Cat : S:lambda $0_{ev}.aux|be&PRES(and(part|go-PROG(pro|you,$0),v|find(pro|you,pro|it,$0)),$0)
Cat : S:lambda $0_{ev}.adv:loc|there($0)
Cat : Swh:lambda $0_{e}.n|man($0)
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.eq($0,det|that($2,n|man($2)),$1)
Cat : Syn:lambda $0_{ev}.Q(n:prop|Eve,$0)
sentence is  ['there', '.']
sem is  lambda $0_{ev}.not(aux|do&3S(v|have(pro|he,det|a($1,n|hat($1)),$0),$0),$0)
sem is  lambda $0_{ev}.v|have&3S(n:prop|Eve,det|a($1,n|hat($1)),$0)
sem is  lambda $0_{ev}.aux|be&PRES(and(part|go-PROG(pro|you,$0),v|find(pro|you,pro|it,$0)),$0)
sem is  lambda $0_{ev}.adv:loc|there($0)
sem is  lambda $0_{e}.n|man($0)
sem is  lambda $0_{e}.lambda $1_{ev}.eq($0,det|that($2,n|man($2)),$1)
sem is  lambda $0_{ev}.Q(n:prop|Eve,$0)
size of chart is  91
got chart
norm score is  -10.648876814
doing updates with learning rate  0.0241573093489
Deleting 0 entries of the total 9363
done io
WATCH	there .
WATCH	55	((S\NP)\NP)	0.680287730806
WATCH	55	((S\NP)/NP)	0.00207559973148
WATCH	55	((S/NP)/NP)	0.317198816206
WATCH	55	((S/NP)\NP)	0.000437853256406
getting topparses
outputting cat probs
done with sent


making  lambda $0_{ev}.v|have&3S(n:prop|Eve,det|a($1,n|hat($1)),$0)
making  v|have&3S(n:prop|Eve,det|a($1,n|hat($1)),$0)
making  n:prop|Eve
making  det|a($1,n|hat($1))
making  n|hat($1)
making  $1
making  $0
sentence is  man ?
making  lambda $0_{ev}.aux|be&PRES(and(part|go-PROG(pro|you,$0),v|find(pro|you,pro|it,$0)),$0)
making  aux|be&PRES(and(part|go-PROG(pro|you,$0),v|find(pro|you,pro|it,$0)),$0)
making  and(part|go-PROG(pro|you,$0),v|find(pro|you,pro|it,$0))
making  part|go-PROG(pro|you,$0)
making  pro|you
making  $0
making  v|find(pro|you,pro|it,$0)
making  pro|you
making  pro|it
making  $0
making  $0
sentence is  man ?
making  lambda $0_{ev}.adv:loc|there($0)
making  adv:loc|there($0)
making  $0
sentence is  man ?
making  lambda $0_{e}.n|man($0)
making  n|man($0)
making  $0
sentence is  man ?
making  lambda $0_{e}.lambda $1_{ev}.eq($0,det|that($2,n|man($2)),$1)
making  lambda $1_{ev}.eq($0,det|that($2,n|man($2)),$1)
making  eq($0,det|that($2,n|man($2)),$1)
making  $0,det|that($2,n|man($2)),$1)
making  det|that($2,n|man($2)),$1)
making  n|man($2)
making  $2
making  $1)
sentence is  man ?
making  lambda $0_{ev}.Q(n:prop|Eve,$0)
making  Q(n:prop|Eve,$0)
making  n:prop|Eve,$0)
making  $0)
Is Q
sentence is  man ?
making  lambda $0_{ev}.eq(pro|you,n:prop|Eve,$0)
making  eq(pro|you,n:prop|Eve,$0)
making  pro|you,n:prop|Eve,$0)
making  n:prop|Eve,$0)
making  $0)
sentence is  man ?

got training pair
Sent : man ?
Cat : S:lambda $0_{ev}.v|have&3S(n:prop|Eve,det|a($1,n|hat($1)),$0)
Cat : S:lambda $0_{ev}.aux|be&PRES(and(part|go-PROG(pro|you,$0),v|find(pro|you,pro|it,$0)),$0)
Cat : S:lambda $0_{ev}.adv:loc|there($0)
Cat : Swh:lambda $0_{e}.n|man($0)
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.eq($0,det|that($2,n|man($2)),$1)
Cat : Syn:lambda $0_{ev}.Q(n:prop|Eve,$0)
Cat : S:lambda $0_{ev}.eq(pro|you,n:prop|Eve,$0)
sentence is  ['man']
sem is  lambda $0_{ev}.v|have&3S(n:prop|Eve,det|a($1,n|hat($1)),$0)
sem is  lambda $0_{ev}.aux|be&PRES(and(part|go-PROG(pro|you,$0),v|find(pro|you,pro|it,$0)),$0)
sem is  lambda $0_{ev}.adv:loc|there($0)
sem is  lambda $0_{e}.n|man($0)
sem is  lambda $0_{e}.lambda $1_{ev}.eq($0,det|that($2,n|man($2)),$1)
sem is  lambda $0_{ev}.Q(n:prop|Eve,$0)
sem is  lambda $0_{ev}.eq(pro|you,n:prop|Eve,$0)
size of chart is  7
got chart
norm score is  -6.84466115419
doing updates with learning rate  0.0239748173813
Deleting 0 entries of the total 9370
done io
WATCH	man ?
WATCH	56	((S\NP)\NP)	0.680302615361
WATCH	56	((S\NP)/NP)	0.00206462206547
WATCH	56	((S/NP)/NP)	0.317201035482
WATCH	56	((S/NP)\NP)	0.000431727092097
getting topparses
outputting cat probs
done with sent


making  lambda $0_{ev}.aux|be&PRES(and(part|go-PROG(pro|you,$0),v|find(pro|you,pro|it,$0)),$0)
making  aux|be&PRES(and(part|go-PROG(pro|you,$0),v|find(pro|you,pro|it,$0)),$0)
making  and(part|go-PROG(pro|you,$0),v|find(pro|you,pro|it,$0))
making  part|go-PROG(pro|you,$0)
making  pro|you
making  $0
making  v|find(pro|you,pro|it,$0)
making  pro|you
making  pro|it
making  $0
making  $0
sentence is  who is that man ?
making  lambda $0_{ev}.adv:loc|there($0)
making  adv:loc|there($0)
making  $0
sentence is  who is that man ?
making  lambda $0_{e}.n|man($0)
making  n|man($0)
making  $0
sentence is  who is that man ?
making  lambda $0_{e}.lambda $1_{ev}.eq($0,det|that($2,n|man($2)),$1)
making  lambda $1_{ev}.eq($0,det|that($2,n|man($2)),$1)
making  eq($0,det|that($2,n|man($2)),$1)
making  $0,det|that($2,n|man($2)),$1)
making  det|that($2,n|man($2)),$1)
making  n|man($2)
making  $2
making  $1)
sentence is  who is that man ?
making  lambda $0_{ev}.Q(n:prop|Eve,$0)
making  Q(n:prop|Eve,$0)
making  n:prop|Eve,$0)
making  $0)
Is Q
sentence is  who is that man ?
making  lambda $0_{ev}.eq(pro|you,n:prop|Eve,$0)
making  eq(pro|you,n:prop|Eve,$0)
making  pro|you,n:prop|Eve,$0)
making  n:prop|Eve,$0)
making  $0)
sentence is  who is that man ?
making  lambda $0_{ev}.adv:loc|down($0)
making  adv:loc|down($0)
making  $0
sentence is  who is that man ?

got training pair
Sent : who is that man ?
Cat : S:lambda $0_{ev}.aux|be&PRES(and(part|go-PROG(pro|you,$0),v|find(pro|you,pro|it,$0)),$0)
Cat : S:lambda $0_{ev}.adv:loc|there($0)
Cat : Swh:lambda $0_{e}.n|man($0)
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.eq($0,det|that($2,n|man($2)),$1)
Cat : Syn:lambda $0_{ev}.Q(n:prop|Eve,$0)
Cat : S:lambda $0_{ev}.eq(pro|you,n:prop|Eve,$0)
Cat : S:lambda $0_{ev}.adv:loc|down($0)
sentence is  ['who', 'is', 'that', 'man']
sem is  lambda $0_{ev}.aux|be&PRES(and(part|go-PROG(pro|you,$0),v|find(pro|you,pro|it,$0)),$0)
sem is  lambda $0_{ev}.adv:loc|there($0)
sem is  lambda $0_{e}.n|man($0)
sem is  lambda $0_{e}.lambda $1_{ev}.eq($0,det|that($2,n|man($2)),$1)
sem is  lambda $0_{ev}.Q(n:prop|Eve,$0)
sem is  lambda $0_{ev}.eq(pro|you,n:prop|Eve,$0)
sem is  lambda $0_{ev}.adv:loc|down($0)
size of chart is  1110
got chart
norm score is  -27.6424193752
doing updates with learning rate  0.0237953982564
Deleting 0 entries of the total 10065
done io
WATCH	who is that man ?
WATCH	57	((S\NP)\NP)	0.695571494544
WATCH	57	((S\NP)/NP)	0.00191945271476
WATCH	57	((S/NP)/NP)	0.302118022633
WATCH	57	((S/NP)\NP)	0.000391030107929
getting topparses
outputting cat probs
done with sent


making  lambda $0_{ev}.adv:loc|there($0)
making  adv:loc|there($0)
making  $0
sentence is  Eve ?
making  lambda $0_{e}.n|man($0)
making  n|man($0)
making  $0
sentence is  Eve ?
making  lambda $0_{e}.lambda $1_{ev}.eq($0,det|that($2,n|man($2)),$1)
making  lambda $1_{ev}.eq($0,det|that($2,n|man($2)),$1)
making  eq($0,det|that($2,n|man($2)),$1)
making  $0,det|that($2,n|man($2)),$1)
making  det|that($2,n|man($2)),$1)
making  n|man($2)
making  $2
making  $1)
sentence is  Eve ?
making  lambda $0_{ev}.Q(n:prop|Eve,$0)
making  Q(n:prop|Eve,$0)
making  n:prop|Eve,$0)
making  $0)
Is Q
sentence is  Eve ?
making  lambda $0_{ev}.eq(pro|you,n:prop|Eve,$0)
making  eq(pro|you,n:prop|Eve,$0)
making  pro|you,n:prop|Eve,$0)
making  n:prop|Eve,$0)
making  $0)
sentence is  Eve ?
making  lambda $0_{ev}.adv:loc|down($0)
making  adv:loc|down($0)
making  $0
sentence is  Eve ?
making  lambda $0_{ev}.v|write(pro|you,det|a($1,n|letter($1)),$0)
making  v|write(pro|you,det|a($1,n|letter($1)),$0)
making  pro|you
making  det|a($1,n|letter($1))
making  n|letter($1)
making  $1
making  $0
sentence is  Eve ?

got training pair
Sent : Eve ?
Cat : S:lambda $0_{ev}.adv:loc|there($0)
Cat : Swh:lambda $0_{e}.n|man($0)
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.eq($0,det|that($2,n|man($2)),$1)
Cat : Syn:lambda $0_{ev}.Q(n:prop|Eve,$0)
Cat : S:lambda $0_{ev}.eq(pro|you,n:prop|Eve,$0)
Cat : S:lambda $0_{ev}.adv:loc|down($0)
Cat : S:lambda $0_{ev}.v|write(pro|you,det|a($1,n|letter($1)),$0)
sentence is  ['Eve']
sem is  lambda $0_{ev}.adv:loc|there($0)
sem is  lambda $0_{e}.n|man($0)
sem is  lambda $0_{e}.lambda $1_{ev}.eq($0,det|that($2,n|man($2)),$1)
sem is  lambda $0_{ev}.Q(n:prop|Eve,$0)
sem is  lambda $0_{ev}.eq(pro|you,n:prop|Eve,$0)
sem is  lambda $0_{ev}.adv:loc|down($0)
sem is  lambda $0_{ev}.v|write(pro|you,det|a($1,n|letter($1)),$0)
size of chart is  7
got chart
norm score is  -7.10455269694
doing updates with learning rate  0.0236189722338
Deleting 0 entries of the total 10070
done io
WATCH	Eve ?
WATCH	58	((S\NP)\NP)	0.69558612492
WATCH	58	((S\NP)/NP)	0.00190900646115
WATCH	58	((S/NP)/NP)	0.302119468292
WATCH	58	((S/NP)\NP)	0.000385400326846
getting topparses
outputting cat probs
done with sent


making  lambda $0_{e}.n|man($0)
making  n|man($0)
making  $0
sentence is  you 're Eve .
making  lambda $0_{e}.lambda $1_{ev}.eq($0,det|that($2,n|man($2)),$1)
making  lambda $1_{ev}.eq($0,det|that($2,n|man($2)),$1)
making  eq($0,det|that($2,n|man($2)),$1)
making  $0,det|that($2,n|man($2)),$1)
making  det|that($2,n|man($2)),$1)
making  n|man($2)
making  $2
making  $1)
sentence is  you 're Eve .
making  lambda $0_{ev}.Q(n:prop|Eve,$0)
making  Q(n:prop|Eve,$0)
making  n:prop|Eve,$0)
making  $0)
Is Q
sentence is  you 're Eve .
making  lambda $0_{ev}.eq(pro|you,n:prop|Eve,$0)
making  eq(pro|you,n:prop|Eve,$0)
making  pro|you,n:prop|Eve,$0)
making  n:prop|Eve,$0)
making  $0)
sentence is  you 're Eve .
making  lambda $0_{ev}.adv:loc|down($0)
making  adv:loc|down($0)
making  $0
sentence is  you 're Eve .
making  lambda $0_{ev}.v|write(pro|you,det|a($1,n|letter($1)),$0)
making  v|write(pro|you,det|a($1,n|letter($1)),$0)
making  pro|you
making  det|a($1,n|letter($1))
making  n|letter($1)
making  $1
making  $0
sentence is  you 're Eve .
making  lambda $0_{ev}.Q(det|the($1,n|pencil($1)),$0)
making  Q(det|the($1,n|pencil($1)),$0)
making  det|the($1,n|pencil($1)),$0)
making  n|pencil($1)
making  $1
making  $0)
Is Q
sentence is  you 're Eve .

got training pair
Sent : you 're Eve .
Cat : Swh:lambda $0_{e}.n|man($0)
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.eq($0,det|that($2,n|man($2)),$1)
Cat : Syn:lambda $0_{ev}.Q(n:prop|Eve,$0)
Cat : S:lambda $0_{ev}.eq(pro|you,n:prop|Eve,$0)
Cat : S:lambda $0_{ev}.adv:loc|down($0)
Cat : S:lambda $0_{ev}.v|write(pro|you,det|a($1,n|letter($1)),$0)
Cat : Syn:lambda $0_{ev}.Q(det|the($1,n|pencil($1)),$0)
sentence is  ['you', "'re", 'Eve', '.']
sem is  lambda $0_{e}.n|man($0)
sem is  lambda $0_{e}.lambda $1_{ev}.eq($0,det|that($2,n|man($2)),$1)
sem is  lambda $0_{ev}.Q(n:prop|Eve,$0)
sem is  lambda $0_{ev}.eq(pro|you,n:prop|Eve,$0)
sem is  lambda $0_{ev}.adv:loc|down($0)
sem is  lambda $0_{ev}.v|write(pro|you,det|a($1,n|letter($1)),$0)
sem is  lambda $0_{ev}.Q(det|the($1,n|pencil($1)),$0)
size of chart is  610
got chart
norm score is  -20.2900438415
doing updates with learning rate  0.0234454623554
Deleting 0 entries of the total 10343
done io
WATCH	you 're Eve .
WATCH	59	((S\NP)\NP)	0.717450671587
WATCH	59	((S\NP)/NP)	0.00193561764667
WATCH	59	((S/NP)/NP)	0.280261402928
WATCH	59	((S/NP)\NP)	0.000352307837896
getting topparses
outputting cat probs
done with sent


making  lambda $0_{e}.lambda $1_{ev}.eq($0,det|that($2,n|man($2)),$1)
making  lambda $1_{ev}.eq($0,det|that($2,n|man($2)),$1)
making  eq($0,det|that($2,n|man($2)),$1)
making  $0,det|that($2,n|man($2)),$1)
making  det|that($2,n|man($2)),$1)
making  n|man($2)
making  $2
making  $1)
sentence is  down .
making  lambda $0_{ev}.Q(n:prop|Eve,$0)
making  Q(n:prop|Eve,$0)
making  n:prop|Eve,$0)
making  $0)
Is Q
sentence is  down .
making  lambda $0_{ev}.eq(pro|you,n:prop|Eve,$0)
making  eq(pro|you,n:prop|Eve,$0)
making  pro|you,n:prop|Eve,$0)
making  n:prop|Eve,$0)
making  $0)
sentence is  down .
making  lambda $0_{ev}.adv:loc|down($0)
making  adv:loc|down($0)
making  $0
sentence is  down .
making  lambda $0_{ev}.v|write(pro|you,det|a($1,n|letter($1)),$0)
making  v|write(pro|you,det|a($1,n|letter($1)),$0)
making  pro|you
making  det|a($1,n|letter($1))
making  n|letter($1)
making  $1
making  $0
sentence is  down .
making  lambda $0_{ev}.Q(det|the($1,n|pencil($1)),$0)
making  Q(det|the($1,n|pencil($1)),$0)
making  det|the($1,n|pencil($1)),$0)
making  n|pencil($1)
making  $1
making  $0)
Is Q
sentence is  down .
making  lambda $0_{ev}.eq(pro:dem|that,pro:poss:det|your($1,n|pencil($1)),$0)
making  eq(pro:dem|that,pro:poss:det|your($1,n|pencil($1)),$0)
making  pro:dem|that,pro:poss:det|your($1,n|pencil($1)),$0)
making  pro:poss:det|your($1,n|pencil($1)),$0)
making  n|pencil($1)
making  $1
making  $0)
sentence is  down .

got training pair
Sent : down .
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.eq($0,det|that($2,n|man($2)),$1)
Cat : Syn:lambda $0_{ev}.Q(n:prop|Eve,$0)
Cat : S:lambda $0_{ev}.eq(pro|you,n:prop|Eve,$0)
Cat : S:lambda $0_{ev}.adv:loc|down($0)
Cat : S:lambda $0_{ev}.v|write(pro|you,det|a($1,n|letter($1)),$0)
Cat : Syn:lambda $0_{ev}.Q(det|the($1,n|pencil($1)),$0)
Cat : S:lambda $0_{ev}.eq(pro:dem|that,pro:poss:det|your($1,n|pencil($1)),$0)
sentence is  ['down']
sem is  lambda $0_{e}.lambda $1_{ev}.eq($0,det|that($2,n|man($2)),$1)
sem is  lambda $0_{ev}.Q(n:prop|Eve,$0)
sem is  lambda $0_{ev}.eq(pro|you,n:prop|Eve,$0)
sem is  lambda $0_{ev}.adv:loc|down($0)
sem is  lambda $0_{ev}.v|write(pro|you,det|a($1,n|letter($1)),$0)
sem is  lambda $0_{ev}.Q(det|the($1,n|pencil($1)),$0)
sem is  lambda $0_{ev}.eq(pro:dem|that,pro:poss:det|your($1,n|pencil($1)),$0)
size of chart is  7
got chart
norm score is  -11.4088251476
doing updates with learning rate  0.023274794324
Deleting 0 entries of the total 10350
done io
WATCH	down .
WATCH	60	((S\NP)\NP)	0.717465557902
WATCH	60	((S\NP)/NP)	0.00192522305352
WATCH	60	((S/NP)/NP)	0.280262127837
WATCH	60	((S/NP)\NP)	0.000347091207239
getting topparses
outputting cat probs
done with sent


making  lambda $0_{ev}.Q(n:prop|Eve,$0)
making  Q(n:prop|Eve,$0)
making  n:prop|Eve,$0)
making  $0)
Is Q
sentence is  you write a letter .
making  lambda $0_{ev}.eq(pro|you,n:prop|Eve,$0)
making  eq(pro|you,n:prop|Eve,$0)
making  pro|you,n:prop|Eve,$0)
making  n:prop|Eve,$0)
making  $0)
sentence is  you write a letter .
making  lambda $0_{ev}.adv:loc|down($0)
making  adv:loc|down($0)
making  $0
sentence is  you write a letter .
making  lambda $0_{ev}.v|write(pro|you,det|a($1,n|letter($1)),$0)
making  v|write(pro|you,det|a($1,n|letter($1)),$0)
making  pro|you
making  det|a($1,n|letter($1))
making  n|letter($1)
making  $1
making  $0
sentence is  you write a letter .
making  lambda $0_{ev}.Q(det|the($1,n|pencil($1)),$0)
making  Q(det|the($1,n|pencil($1)),$0)
making  det|the($1,n|pencil($1)),$0)
making  n|pencil($1)
making  $1
making  $0)
Is Q
sentence is  you write a letter .
making  lambda $0_{ev}.eq(pro:dem|that,pro:poss:det|your($1,n|pencil($1)),$0)
making  eq(pro:dem|that,pro:poss:det|your($1,n|pencil($1)),$0)
making  pro:dem|that,pro:poss:det|your($1,n|pencil($1)),$0)
making  pro:poss:det|your($1,n|pencil($1)),$0)
making  n|pencil($1)
making  $1
making  $0)
sentence is  you write a letter .
making  lambda $0_{ev}.Q(det|the($1,n|man($1)),$0)
making  Q(det|the($1,n|man($1)),$0)
making  det|the($1,n|man($1)),$0)
making  n|man($1)
making  $1
making  $0)
Is Q
sentence is  you write a letter .

got training pair
Sent : you write a letter .
Cat : Syn:lambda $0_{ev}.Q(n:prop|Eve,$0)
Cat : S:lambda $0_{ev}.eq(pro|you,n:prop|Eve,$0)
Cat : S:lambda $0_{ev}.adv:loc|down($0)
Cat : S:lambda $0_{ev}.v|write(pro|you,det|a($1,n|letter($1)),$0)
Cat : Syn:lambda $0_{ev}.Q(det|the($1,n|pencil($1)),$0)
Cat : S:lambda $0_{ev}.eq(pro:dem|that,pro:poss:det|your($1,n|pencil($1)),$0)
Cat : Syn:lambda $0_{ev}.Q(det|the($1,n|man($1)),$0)
sentence is  ['you', 'write', 'a', 'letter', '.']
sem is  lambda $0_{ev}.Q(n:prop|Eve,$0)
sem is  lambda $0_{ev}.eq(pro|you,n:prop|Eve,$0)
sem is  lambda $0_{ev}.adv:loc|down($0)
sem is  lambda $0_{ev}.v|write(pro|you,det|a($1,n|letter($1)),$0)
sem is  lambda $0_{ev}.Q(det|the($1,n|pencil($1)),$0)
sem is  lambda $0_{ev}.eq(pro:dem|that,pro:poss:det|your($1,n|pencil($1)),$0)
sem is  lambda $0_{ev}.Q(det|the($1,n|man($1)),$0)
size of chart is  1083
got chart
norm score is  -35.5963895286
doing updates with learning rate  0.0231068963886
Deleting 9590 entries of the total 10958
done io
WATCH	you write a letter .
WATCH	61	((S\NP)\NP)	0.734475376269
WATCH	61	((S\NP)/NP)	0.00183298753168
WATCH	61	((S/NP)/NP)	0.263359064076
WATCH	61	((S/NP)\NP)	0.000332572123833
getting topparses
outputting cat probs
done with sent


making  lambda $0_{ev}.eq(pro|you,n:prop|Eve,$0)
making  eq(pro|you,n:prop|Eve,$0)
making  pro|you,n:prop|Eve,$0)
making  n:prop|Eve,$0)
making  $0)
sentence is  the pencil ?
making  lambda $0_{ev}.adv:loc|down($0)
making  adv:loc|down($0)
making  $0
sentence is  the pencil ?
making  lambda $0_{ev}.v|write(pro|you,det|a($1,n|letter($1)),$0)
making  v|write(pro|you,det|a($1,n|letter($1)),$0)
making  pro|you
making  det|a($1,n|letter($1))
making  n|letter($1)
making  $1
making  $0
sentence is  the pencil ?
making  lambda $0_{ev}.Q(det|the($1,n|pencil($1)),$0)
making  Q(det|the($1,n|pencil($1)),$0)
making  det|the($1,n|pencil($1)),$0)
making  n|pencil($1)
making  $1
making  $0)
Is Q
sentence is  the pencil ?
making  lambda $0_{ev}.eq(pro:dem|that,pro:poss:det|your($1,n|pencil($1)),$0)
making  eq(pro:dem|that,pro:poss:det|your($1,n|pencil($1)),$0)
making  pro:dem|that,pro:poss:det|your($1,n|pencil($1)),$0)
making  pro:poss:det|your($1,n|pencil($1)),$0)
making  n|pencil($1)
making  $1
making  $0)
sentence is  the pencil ?
making  lambda $0_{ev}.Q(det|the($1,n|man($1)),$0)
making  Q(det|the($1,n|man($1)),$0)
making  det|the($1,n|man($1)),$0)
making  n|man($1)
making  $1
making  $0)
Is Q
sentence is  the pencil ?
making  lambda $0_{e}.lambda $1_{ev}.and(aux|be&PRES(part|do-PROG(pro|you,$0,$1),$1),prep|in(det|the($2,n|corner($2)),$1))
making  lambda $1_{ev}.and(aux|be&PRES(part|do-PROG(pro|you,$0,$1),$1),prep|in(det|the($2,n|corner($2)),$1))
making  and(aux|be&PRES(part|do-PROG(pro|you,$0,$1),$1),prep|in(det|the($2,n|corner($2)),$1))
making  aux|be&PRES(part|do-PROG(pro|you,$0,$1),$1)
making  part|do-PROG(pro|you,$0,$1)
making  pro|you
making  $0
making  $1
making  $1
making  prep|in(det|the($2,n|corner($2)),$1)
making  det|the($2,n|corner($2))
making  n|corner($2)
making  $2
making  $1
sentence is  the pencil ?

got training pair
Sent : the pencil ?
Cat : S:lambda $0_{ev}.eq(pro|you,n:prop|Eve,$0)
Cat : S:lambda $0_{ev}.adv:loc|down($0)
Cat : S:lambda $0_{ev}.v|write(pro|you,det|a($1,n|letter($1)),$0)
Cat : Syn:lambda $0_{ev}.Q(det|the($1,n|pencil($1)),$0)
Cat : S:lambda $0_{ev}.eq(pro:dem|that,pro:poss:det|your($1,n|pencil($1)),$0)
Cat : Syn:lambda $0_{ev}.Q(det|the($1,n|man($1)),$0)
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.and(aux|be&PRES(part|do-PROG(pro|you,$0,$1),$1),prep|in(det|the($2,n|corner($2)),$1))
sentence is  ['the', 'pencil']
sem is  lambda $0_{ev}.eq(pro|you,n:prop|Eve,$0)
sem is  lambda $0_{ev}.adv:loc|down($0)
sem is  lambda $0_{ev}.v|write(pro|you,det|a($1,n|letter($1)),$0)
sem is  lambda $0_{ev}.Q(det|the($1,n|pencil($1)),$0)
sem is  lambda $0_{ev}.eq(pro:dem|that,pro:poss:det|your($1,n|pencil($1)),$0)
sem is  lambda $0_{ev}.Q(det|the($1,n|man($1)),$0)
sem is  lambda $0_{e}.lambda $1_{ev}.and(aux|be&PRES(part|do-PROG(pro|you,$0,$1),$1),prep|in(det|the($2,n|corner($2)),$1))
types dont match 2 :  (Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|in(det|the($2,n|corner($2)),$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|in(det|the($2,n|corner($2)),$1)) (S/NP):lambda $0_{e}.lambda $1_{ev}.aux|be&PRES(part|do-PROG(pro|you,$0,$1),$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|in(det|the($2,n|corner($2)),$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
types dont match 2 :  (Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|in(det|the($2,n|corner($2)),$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|in(det|the($2,n|corner($2)),$1)) (S\NP):lambda $0_{e}.lambda $1_{ev}.aux|be&PRES(part|do-PROG(pro|you,$0,$1),$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|in(det|the($2,n|corner($2)),$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
types dont match 2 :  (Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|in(det|the($2,n|corner($2)),$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|in(det|the($2,n|corner($2)),$1)) (S/NP):lambda $0_{e}.lambda $1_{ev}.aux|be&PRES(part|do-PROG(pro|you,$0,$1),$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|in(det|the($2,n|corner($2)),$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
types dont match 2 :  (Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|in(det|the($2,n|corner($2)),$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|in(det|the($2,n|corner($2)),$1)) (S\NP):lambda $0_{e}.lambda $1_{ev}.aux|be&PRES(part|do-PROG(pro|you,$0,$1),$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|in(det|the($2,n|corner($2)),$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
types dont match 2 :  (Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and(aux|be&PRES($0($1),$1),prep|in(det|the($2,n|corner($2)),$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and(aux|be&PRES($0($1),$1),prep|in(det|the($2,n|corner($2)),$1)) (S/NP):lambda $0_{e}.lambda $1_{ev}.part|do-PROG(pro|you,$0,$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and(aux|be&PRES($0($1),$1),prep|in(det|the($2,n|corner($2)),$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
types dont match 2 :  (Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and(aux|be&PRES($0($1),$1),prep|in(det|the($2,n|corner($2)),$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and(aux|be&PRES($0($1),$1),prep|in(det|the($2,n|corner($2)),$1)) (S\NP):lambda $0_{e}.lambda $1_{ev}.part|do-PROG(pro|you,$0,$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and(aux|be&PRES($0($1),$1),prep|in(det|the($2,n|corner($2)),$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
size of chart is  101
got chart
norm score is  -18.9279937306
doing updates with learning rate  0.0229416992343
Deleting 0 entries of the total 1453
done io
WATCH	the pencil ?
WATCH	62	((S\NP)\NP)	0.735361265694
WATCH	62	((S\NP)/NP)	0.00182506322963
WATCH	62	((S/NP)/NP)	0.262487190682
WATCH	62	((S/NP)\NP)	0.000326480394607
getting topparses
outputting cat probs
done with sent


making  lambda $0_{ev}.adv:loc|down($0)
making  adv:loc|down($0)
making  $0
sentence is  that 's your pencil .
making  lambda $0_{ev}.v|write(pro|you,det|a($1,n|letter($1)),$0)
making  v|write(pro|you,det|a($1,n|letter($1)),$0)
making  pro|you
making  det|a($1,n|letter($1))
making  n|letter($1)
making  $1
making  $0
sentence is  that 's your pencil .
making  lambda $0_{ev}.Q(det|the($1,n|pencil($1)),$0)
making  Q(det|the($1,n|pencil($1)),$0)
making  det|the($1,n|pencil($1)),$0)
making  n|pencil($1)
making  $1
making  $0)
Is Q
sentence is  that 's your pencil .
making  lambda $0_{ev}.eq(pro:dem|that,pro:poss:det|your($1,n|pencil($1)),$0)
making  eq(pro:dem|that,pro:poss:det|your($1,n|pencil($1)),$0)
making  pro:dem|that,pro:poss:det|your($1,n|pencil($1)),$0)
making  pro:poss:det|your($1,n|pencil($1)),$0)
making  n|pencil($1)
making  $1
making  $0)
sentence is  that 's your pencil .
making  lambda $0_{ev}.Q(det|the($1,n|man($1)),$0)
making  Q(det|the($1,n|man($1)),$0)
making  det|the($1,n|man($1)),$0)
making  n|man($1)
making  $1
making  $0)
Is Q
sentence is  that 's your pencil .
making  lambda $0_{e}.lambda $1_{ev}.and(aux|be&PRES(part|do-PROG(pro|you,$0,$1),$1),prep|in(det|the($2,n|corner($2)),$1))
making  lambda $1_{ev}.and(aux|be&PRES(part|do-PROG(pro|you,$0,$1),$1),prep|in(det|the($2,n|corner($2)),$1))
making  and(aux|be&PRES(part|do-PROG(pro|you,$0,$1),$1),prep|in(det|the($2,n|corner($2)),$1))
making  aux|be&PRES(part|do-PROG(pro|you,$0,$1),$1)
making  part|do-PROG(pro|you,$0,$1)
making  pro|you
making  $0
making  $1
making  $1
making  prep|in(det|the($2,n|corner($2)),$1)
making  det|the($2,n|corner($2))
making  n|corner($2)
making  $2
making  $1
sentence is  that 's your pencil .
making  lambda $0_{ev}.aux|be&PRES(and(part|go-PROG(pro|you,$0),v|read&ZERO(pro|you,$0)),$0)
making  aux|be&PRES(and(part|go-PROG(pro|you,$0),v|read&ZERO(pro|you,$0)),$0)
making  and(part|go-PROG(pro|you,$0),v|read&ZERO(pro|you,$0))
making  part|go-PROG(pro|you,$0)
making  pro|you
making  $0
making  v|read&ZERO(pro|you,$0)
making  pro|you
making  $0
making  $0
sentence is  that 's your pencil .

got training pair
Sent : that 's your pencil .
Cat : S:lambda $0_{ev}.adv:loc|down($0)
Cat : S:lambda $0_{ev}.v|write(pro|you,det|a($1,n|letter($1)),$0)
Cat : Syn:lambda $0_{ev}.Q(det|the($1,n|pencil($1)),$0)
Cat : S:lambda $0_{ev}.eq(pro:dem|that,pro:poss:det|your($1,n|pencil($1)),$0)
Cat : Syn:lambda $0_{ev}.Q(det|the($1,n|man($1)),$0)
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.and(aux|be&PRES(part|do-PROG(pro|you,$0,$1),$1),prep|in(det|the($2,n|corner($2)),$1))
Cat : S:lambda $0_{ev}.aux|be&PRES(and(part|go-PROG(pro|you,$0),v|read&ZERO(pro|you,$0)),$0)
sentence is  ['that', "'s", 'your', 'pencil']
sem is  lambda $0_{ev}.adv:loc|down($0)
sem is  lambda $0_{ev}.v|write(pro|you,det|a($1,n|letter($1)),$0)
sem is  lambda $0_{ev}.Q(det|the($1,n|pencil($1)),$0)
sem is  lambda $0_{ev}.eq(pro:dem|that,pro:poss:det|your($1,n|pencil($1)),$0)
sem is  lambda $0_{ev}.Q(det|the($1,n|man($1)),$0)
sem is  lambda $0_{e}.lambda $1_{ev}.and(aux|be&PRES(part|do-PROG(pro|you,$0,$1),$1),prep|in(det|the($2,n|corner($2)),$1))
types dont match 2 :  (Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|in(det|the($2,n|corner($2)),$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|in(det|the($2,n|corner($2)),$1)) (S/NP):lambda $0_{e}.lambda $1_{ev}.aux|be&PRES(part|do-PROG(pro|you,$0,$1),$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|in(det|the($2,n|corner($2)),$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
types dont match 2 :  (Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|in(det|the($2,n|corner($2)),$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|in(det|the($2,n|corner($2)),$1)) (S\NP):lambda $0_{e}.lambda $1_{ev}.aux|be&PRES(part|do-PROG(pro|you,$0,$1),$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|in(det|the($2,n|corner($2)),$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
types dont match 2 :  (Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|in(det|the($2,n|corner($2)),$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|in(det|the($2,n|corner($2)),$1)) (S/NP):lambda $0_{e}.lambda $1_{ev}.aux|be&PRES(part|do-PROG(pro|you,$0,$1),$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|in(det|the($2,n|corner($2)),$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
types dont match 2 :  (Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|in(det|the($2,n|corner($2)),$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|in(det|the($2,n|corner($2)),$1)) (S\NP):lambda $0_{e}.lambda $1_{ev}.aux|be&PRES(part|do-PROG(pro|you,$0,$1),$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|in(det|the($2,n|corner($2)),$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
types dont match 2 :  (Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and(aux|be&PRES($0($1),$1),prep|in(det|the($2,n|corner($2)),$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and(aux|be&PRES($0($1),$1),prep|in(det|the($2,n|corner($2)),$1)) (S/NP):lambda $0_{e}.lambda $1_{ev}.part|do-PROG(pro|you,$0,$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and(aux|be&PRES($0($1),$1),prep|in(det|the($2,n|corner($2)),$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
types dont match 2 :  (Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and(aux|be&PRES($0($1),$1),prep|in(det|the($2,n|corner($2)),$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and(aux|be&PRES($0($1),$1),prep|in(det|the($2,n|corner($2)),$1)) (S\NP):lambda $0_{e}.lambda $1_{ev}.part|do-PROG(pro|you,$0,$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and(aux|be&PRES($0($1),$1),prep|in(det|the($2,n|corner($2)),$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
sem is  lambda $0_{ev}.aux|be&PRES(and(part|go-PROG(pro|you,$0),v|read&ZERO(pro|you,$0)),$0)
size of chart is  2244
got chart
norm score is  -32.2932561088
doing updates with learning rate  0.0227791358797
Deleting 0 entries of the total 2525
done io
WATCH	that 's your pencil .
WATCH	63	((S\NP)\NP)	0.730495585028
WATCH	63	((S\NP)/NP)	0.00180358367675
WATCH	63	((S/NP)/NP)	0.267373518814
WATCH	63	((S/NP)\NP)	0.000327312481048
getting topparses
outputting cat probs
done with sent


making  lambda $0_{ev}.v|write(pro|you,det|a($1,n|letter($1)),$0)
making  v|write(pro|you,det|a($1,n|letter($1)),$0)
making  pro|you
making  det|a($1,n|letter($1))
making  n|letter($1)
making  $1
making  $0
sentence is  the man ?
making  lambda $0_{ev}.Q(det|the($1,n|pencil($1)),$0)
making  Q(det|the($1,n|pencil($1)),$0)
making  det|the($1,n|pencil($1)),$0)
making  n|pencil($1)
making  $1
making  $0)
Is Q
sentence is  the man ?
making  lambda $0_{ev}.eq(pro:dem|that,pro:poss:det|your($1,n|pencil($1)),$0)
making  eq(pro:dem|that,pro:poss:det|your($1,n|pencil($1)),$0)
making  pro:dem|that,pro:poss:det|your($1,n|pencil($1)),$0)
making  pro:poss:det|your($1,n|pencil($1)),$0)
making  n|pencil($1)
making  $1
making  $0)
sentence is  the man ?
making  lambda $0_{ev}.Q(det|the($1,n|man($1)),$0)
making  Q(det|the($1,n|man($1)),$0)
making  det|the($1,n|man($1)),$0)
making  n|man($1)
making  $1
making  $0)
Is Q
sentence is  the man ?
making  lambda $0_{e}.lambda $1_{ev}.and(aux|be&PRES(part|do-PROG(pro|you,$0,$1),$1),prep|in(det|the($2,n|corner($2)),$1))
making  lambda $1_{ev}.and(aux|be&PRES(part|do-PROG(pro|you,$0,$1),$1),prep|in(det|the($2,n|corner($2)),$1))
making  and(aux|be&PRES(part|do-PROG(pro|you,$0,$1),$1),prep|in(det|the($2,n|corner($2)),$1))
making  aux|be&PRES(part|do-PROG(pro|you,$0,$1),$1)
making  part|do-PROG(pro|you,$0,$1)
making  pro|you
making  $0
making  $1
making  $1
making  prep|in(det|the($2,n|corner($2)),$1)
making  det|the($2,n|corner($2))
making  n|corner($2)
making  $2
making  $1
sentence is  the man ?
making  lambda $0_{ev}.aux|be&PRES(and(part|go-PROG(pro|you,$0),v|read&ZERO(pro|you,$0)),$0)
making  aux|be&PRES(and(part|go-PROG(pro|you,$0),v|read&ZERO(pro|you,$0)),$0)
making  and(part|go-PROG(pro|you,$0),v|read&ZERO(pro|you,$0))
making  part|go-PROG(pro|you,$0)
making  pro|you
making  $0
making  v|read&ZERO(pro|you,$0)
making  pro|you
making  $0
making  $0
sentence is  the man ?
making  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  eq($0,pro:dem|that,$1)
making  $0,pro:dem|that,$1)
making  pro:dem|that,$1)
making  $1)
sentence is  the man ?

got training pair
Sent : the man ?
Cat : S:lambda $0_{ev}.v|write(pro|you,det|a($1,n|letter($1)),$0)
Cat : Syn:lambda $0_{ev}.Q(det|the($1,n|pencil($1)),$0)
Cat : S:lambda $0_{ev}.eq(pro:dem|that,pro:poss:det|your($1,n|pencil($1)),$0)
Cat : Syn:lambda $0_{ev}.Q(det|the($1,n|man($1)),$0)
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.and(aux|be&PRES(part|do-PROG(pro|you,$0,$1),$1),prep|in(det|the($2,n|corner($2)),$1))
Cat : S:lambda $0_{ev}.aux|be&PRES(and(part|go-PROG(pro|you,$0),v|read&ZERO(pro|you,$0)),$0)
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
sentence is  ['the', 'man']
sem is  lambda $0_{ev}.v|write(pro|you,det|a($1,n|letter($1)),$0)
sem is  lambda $0_{ev}.Q(det|the($1,n|pencil($1)),$0)
sem is  lambda $0_{ev}.eq(pro:dem|that,pro:poss:det|your($1,n|pencil($1)),$0)
sem is  lambda $0_{ev}.Q(det|the($1,n|man($1)),$0)
sem is  lambda $0_{e}.lambda $1_{ev}.and(aux|be&PRES(part|do-PROG(pro|you,$0,$1),$1),prep|in(det|the($2,n|corner($2)),$1))
types dont match 2 :  (Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|in(det|the($2,n|corner($2)),$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|in(det|the($2,n|corner($2)),$1)) (S/NP):lambda $0_{e}.lambda $1_{ev}.aux|be&PRES(part|do-PROG(pro|you,$0,$1),$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|in(det|the($2,n|corner($2)),$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
types dont match 2 :  (Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|in(det|the($2,n|corner($2)),$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|in(det|the($2,n|corner($2)),$1)) (S\NP):lambda $0_{e}.lambda $1_{ev}.aux|be&PRES(part|do-PROG(pro|you,$0,$1),$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|in(det|the($2,n|corner($2)),$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
types dont match 2 :  (Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|in(det|the($2,n|corner($2)),$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|in(det|the($2,n|corner($2)),$1)) (S/NP):lambda $0_{e}.lambda $1_{ev}.aux|be&PRES(part|do-PROG(pro|you,$0,$1),$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|in(det|the($2,n|corner($2)),$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
types dont match 2 :  (Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|in(det|the($2,n|corner($2)),$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|in(det|the($2,n|corner($2)),$1)) (S\NP):lambda $0_{e}.lambda $1_{ev}.aux|be&PRES(part|do-PROG(pro|you,$0,$1),$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|in(det|the($2,n|corner($2)),$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
types dont match 2 :  (Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and(aux|be&PRES($0($1),$1),prep|in(det|the($2,n|corner($2)),$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and(aux|be&PRES($0($1),$1),prep|in(det|the($2,n|corner($2)),$1)) (S/NP):lambda $0_{e}.lambda $1_{ev}.part|do-PROG(pro|you,$0,$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and(aux|be&PRES($0($1),$1),prep|in(det|the($2,n|corner($2)),$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
types dont match 2 :  (Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and(aux|be&PRES($0($1),$1),prep|in(det|the($2,n|corner($2)),$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and(aux|be&PRES($0($1),$1),prep|in(det|the($2,n|corner($2)),$1)) (S\NP):lambda $0_{e}.lambda $1_{ev}.part|do-PROG(pro|you,$0,$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and(aux|be&PRES($0($1),$1),prep|in(det|the($2,n|corner($2)),$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
sem is  lambda $0_{ev}.aux|be&PRES(and(part|go-PROG(pro|you,$0),v|read&ZERO(pro|you,$0)),$0)
sem is  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
size of chart is  115
got chart
norm score is  -10.2026342659
doing updates with learning rate  0.0226191415778
Deleting 0 entries of the total 2587
done io
WATCH	the man ?
WATCH	64	((S\NP)\NP)	0.730512491611
WATCH	64	((S\NP)/NP)	0.00179339479899
WATCH	64	((S/NP)/NP)	0.267371864974
WATCH	64	((S/NP)\NP)	0.00032224861614
getting topparses
outputting cat probs
done with sent


making  lambda $0_{ev}.Q(det|the($1,n|pencil($1)),$0)
making  Q(det|the($1,n|pencil($1)),$0)
making  det|the($1,n|pencil($1)),$0)
making  n|pencil($1)
making  $1
making  $0)
Is Q
sentence is  what are you doing in the corner ?
making  lambda $0_{ev}.eq(pro:dem|that,pro:poss:det|your($1,n|pencil($1)),$0)
making  eq(pro:dem|that,pro:poss:det|your($1,n|pencil($1)),$0)
making  pro:dem|that,pro:poss:det|your($1,n|pencil($1)),$0)
making  pro:poss:det|your($1,n|pencil($1)),$0)
making  n|pencil($1)
making  $1
making  $0)
sentence is  what are you doing in the corner ?
making  lambda $0_{ev}.Q(det|the($1,n|man($1)),$0)
making  Q(det|the($1,n|man($1)),$0)
making  det|the($1,n|man($1)),$0)
making  n|man($1)
making  $1
making  $0)
Is Q
sentence is  what are you doing in the corner ?
making  lambda $0_{e}.lambda $1_{ev}.and(aux|be&PRES(part|do-PROG(pro|you,$0,$1),$1),prep|in(det|the($2,n|corner($2)),$1))
making  lambda $1_{ev}.and(aux|be&PRES(part|do-PROG(pro|you,$0,$1),$1),prep|in(det|the($2,n|corner($2)),$1))
making  and(aux|be&PRES(part|do-PROG(pro|you,$0,$1),$1),prep|in(det|the($2,n|corner($2)),$1))
making  aux|be&PRES(part|do-PROG(pro|you,$0,$1),$1)
making  part|do-PROG(pro|you,$0,$1)
making  pro|you
making  $0
making  $1
making  $1
making  prep|in(det|the($2,n|corner($2)),$1)
making  det|the($2,n|corner($2))
making  n|corner($2)
making  $2
making  $1
sentence is  what are you doing in the corner ?
making  lambda $0_{ev}.aux|be&PRES(and(part|go-PROG(pro|you,$0),v|read&ZERO(pro|you,$0)),$0)
making  aux|be&PRES(and(part|go-PROG(pro|you,$0),v|read&ZERO(pro|you,$0)),$0)
making  and(part|go-PROG(pro|you,$0),v|read&ZERO(pro|you,$0))
making  part|go-PROG(pro|you,$0)
making  pro|you
making  $0
making  v|read&ZERO(pro|you,$0)
making  pro|you
making  $0
making  $0
sentence is  what are you doing in the corner ?
making  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  eq($0,pro:dem|that,$1)
making  $0,pro:dem|that,$1)
making  pro:dem|that,$1)
making  $1)
sentence is  what are you doing in the corner ?
making  lambda $0_{e}.n|shoe($0)
making  n|shoe($0)
making  $0
sentence is  what are you doing in the corner ?

got training pair
Sent : what are you doing in the corner ?
Cat : Syn:lambda $0_{ev}.Q(det|the($1,n|pencil($1)),$0)
Cat : S:lambda $0_{ev}.eq(pro:dem|that,pro:poss:det|your($1,n|pencil($1)),$0)
Cat : Syn:lambda $0_{ev}.Q(det|the($1,n|man($1)),$0)
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.and(aux|be&PRES(part|do-PROG(pro|you,$0,$1),$1),prep|in(det|the($2,n|corner($2)),$1))
Cat : S:lambda $0_{ev}.aux|be&PRES(and(part|go-PROG(pro|you,$0),v|read&ZERO(pro|you,$0)),$0)
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
Cat : Swh:lambda $0_{e}.n|shoe($0)
sentence is  ['what', 'are', 'you', 'doing', 'in', 'the', 'corner']
sem is  lambda $0_{ev}.Q(det|the($1,n|pencil($1)),$0)
sem is  lambda $0_{ev}.eq(pro:dem|that,pro:poss:det|your($1,n|pencil($1)),$0)
sem is  lambda $0_{ev}.Q(det|the($1,n|man($1)),$0)
sem is  lambda $0_{e}.lambda $1_{ev}.and(aux|be&PRES(part|do-PROG(pro|you,$0,$1),$1),prep|in(det|the($2,n|corner($2)),$1))
types dont match 2 :  (Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|in(det|the($2,n|corner($2)),$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|in(det|the($2,n|corner($2)),$1)) (S/NP):lambda $0_{e}.lambda $1_{ev}.aux|be&PRES(part|do-PROG(pro|you,$0,$1),$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|in(det|the($2,n|corner($2)),$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
types dont match 2 :  (Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|in(det|the($2,n|corner($2)),$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|in(det|the($2,n|corner($2)),$1)) (S\NP):lambda $0_{e}.lambda $1_{ev}.aux|be&PRES(part|do-PROG(pro|you,$0,$1),$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|in(det|the($2,n|corner($2)),$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
types dont match 2 :  (Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|in(det|the($2,n|corner($2)),$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|in(det|the($2,n|corner($2)),$1)) (S/NP):lambda $0_{e}.lambda $1_{ev}.aux|be&PRES(part|do-PROG(pro|you,$0,$1),$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|in(det|the($2,n|corner($2)),$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
types dont match 2 :  (Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|in(det|the($2,n|corner($2)),$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|in(det|the($2,n|corner($2)),$1)) (S\NP):lambda $0_{e}.lambda $1_{ev}.aux|be&PRES(part|do-PROG(pro|you,$0,$1),$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|in(det|the($2,n|corner($2)),$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
types dont match 2 :  (Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and(aux|be&PRES($0($1),$1),prep|in(det|the($2,n|corner($2)),$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and(aux|be&PRES($0($1),$1),prep|in(det|the($2,n|corner($2)),$1)) (S/NP):lambda $0_{e}.lambda $1_{ev}.part|do-PROG(pro|you,$0,$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and(aux|be&PRES($0($1),$1),prep|in(det|the($2,n|corner($2)),$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
types dont match 2 :  (Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and(aux|be&PRES($0($1),$1),prep|in(det|the($2,n|corner($2)),$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and(aux|be&PRES($0($1),$1),prep|in(det|the($2,n|corner($2)),$1)) (S\NP):lambda $0_{e}.lambda $1_{ev}.part|do-PROG(pro|you,$0,$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and(aux|be&PRES($0($1),$1),prep|in(det|the($2,n|corner($2)),$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
sem is  lambda $0_{ev}.aux|be&PRES(and(part|go-PROG(pro|you,$0),v|read&ZERO(pro|you,$0)),$0)
sem is  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
sem is  lambda $0_{e}.n|shoe($0)
size of chart is  16749
got chart
norm score is  -55.933872616
doing updates with learning rate  0.0224616537229
Deleting 0 entries of the total 7080
done io
WATCH	what are you doing in the corner ?
WATCH	65	((S\NP)\NP)	0.717338395762
WATCH	65	((S\NP)/NP)	0.00178767651881
WATCH	65	((S/NP)/NP)	0.280542529473
WATCH	65	((S/NP)\NP)	0.000331398245864
getting topparses
outputting cat probs
done with sent


making  lambda $0_{ev}.eq(pro:dem|that,pro:poss:det|your($1,n|pencil($1)),$0)
making  eq(pro:dem|that,pro:poss:det|your($1,n|pencil($1)),$0)
making  pro:dem|that,pro:poss:det|your($1,n|pencil($1)),$0)
making  pro:poss:det|your($1,n|pencil($1)),$0)
making  n|pencil($1)
making  $1
making  $0)
sentence is  you 're going to read .
making  lambda $0_{ev}.Q(det|the($1,n|man($1)),$0)
making  Q(det|the($1,n|man($1)),$0)
making  det|the($1,n|man($1)),$0)
making  n|man($1)
making  $1
making  $0)
Is Q
sentence is  you 're going to read .
making  lambda $0_{e}.lambda $1_{ev}.and(aux|be&PRES(part|do-PROG(pro|you,$0,$1),$1),prep|in(det|the($2,n|corner($2)),$1))
making  lambda $1_{ev}.and(aux|be&PRES(part|do-PROG(pro|you,$0,$1),$1),prep|in(det|the($2,n|corner($2)),$1))
making  and(aux|be&PRES(part|do-PROG(pro|you,$0,$1),$1),prep|in(det|the($2,n|corner($2)),$1))
making  aux|be&PRES(part|do-PROG(pro|you,$0,$1),$1)
making  part|do-PROG(pro|you,$0,$1)
making  pro|you
making  $0
making  $1
making  $1
making  prep|in(det|the($2,n|corner($2)),$1)
making  det|the($2,n|corner($2))
making  n|corner($2)
making  $2
making  $1
sentence is  you 're going to read .
making  lambda $0_{ev}.aux|be&PRES(and(part|go-PROG(pro|you,$0),v|read&ZERO(pro|you,$0)),$0)
making  aux|be&PRES(and(part|go-PROG(pro|you,$0),v|read&ZERO(pro|you,$0)),$0)
making  and(part|go-PROG(pro|you,$0),v|read&ZERO(pro|you,$0))
making  part|go-PROG(pro|you,$0)
making  pro|you
making  $0
making  v|read&ZERO(pro|you,$0)
making  pro|you
making  $0
making  $0
sentence is  you 're going to read .
making  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  eq($0,pro:dem|that,$1)
making  $0,pro:dem|that,$1)
making  pro:dem|that,$1)
making  $1)
sentence is  you 're going to read .
making  lambda $0_{e}.n|shoe($0)
making  n|shoe($0)
making  $0
sentence is  you 're going to read .
making  lambda $0_{ev}.eq(pro:dem|that,n:prop|Racketyboom,$0)
making  eq(pro:dem|that,n:prop|Racketyboom,$0)
making  pro:dem|that,n:prop|Racketyboom,$0)
making  n:prop|Racketyboom,$0)
making  $0)
sentence is  you 're going to read .

got training pair
Sent : you 're going to read .
Cat : S:lambda $0_{ev}.eq(pro:dem|that,pro:poss:det|your($1,n|pencil($1)),$0)
Cat : Syn:lambda $0_{ev}.Q(det|the($1,n|man($1)),$0)
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.and(aux|be&PRES(part|do-PROG(pro|you,$0,$1),$1),prep|in(det|the($2,n|corner($2)),$1))
Cat : S:lambda $0_{ev}.aux|be&PRES(and(part|go-PROG(pro|you,$0),v|read&ZERO(pro|you,$0)),$0)
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
Cat : Swh:lambda $0_{e}.n|shoe($0)
Cat : S:lambda $0_{ev}.eq(pro:dem|that,n:prop|Racketyboom,$0)
sentence is  ['you', "'re", 'going', 'to', 'read']
sem is  lambda $0_{ev}.eq(pro:dem|that,pro:poss:det|your($1,n|pencil($1)),$0)
sem is  lambda $0_{ev}.Q(det|the($1,n|man($1)),$0)
sem is  lambda $0_{e}.lambda $1_{ev}.and(aux|be&PRES(part|do-PROG(pro|you,$0,$1),$1),prep|in(det|the($2,n|corner($2)),$1))
types dont match 2 :  (Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|in(det|the($2,n|corner($2)),$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|in(det|the($2,n|corner($2)),$1)) (S/NP):lambda $0_{e}.lambda $1_{ev}.aux|be&PRES(part|do-PROG(pro|you,$0,$1),$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|in(det|the($2,n|corner($2)),$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
types dont match 2 :  (Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|in(det|the($2,n|corner($2)),$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|in(det|the($2,n|corner($2)),$1)) (S\NP):lambda $0_{e}.lambda $1_{ev}.aux|be&PRES(part|do-PROG(pro|you,$0,$1),$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|in(det|the($2,n|corner($2)),$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
types dont match 2 :  (Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|in(det|the($2,n|corner($2)),$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|in(det|the($2,n|corner($2)),$1)) (S/NP):lambda $0_{e}.lambda $1_{ev}.aux|be&PRES(part|do-PROG(pro|you,$0,$1),$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|in(det|the($2,n|corner($2)),$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
types dont match 2 :  (Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|in(det|the($2,n|corner($2)),$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|in(det|the($2,n|corner($2)),$1)) (S\NP):lambda $0_{e}.lambda $1_{ev}.aux|be&PRES(part|do-PROG(pro|you,$0,$1),$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|in(det|the($2,n|corner($2)),$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
types dont match 2 :  (Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and(aux|be&PRES($0($1),$1),prep|in(det|the($2,n|corner($2)),$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and(aux|be&PRES($0($1),$1),prep|in(det|the($2,n|corner($2)),$1)) (S/NP):lambda $0_{e}.lambda $1_{ev}.part|do-PROG(pro|you,$0,$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and(aux|be&PRES($0($1),$1),prep|in(det|the($2,n|corner($2)),$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
types dont match 2 :  (Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and(aux|be&PRES($0($1),$1),prep|in(det|the($2,n|corner($2)),$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and(aux|be&PRES($0($1),$1),prep|in(det|the($2,n|corner($2)),$1)) (S\NP):lambda $0_{e}.lambda $1_{ev}.part|do-PROG(pro|you,$0,$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and(aux|be&PRES($0($1),$1),prep|in(det|the($2,n|corner($2)),$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
sem is  lambda $0_{ev}.aux|be&PRES(and(part|go-PROG(pro|you,$0),v|read&ZERO(pro|you,$0)),$0)
sem is  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
sem is  lambda $0_{e}.n|shoe($0)
sem is  lambda $0_{ev}.eq(pro:dem|that,n:prop|Racketyboom,$0)
size of chart is  5489
got chart
norm score is  -35.9948163939
doing updates with learning rate  0.0223066117621
Deleting 0 entries of the total 8879
done io
WATCH	you 're going to read .
WATCH	66	((S\NP)\NP)	0.711286799065
WATCH	66	((S\NP)/NP)	0.00176222329415
WATCH	66	((S/NP)/NP)	0.28661771318
WATCH	66	((S/NP)\NP)	0.000333264461086
getting topparses
outputting cat probs
done with sent


making  lambda $0_{ev}.Q(det|the($1,n|man($1)),$0)
making  Q(det|the($1,n|man($1)),$0)
making  det|the($1,n|man($1)),$0)
making  n|man($1)
making  $1
making  $0)
Is Q
sentence is  what is that ?
making  lambda $0_{e}.lambda $1_{ev}.and(aux|be&PRES(part|do-PROG(pro|you,$0,$1),$1),prep|in(det|the($2,n|corner($2)),$1))
making  lambda $1_{ev}.and(aux|be&PRES(part|do-PROG(pro|you,$0,$1),$1),prep|in(det|the($2,n|corner($2)),$1))
making  and(aux|be&PRES(part|do-PROG(pro|you,$0,$1),$1),prep|in(det|the($2,n|corner($2)),$1))
making  aux|be&PRES(part|do-PROG(pro|you,$0,$1),$1)
making  part|do-PROG(pro|you,$0,$1)
making  pro|you
making  $0
making  $1
making  $1
making  prep|in(det|the($2,n|corner($2)),$1)
making  det|the($2,n|corner($2))
making  n|corner($2)
making  $2
making  $1
sentence is  what is that ?
making  lambda $0_{ev}.aux|be&PRES(and(part|go-PROG(pro|you,$0),v|read&ZERO(pro|you,$0)),$0)
making  aux|be&PRES(and(part|go-PROG(pro|you,$0),v|read&ZERO(pro|you,$0)),$0)
making  and(part|go-PROG(pro|you,$0),v|read&ZERO(pro|you,$0))
making  part|go-PROG(pro|you,$0)
making  pro|you
making  $0
making  v|read&ZERO(pro|you,$0)
making  pro|you
making  $0
making  $0
sentence is  what is that ?
making  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  eq($0,pro:dem|that,$1)
making  $0,pro:dem|that,$1)
making  pro:dem|that,$1)
making  $1)
sentence is  what is that ?
making  lambda $0_{e}.n|shoe($0)
making  n|shoe($0)
making  $0
sentence is  what is that ?
making  lambda $0_{ev}.eq(pro:dem|that,n:prop|Racketyboom,$0)
making  eq(pro:dem|that,n:prop|Racketyboom,$0)
making  pro:dem|that,n:prop|Racketyboom,$0)
making  n:prop|Racketyboom,$0)
making  $0)
sentence is  what is that ?
making  lambda $0_{ev}.eq(pro:dem|that,n:prop|Racketyboom,$0)
making  eq(pro:dem|that,n:prop|Racketyboom,$0)
making  pro:dem|that,n:prop|Racketyboom,$0)
making  n:prop|Racketyboom,$0)
making  $0)
sentence is  what is that ?

got training pair
Sent : what is that ?
Cat : Syn:lambda $0_{ev}.Q(det|the($1,n|man($1)),$0)
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.and(aux|be&PRES(part|do-PROG(pro|you,$0,$1),$1),prep|in(det|the($2,n|corner($2)),$1))
Cat : S:lambda $0_{ev}.aux|be&PRES(and(part|go-PROG(pro|you,$0),v|read&ZERO(pro|you,$0)),$0)
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
Cat : Swh:lambda $0_{e}.n|shoe($0)
Cat : S:lambda $0_{ev}.eq(pro:dem|that,n:prop|Racketyboom,$0)
Cat : S:lambda $0_{ev}.eq(pro:dem|that,n:prop|Racketyboom,$0)
sentence is  ['what', 'is', 'that']
sem is  lambda $0_{ev}.Q(det|the($1,n|man($1)),$0)
sem is  lambda $0_{e}.lambda $1_{ev}.and(aux|be&PRES(part|do-PROG(pro|you,$0,$1),$1),prep|in(det|the($2,n|corner($2)),$1))
types dont match 2 :  (Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|in(det|the($2,n|corner($2)),$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|in(det|the($2,n|corner($2)),$1)) (S/NP):lambda $0_{e}.lambda $1_{ev}.aux|be&PRES(part|do-PROG(pro|you,$0,$1),$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|in(det|the($2,n|corner($2)),$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
types dont match 2 :  (Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|in(det|the($2,n|corner($2)),$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|in(det|the($2,n|corner($2)),$1)) (S\NP):lambda $0_{e}.lambda $1_{ev}.aux|be&PRES(part|do-PROG(pro|you,$0,$1),$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|in(det|the($2,n|corner($2)),$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
types dont match 2 :  (Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|in(det|the($2,n|corner($2)),$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|in(det|the($2,n|corner($2)),$1)) (S/NP):lambda $0_{e}.lambda $1_{ev}.aux|be&PRES(part|do-PROG(pro|you,$0,$1),$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|in(det|the($2,n|corner($2)),$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
types dont match 2 :  (Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|in(det|the($2,n|corner($2)),$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|in(det|the($2,n|corner($2)),$1)) (S\NP):lambda $0_{e}.lambda $1_{ev}.aux|be&PRES(part|do-PROG(pro|you,$0,$1),$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|in(det|the($2,n|corner($2)),$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
types dont match 2 :  (Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and(aux|be&PRES($0($1),$1),prep|in(det|the($2,n|corner($2)),$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and(aux|be&PRES($0($1),$1),prep|in(det|the($2,n|corner($2)),$1)) (S/NP):lambda $0_{e}.lambda $1_{ev}.part|do-PROG(pro|you,$0,$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and(aux|be&PRES($0($1),$1),prep|in(det|the($2,n|corner($2)),$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
types dont match 2 :  (Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and(aux|be&PRES($0($1),$1),prep|in(det|the($2,n|corner($2)),$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and(aux|be&PRES($0($1),$1),prep|in(det|the($2,n|corner($2)),$1)) (S\NP):lambda $0_{e}.lambda $1_{ev}.part|do-PROG(pro|you,$0,$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and(aux|be&PRES($0($1),$1),prep|in(det|the($2,n|corner($2)),$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
sem is  lambda $0_{ev}.aux|be&PRES(and(part|go-PROG(pro|you,$0),v|read&ZERO(pro|you,$0)),$0)
sem is  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
sem is  lambda $0_{e}.n|shoe($0)
sem is  lambda $0_{ev}.eq(pro:dem|that,n:prop|Racketyboom,$0)
sem is  lambda $0_{ev}.eq(pro:dem|that,n:prop|Racketyboom,$0)
size of chart is  545
got chart
norm score is  -21.5638040087
doing updates with learning rate  0.022153957111
Deleting 0 entries of the total 9040
done io
WATCH	what is that ?
WATCH	67	((S\NP)\NP)	0.713208209371
WATCH	67	((S\NP)/NP)	0.00175582603596
WATCH	67	((S/NP)/NP)	0.28471049464
WATCH	67	((S/NP)\NP)	0.000325469952538
getting topparses
outputting cat probs
done with sent


making  lambda $0_{e}.lambda $1_{ev}.and(aux|be&PRES(part|do-PROG(pro|you,$0,$1),$1),prep|in(det|the($2,n|corner($2)),$1))
making  lambda $1_{ev}.and(aux|be&PRES(part|do-PROG(pro|you,$0,$1),$1),prep|in(det|the($2,n|corner($2)),$1))
making  and(aux|be&PRES(part|do-PROG(pro|you,$0,$1),$1),prep|in(det|the($2,n|corner($2)),$1))
making  aux|be&PRES(part|do-PROG(pro|you,$0,$1),$1)
making  part|do-PROG(pro|you,$0,$1)
making  pro|you
making  $0
making  $1
making  $1
making  prep|in(det|the($2,n|corner($2)),$1)
making  det|the($2,n|corner($2))
making  n|corner($2)
making  $2
making  $1
sentence is  shoe .
making  lambda $0_{ev}.aux|be&PRES(and(part|go-PROG(pro|you,$0),v|read&ZERO(pro|you,$0)),$0)
making  aux|be&PRES(and(part|go-PROG(pro|you,$0),v|read&ZERO(pro|you,$0)),$0)
making  and(part|go-PROG(pro|you,$0),v|read&ZERO(pro|you,$0))
making  part|go-PROG(pro|you,$0)
making  pro|you
making  $0
making  v|read&ZERO(pro|you,$0)
making  pro|you
making  $0
making  $0
sentence is  shoe .
making  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  eq($0,pro:dem|that,$1)
making  $0,pro:dem|that,$1)
making  pro:dem|that,$1)
making  $1)
sentence is  shoe .
making  lambda $0_{e}.n|shoe($0)
making  n|shoe($0)
making  $0
sentence is  shoe .
making  lambda $0_{ev}.eq(pro:dem|that,n:prop|Racketyboom,$0)
making  eq(pro:dem|that,n:prop|Racketyboom,$0)
making  pro:dem|that,n:prop|Racketyboom,$0)
making  n:prop|Racketyboom,$0)
making  $0)
sentence is  shoe .
making  lambda $0_{ev}.eq(pro:dem|that,n:prop|Racketyboom,$0)
making  eq(pro:dem|that,n:prop|Racketyboom,$0)
making  pro:dem|that,n:prop|Racketyboom,$0)
making  n:prop|Racketyboom,$0)
making  $0)
sentence is  shoe .
making  lambda $0_{ev}.v|read&ZERO(n:prop|Eve,lambda $1_{e}.n|book($1),$0)
making  v|read&ZERO(n:prop|Eve,lambda $1_{e}.n|book($1),$0)
making  n:prop|Eve
making  lambda $1_{e}.n|book($1)
making  n|book($1)
making  $1
making  $0
sentence is  shoe .

got training pair
Sent : shoe .
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.and(aux|be&PRES(part|do-PROG(pro|you,$0,$1),$1),prep|in(det|the($2,n|corner($2)),$1))
Cat : S:lambda $0_{ev}.aux|be&PRES(and(part|go-PROG(pro|you,$0),v|read&ZERO(pro|you,$0)),$0)
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
Cat : Swh:lambda $0_{e}.n|shoe($0)
Cat : S:lambda $0_{ev}.eq(pro:dem|that,n:prop|Racketyboom,$0)
Cat : S:lambda $0_{ev}.eq(pro:dem|that,n:prop|Racketyboom,$0)
Cat : S:lambda $0_{ev}.v|read&ZERO(n:prop|Eve,lambda $1_{e}.n|book($1),$0)
sentence is  ['shoe']
sem is  lambda $0_{e}.lambda $1_{ev}.and(aux|be&PRES(part|do-PROG(pro|you,$0,$1),$1),prep|in(det|the($2,n|corner($2)),$1))
sem is  lambda $0_{ev}.aux|be&PRES(and(part|go-PROG(pro|you,$0),v|read&ZERO(pro|you,$0)),$0)
sem is  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
sem is  lambda $0_{e}.n|shoe($0)
sem is  lambda $0_{ev}.eq(pro:dem|that,n:prop|Racketyboom,$0)
sem is  lambda $0_{ev}.eq(pro:dem|that,n:prop|Racketyboom,$0)
sem is  lambda $0_{ev}.v|read&ZERO(n:prop|Eve,lambda $1_{e}.n|book($1),$0)
size of chart is  6
got chart
norm score is  -7.45797093795
doing updates with learning rate  0.0220036330731
Deleting 0 entries of the total 9046
done io
WATCH	shoe .
WATCH	68	((S\NP)\NP)	0.713224492756
WATCH	68	((S\NP)/NP)	0.00174536931784
WATCH	68	((S/NP)/NP)	0.284709968305
WATCH	68	((S/NP)\NP)	0.000320169621695
getting topparses
outputting cat probs
done with sent


making  lambda $0_{ev}.aux|be&PRES(and(part|go-PROG(pro|you,$0),v|read&ZERO(pro|you,$0)),$0)
making  aux|be&PRES(and(part|go-PROG(pro|you,$0),v|read&ZERO(pro|you,$0)),$0)
making  and(part|go-PROG(pro|you,$0),v|read&ZERO(pro|you,$0))
making  part|go-PROG(pro|you,$0)
making  pro|you
making  $0
making  v|read&ZERO(pro|you,$0)
making  pro|you
making  $0
making  $0
sentence is  that 's Racketyboom .
making  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  eq($0,pro:dem|that,$1)
making  $0,pro:dem|that,$1)
making  pro:dem|that,$1)
making  $1)
sentence is  that 's Racketyboom .
making  lambda $0_{e}.n|shoe($0)
making  n|shoe($0)
making  $0
sentence is  that 's Racketyboom .
making  lambda $0_{ev}.eq(pro:dem|that,n:prop|Racketyboom,$0)
making  eq(pro:dem|that,n:prop|Racketyboom,$0)
making  pro:dem|that,n:prop|Racketyboom,$0)
making  n:prop|Racketyboom,$0)
making  $0)
sentence is  that 's Racketyboom .
making  lambda $0_{ev}.eq(pro:dem|that,n:prop|Racketyboom,$0)
making  eq(pro:dem|that,n:prop|Racketyboom,$0)
making  pro:dem|that,n:prop|Racketyboom,$0)
making  n:prop|Racketyboom,$0)
making  $0)
sentence is  that 's Racketyboom .
making  lambda $0_{ev}.v|read&ZERO(n:prop|Eve,lambda $1_{e}.n|book($1),$0)
making  v|read&ZERO(n:prop|Eve,lambda $1_{e}.n|book($1),$0)
making  n:prop|Eve
making  lambda $1_{e}.n|book($1)
making  n|book($1)
making  $1
making  $0
sentence is  that 's Racketyboom .
making  lambda $0_{ev}.v|read&ZERO(pro|you,det|the($1,n|book($1)),$0)
making  v|read&ZERO(pro|you,det|the($1,n|book($1)),$0)
making  pro|you
making  det|the($1,n|book($1))
making  n|book($1)
making  $1
making  $0
sentence is  that 's Racketyboom .

got training pair
Sent : that 's Racketyboom .
Cat : S:lambda $0_{ev}.aux|be&PRES(and(part|go-PROG(pro|you,$0),v|read&ZERO(pro|you,$0)),$0)
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
Cat : Swh:lambda $0_{e}.n|shoe($0)
Cat : S:lambda $0_{ev}.eq(pro:dem|that,n:prop|Racketyboom,$0)
Cat : S:lambda $0_{ev}.eq(pro:dem|that,n:prop|Racketyboom,$0)
Cat : S:lambda $0_{ev}.v|read&ZERO(n:prop|Eve,lambda $1_{e}.n|book($1),$0)
Cat : S:lambda $0_{ev}.v|read&ZERO(pro|you,det|the($1,n|book($1)),$0)
sentence is  ['that', "'s", 'Racketyboom']
sem is  lambda $0_{ev}.aux|be&PRES(and(part|go-PROG(pro|you,$0),v|read&ZERO(pro|you,$0)),$0)
sem is  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
sem is  lambda $0_{e}.n|shoe($0)
sem is  lambda $0_{ev}.eq(pro:dem|that,n:prop|Racketyboom,$0)
sem is  lambda $0_{ev}.eq(pro:dem|that,n:prop|Racketyboom,$0)
sem is  lambda $0_{ev}.v|read&ZERO(n:prop|Eve,lambda $1_{e}.n|book($1),$0)
sem is  lambda $0_{ev}.v|read&ZERO(pro|you,det|the($1,n|book($1)),$0)
size of chart is  300
got chart
norm score is  -26.4978866921
doing updates with learning rate  0.0218555847641
Deleting 0 entries of the total 9193
done io
WATCH	that 's Racketyboom .
WATCH	69	((S\NP)\NP)	0.717267092956
WATCH	69	((S\NP)/NP)	0.00174276780598
WATCH	69	((S/NP)/NP)	0.280679358123
WATCH	69	((S/NP)\NP)	0.000310781115378
getting topparses
outputting cat probs
done with sent


making  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  eq($0,pro:dem|that,$1)
making  $0,pro:dem|that,$1)
making  pro:dem|that,$1)
making  $1)
sentence is  that 's Racketyboom .
making  lambda $0_{e}.n|shoe($0)
making  n|shoe($0)
making  $0
sentence is  that 's Racketyboom .
making  lambda $0_{ev}.eq(pro:dem|that,n:prop|Racketyboom,$0)
making  eq(pro:dem|that,n:prop|Racketyboom,$0)
making  pro:dem|that,n:prop|Racketyboom,$0)
making  n:prop|Racketyboom,$0)
making  $0)
sentence is  that 's Racketyboom .
making  lambda $0_{ev}.eq(pro:dem|that,n:prop|Racketyboom,$0)
making  eq(pro:dem|that,n:prop|Racketyboom,$0)
making  pro:dem|that,n:prop|Racketyboom,$0)
making  n:prop|Racketyboom,$0)
making  $0)
sentence is  that 's Racketyboom .
making  lambda $0_{ev}.v|read&ZERO(n:prop|Eve,lambda $1_{e}.n|book($1),$0)
making  v|read&ZERO(n:prop|Eve,lambda $1_{e}.n|book($1),$0)
making  n:prop|Eve
making  lambda $1_{e}.n|book($1)
making  n|book($1)
making  $1
making  $0
sentence is  that 's Racketyboom .
making  lambda $0_{ev}.v|read&ZERO(pro|you,det|the($1,n|book($1)),$0)
making  v|read&ZERO(pro|you,det|the($1,n|book($1)),$0)
making  pro|you
making  det|the($1,n|book($1))
making  n|book($1)
making  $1
making  $0
sentence is  that 's Racketyboom .
making  lambda $0_{ev}.not(aux|can(v|read&ZERO(n:prop|Mommy,$0),$0),$0)
making  not(aux|can(v|read&ZERO(n:prop|Mommy,$0),$0),$0)
making  aux|can(v|read&ZERO(n:prop|Mommy,$0),$0),$0)
making  v|read&ZERO(n:prop|Mommy,$0)
making  n:prop|Mommy
making  $0
making  $0
making  $0)
sentence is  that 's Racketyboom .

got training pair
Sent : that 's Racketyboom .
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
Cat : Swh:lambda $0_{e}.n|shoe($0)
Cat : S:lambda $0_{ev}.eq(pro:dem|that,n:prop|Racketyboom,$0)
Cat : S:lambda $0_{ev}.eq(pro:dem|that,n:prop|Racketyboom,$0)
Cat : S:lambda $0_{ev}.v|read&ZERO(n:prop|Eve,lambda $1_{e}.n|book($1),$0)
Cat : S:lambda $0_{ev}.v|read&ZERO(pro|you,det|the($1,n|book($1)),$0)
Cat : S:lambda $0_{ev}.not(aux|can(v|read&ZERO(n:prop|Mommy,$0),$0),$0)
sentence is  ['that', "'s", 'Racketyboom']
sem is  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
sem is  lambda $0_{e}.n|shoe($0)
sem is  lambda $0_{ev}.eq(pro:dem|that,n:prop|Racketyboom,$0)
sem is  lambda $0_{ev}.eq(pro:dem|that,n:prop|Racketyboom,$0)
sem is  lambda $0_{ev}.v|read&ZERO(n:prop|Eve,lambda $1_{e}.n|book($1),$0)
sem is  lambda $0_{ev}.v|read&ZERO(pro|you,det|the($1,n|book($1)),$0)
sem is  lambda $0_{ev}.not(aux|can(v|read&ZERO(n:prop|Mommy,$0),$0),$0)
size of chart is  250
got chart
norm score is  -14.5506341942
doing updates with learning rate  0.0217097590391
Deleting 0 entries of the total 9227
done io
WATCH	that 's Racketyboom .
WATCH	70	((S\NP)\NP)	0.720885248522
WATCH	70	((S\NP)/NP)	0.00174072859001
WATCH	70	((S/NP)/NP)	0.277072356063
WATCH	70	((S/NP)\NP)	0.00030166682532
getting topparses
outputting cat probs
done with sent


making  lambda $0_{e}.n|shoe($0)
making  n|shoe($0)
making  $0
sentence is  Eve read book .
making  lambda $0_{ev}.eq(pro:dem|that,n:prop|Racketyboom,$0)
making  eq(pro:dem|that,n:prop|Racketyboom,$0)
making  pro:dem|that,n:prop|Racketyboom,$0)
making  n:prop|Racketyboom,$0)
making  $0)
sentence is  Eve read book .
making  lambda $0_{ev}.eq(pro:dem|that,n:prop|Racketyboom,$0)
making  eq(pro:dem|that,n:prop|Racketyboom,$0)
making  pro:dem|that,n:prop|Racketyboom,$0)
making  n:prop|Racketyboom,$0)
making  $0)
sentence is  Eve read book .
making  lambda $0_{ev}.v|read&ZERO(n:prop|Eve,lambda $1_{e}.n|book($1),$0)
making  v|read&ZERO(n:prop|Eve,lambda $1_{e}.n|book($1),$0)
making  n:prop|Eve
making  lambda $1_{e}.n|book($1)
making  n|book($1)
making  $1
making  $0
sentence is  Eve read book .
making  lambda $0_{ev}.v|read&ZERO(pro|you,det|the($1,n|book($1)),$0)
making  v|read&ZERO(pro|you,det|the($1,n|book($1)),$0)
making  pro|you
making  det|the($1,n|book($1))
making  n|book($1)
making  $1
making  $0
sentence is  Eve read book .
making  lambda $0_{ev}.not(aux|can(v|read&ZERO(n:prop|Mommy,$0),$0),$0)
making  not(aux|can(v|read&ZERO(n:prop|Mommy,$0),$0),$0)
making  aux|can(v|read&ZERO(n:prop|Mommy,$0),$0),$0)
making  v|read&ZERO(n:prop|Mommy,$0)
making  n:prop|Mommy
making  $0
making  $0
making  $0)
sentence is  Eve read book .
making  adj|busy(n:prop|Mommy)
making  n:prop|Mommy
sentence is  Eve read book .

got training pair
Sent : Eve read book .
Cat : Swh:lambda $0_{e}.n|shoe($0)
Cat : S:lambda $0_{ev}.eq(pro:dem|that,n:prop|Racketyboom,$0)
Cat : S:lambda $0_{ev}.eq(pro:dem|that,n:prop|Racketyboom,$0)
Cat : S:lambda $0_{ev}.v|read&ZERO(n:prop|Eve,lambda $1_{e}.n|book($1),$0)
Cat : S:lambda $0_{ev}.v|read&ZERO(pro|you,det|the($1,n|book($1)),$0)
Cat : S:lambda $0_{ev}.not(aux|can(v|read&ZERO(n:prop|Mommy,$0),$0),$0)
Cat : St:adj|busy(n:prop|Mommy)
sentence is  ['Eve', 'read', 'book']
sem is  lambda $0_{e}.n|shoe($0)
sem is  lambda $0_{ev}.eq(pro:dem|that,n:prop|Racketyboom,$0)
sem is  lambda $0_{ev}.eq(pro:dem|that,n:prop|Racketyboom,$0)
sem is  lambda $0_{ev}.v|read&ZERO(n:prop|Eve,lambda $1_{e}.n|book($1),$0)
sem is  lambda $0_{ev}.v|read&ZERO(pro|you,det|the($1,n|book($1)),$0)
sem is  lambda $0_{ev}.not(aux|can(v|read&ZERO(n:prop|Mommy,$0),$0),$0)
sem is  adj|busy(n:prop|Mommy)
size of chart is  235
got chart
norm score is  -25.9307015195
doing updates with learning rate  0.0215661044238
Deleting 7956 entries of the total 9413
done io
WATCH	Eve read book .
WATCH	71	((S\NP)\NP)	0.72096191764
WATCH	71	((S\NP)/NP)	0.00172948420654
WATCH	71	((S/NP)/NP)	0.277012307027
WATCH	71	((S/NP)\NP)	0.000296291125766
getting topparses
outputting cat probs
done with sent


making  lambda $0_{ev}.eq(pro:dem|that,n:prop|Racketyboom,$0)
making  eq(pro:dem|that,n:prop|Racketyboom,$0)
making  pro:dem|that,n:prop|Racketyboom,$0)
making  n:prop|Racketyboom,$0)
making  $0)
sentence is  you read the book .
making  lambda $0_{ev}.eq(pro:dem|that,n:prop|Racketyboom,$0)
making  eq(pro:dem|that,n:prop|Racketyboom,$0)
making  pro:dem|that,n:prop|Racketyboom,$0)
making  n:prop|Racketyboom,$0)
making  $0)
sentence is  you read the book .
making  lambda $0_{ev}.v|read&ZERO(n:prop|Eve,lambda $1_{e}.n|book($1),$0)
making  v|read&ZERO(n:prop|Eve,lambda $1_{e}.n|book($1),$0)
making  n:prop|Eve
making  lambda $1_{e}.n|book($1)
making  n|book($1)
making  $1
making  $0
sentence is  you read the book .
making  lambda $0_{ev}.v|read&ZERO(pro|you,det|the($1,n|book($1)),$0)
making  v|read&ZERO(pro|you,det|the($1,n|book($1)),$0)
making  pro|you
making  det|the($1,n|book($1))
making  n|book($1)
making  $1
making  $0
sentence is  you read the book .
making  lambda $0_{ev}.not(aux|can(v|read&ZERO(n:prop|Mommy,$0),$0),$0)
making  not(aux|can(v|read&ZERO(n:prop|Mommy,$0),$0),$0)
making  aux|can(v|read&ZERO(n:prop|Mommy,$0),$0),$0)
making  v|read&ZERO(n:prop|Mommy,$0)
making  n:prop|Mommy
making  $0
making  $0
making  $0)
sentence is  you read the book .
making  adj|busy(n:prop|Mommy)
making  n:prop|Mommy
sentence is  you read the book .
making  lambda $0_{ev}.v|read&ZERO(n:prop|Eve,$0)
making  v|read&ZERO(n:prop|Eve,$0)
making  n:prop|Eve
making  $0
sentence is  you read the book .

got training pair
Sent : you read the book .
Cat : S:lambda $0_{ev}.eq(pro:dem|that,n:prop|Racketyboom,$0)
Cat : S:lambda $0_{ev}.eq(pro:dem|that,n:prop|Racketyboom,$0)
Cat : S:lambda $0_{ev}.v|read&ZERO(n:prop|Eve,lambda $1_{e}.n|book($1),$0)
Cat : S:lambda $0_{ev}.v|read&ZERO(pro|you,det|the($1,n|book($1)),$0)
Cat : S:lambda $0_{ev}.not(aux|can(v|read&ZERO(n:prop|Mommy,$0),$0),$0)
Cat : St:adj|busy(n:prop|Mommy)
Cat : S:lambda $0_{ev}.v|read&ZERO(n:prop|Eve,$0)
sentence is  ['you', 'read', 'the', 'book']
sem is  lambda $0_{ev}.eq(pro:dem|that,n:prop|Racketyboom,$0)
sem is  lambda $0_{ev}.eq(pro:dem|that,n:prop|Racketyboom,$0)
sem is  lambda $0_{ev}.v|read&ZERO(n:prop|Eve,lambda $1_{e}.n|book($1),$0)
sem is  lambda $0_{ev}.v|read&ZERO(pro|you,det|the($1,n|book($1)),$0)
sem is  lambda $0_{ev}.not(aux|can(v|read&ZERO(n:prop|Mommy,$0),$0),$0)
sem is  adj|busy(n:prop|Mommy)
sem is  lambda $0_{ev}.v|read&ZERO(n:prop|Eve,$0)
size of chart is  567
got chart
norm score is  -32.542256748
doing updates with learning rate  0.0214245710482
Deleting 0 entries of the total 1887
done io
WATCH	you read the book .
WATCH	72	((S\NP)\NP)	0.724134029772
WATCH	72	((S\NP)/NP)	0.00172206337901
WATCH	72	((S/NP)/NP)	0.273856264353
WATCH	72	((S/NP)\NP)	0.000287642496893
getting topparses
outputting cat probs
done with sent


making  lambda $0_{ev}.eq(pro:dem|that,n:prop|Racketyboom,$0)
making  eq(pro:dem|that,n:prop|Racketyboom,$0)
making  pro:dem|that,n:prop|Racketyboom,$0)
making  n:prop|Racketyboom,$0)
making  $0)
sentence is  Mommy can 't read .
making  lambda $0_{ev}.v|read&ZERO(n:prop|Eve,lambda $1_{e}.n|book($1),$0)
making  v|read&ZERO(n:prop|Eve,lambda $1_{e}.n|book($1),$0)
making  n:prop|Eve
making  lambda $1_{e}.n|book($1)
making  n|book($1)
making  $1
making  $0
sentence is  Mommy can 't read .
making  lambda $0_{ev}.v|read&ZERO(pro|you,det|the($1,n|book($1)),$0)
making  v|read&ZERO(pro|you,det|the($1,n|book($1)),$0)
making  pro|you
making  det|the($1,n|book($1))
making  n|book($1)
making  $1
making  $0
sentence is  Mommy can 't read .
making  lambda $0_{ev}.not(aux|can(v|read&ZERO(n:prop|Mommy,$0),$0),$0)
making  not(aux|can(v|read&ZERO(n:prop|Mommy,$0),$0),$0)
making  aux|can(v|read&ZERO(n:prop|Mommy,$0),$0),$0)
making  v|read&ZERO(n:prop|Mommy,$0)
making  n:prop|Mommy
making  $0
making  $0
making  $0)
sentence is  Mommy can 't read .
making  adj|busy(n:prop|Mommy)
making  n:prop|Mommy
sentence is  Mommy can 't read .
making  lambda $0_{ev}.v|read&ZERO(n:prop|Eve,$0)
making  v|read&ZERO(n:prop|Eve,$0)
making  n:prop|Eve
making  $0
sentence is  Mommy can 't read .
making  lambda $0_{ev}.and(v|read&ZERO(pro|you,$0),prep|about(det|the($1,n|+on|choo+on|choo($1)),$0))
making  and(v|read&ZERO(pro|you,$0),prep|about(det|the($1,n|+on|choo+on|choo($1)),$0))
making  v|read&ZERO(pro|you,$0)
making  pro|you
making  $0
making  prep|about(det|the($1,n|+on|choo+on|choo($1)),$0)
making  det|the($1,n|+on|choo+on|choo($1))
making  n|+on|choo+on|choo($1)
making  $1
making  $0
sentence is  Mommy can 't read .

got training pair
Sent : Mommy can 't read .
Cat : S:lambda $0_{ev}.eq(pro:dem|that,n:prop|Racketyboom,$0)
Cat : S:lambda $0_{ev}.v|read&ZERO(n:prop|Eve,lambda $1_{e}.n|book($1),$0)
Cat : S:lambda $0_{ev}.v|read&ZERO(pro|you,det|the($1,n|book($1)),$0)
Cat : S:lambda $0_{ev}.not(aux|can(v|read&ZERO(n:prop|Mommy,$0),$0),$0)
Cat : St:adj|busy(n:prop|Mommy)
Cat : S:lambda $0_{ev}.v|read&ZERO(n:prop|Eve,$0)
Cat : S:lambda $0_{ev}.and(v|read&ZERO(pro|you,$0),prep|about(det|the($1,n|+on|choo+on|choo($1)),$0))
sentence is  ['Mommy', 'can', "'t", 'read']
sem is  lambda $0_{ev}.eq(pro:dem|that,n:prop|Racketyboom,$0)
sem is  lambda $0_{ev}.v|read&ZERO(n:prop|Eve,lambda $1_{e}.n|book($1),$0)
sem is  lambda $0_{ev}.v|read&ZERO(pro|you,det|the($1,n|book($1)),$0)
sem is  lambda $0_{ev}.not(aux|can(v|read&ZERO(n:prop|Mommy,$0),$0),$0)
sem is  adj|busy(n:prop|Mommy)
sem is  lambda $0_{ev}.v|read&ZERO(n:prop|Eve,$0)
sem is  lambda $0_{ev}.and(v|read&ZERO(pro|you,$0),prep|about(det|the($1,n|+on|choo+on|choo($1)),$0))
size of chart is  1071
got chart
norm score is  -29.4599461966
doing updates with learning rate  0.0212851105845
Deleting 0 entries of the total 2615
done io
WATCH	Mommy can 't read .
WATCH	73	((S\NP)\NP)	0.663133905796
WATCH	73	((S\NP)/NP)	0.00156936928113
WATCH	73	((S/NP)/NP)	0.335032667298
WATCH	73	((S/NP)\NP)	0.000264057624587
getting topparses
outputting cat probs
done with sent


making  lambda $0_{ev}.v|read&ZERO(n:prop|Eve,lambda $1_{e}.n|book($1),$0)
making  v|read&ZERO(n:prop|Eve,lambda $1_{e}.n|book($1),$0)
making  n:prop|Eve
making  lambda $1_{e}.n|book($1)
making  n|book($1)
making  $1
making  $0
sentence is  Mommy 's busy .
making  lambda $0_{ev}.v|read&ZERO(pro|you,det|the($1,n|book($1)),$0)
making  v|read&ZERO(pro|you,det|the($1,n|book($1)),$0)
making  pro|you
making  det|the($1,n|book($1))
making  n|book($1)
making  $1
making  $0
sentence is  Mommy 's busy .
making  lambda $0_{ev}.not(aux|can(v|read&ZERO(n:prop|Mommy,$0),$0),$0)
making  not(aux|can(v|read&ZERO(n:prop|Mommy,$0),$0),$0)
making  aux|can(v|read&ZERO(n:prop|Mommy,$0),$0),$0)
making  v|read&ZERO(n:prop|Mommy,$0)
making  n:prop|Mommy
making  $0
making  $0
making  $0)
sentence is  Mommy 's busy .
making  adj|busy(n:prop|Mommy)
making  n:prop|Mommy
sentence is  Mommy 's busy .
making  lambda $0_{ev}.v|read&ZERO(n:prop|Eve,$0)
making  v|read&ZERO(n:prop|Eve,$0)
making  n:prop|Eve
making  $0
sentence is  Mommy 's busy .
making  lambda $0_{ev}.and(v|read&ZERO(pro|you,$0),prep|about(det|the($1,n|+on|choo+on|choo($1)),$0))
making  and(v|read&ZERO(pro|you,$0),prep|about(det|the($1,n|+on|choo+on|choo($1)),$0))
making  v|read&ZERO(pro|you,$0)
making  pro|you
making  $0
making  prep|about(det|the($1,n|+on|choo+on|choo($1)),$0)
making  det|the($1,n|+on|choo+on|choo($1))
making  n|+on|choo+on|choo($1)
making  $1
making  $0
sentence is  Mommy 's busy .
making  lambda $0_{ev}.and(aux|will(v|read&ZERO(n:prop|Mommy,$0),$0),adv|later($0))
making  and(aux|will(v|read&ZERO(n:prop|Mommy,$0),$0),adv|later($0))
making  aux|will(v|read&ZERO(n:prop|Mommy,$0),$0)
making  v|read&ZERO(n:prop|Mommy,$0)
making  n:prop|Mommy
making  $0
making  $0
making  adv|later($0)
making  $0
sentence is  Mommy 's busy .

got training pair
Sent : Mommy 's busy .
Cat : S:lambda $0_{ev}.v|read&ZERO(n:prop|Eve,lambda $1_{e}.n|book($1),$0)
Cat : S:lambda $0_{ev}.v|read&ZERO(pro|you,det|the($1,n|book($1)),$0)
Cat : S:lambda $0_{ev}.not(aux|can(v|read&ZERO(n:prop|Mommy,$0),$0),$0)
Cat : St:adj|busy(n:prop|Mommy)
Cat : S:lambda $0_{ev}.v|read&ZERO(n:prop|Eve,$0)
Cat : S:lambda $0_{ev}.and(v|read&ZERO(pro|you,$0),prep|about(det|the($1,n|+on|choo+on|choo($1)),$0))
Cat : S:lambda $0_{ev}.and(aux|will(v|read&ZERO(n:prop|Mommy,$0),$0),adv|later($0))
sentence is  ['Mommy', "'s", 'busy']
sem is  lambda $0_{ev}.v|read&ZERO(n:prop|Eve,lambda $1_{e}.n|book($1),$0)
sem is  lambda $0_{ev}.v|read&ZERO(pro|you,det|the($1,n|book($1)),$0)
sem is  lambda $0_{ev}.not(aux|can(v|read&ZERO(n:prop|Mommy,$0),$0),$0)
sem is  adj|busy(n:prop|Mommy)
sem is  lambda $0_{ev}.v|read&ZERO(n:prop|Eve,$0)
sem is  lambda $0_{ev}.and(v|read&ZERO(pro|you,$0),prep|about(det|the($1,n|+on|choo+on|choo($1)),$0))
sem is  lambda $0_{ev}.and(aux|will(v|read&ZERO(n:prop|Mommy,$0),$0),adv|later($0))
size of chart is  387
got chart
norm score is  -23.6762552098
doing updates with learning rate  0.0211476761869
Deleting 0 entries of the total 2863
done io
WATCH	Mommy 's busy .
WATCH	74	((S\NP)\NP)	0.66431673501
WATCH	74	((S\NP)/NP)	0.00156198508393
WATCH	74	((S/NP)/NP)	0.333863059082
WATCH	74	((S/NP)\NP)	0.000258220823935
getting topparses
outputting cat probs
done with sent


making  lambda $0_{ev}.v|read&ZERO(pro|you,det|the($1,n|book($1)),$0)
making  v|read&ZERO(pro|you,det|the($1,n|book($1)),$0)
making  pro|you
making  det|the($1,n|book($1))
making  n|book($1)
making  $1
making  $0
sentence is  Eve read .
making  lambda $0_{ev}.not(aux|can(v|read&ZERO(n:prop|Mommy,$0),$0),$0)
making  not(aux|can(v|read&ZERO(n:prop|Mommy,$0),$0),$0)
making  aux|can(v|read&ZERO(n:prop|Mommy,$0),$0),$0)
making  v|read&ZERO(n:prop|Mommy,$0)
making  n:prop|Mommy
making  $0
making  $0
making  $0)
sentence is  Eve read .
making  adj|busy(n:prop|Mommy)
making  n:prop|Mommy
sentence is  Eve read .
making  lambda $0_{ev}.v|read&ZERO(n:prop|Eve,$0)
making  v|read&ZERO(n:prop|Eve,$0)
making  n:prop|Eve
making  $0
sentence is  Eve read .
making  lambda $0_{ev}.and(v|read&ZERO(pro|you,$0),prep|about(det|the($1,n|+on|choo+on|choo($1)),$0))
making  and(v|read&ZERO(pro|you,$0),prep|about(det|the($1,n|+on|choo+on|choo($1)),$0))
making  v|read&ZERO(pro|you,$0)
making  pro|you
making  $0
making  prep|about(det|the($1,n|+on|choo+on|choo($1)),$0)
making  det|the($1,n|+on|choo+on|choo($1))
making  n|+on|choo+on|choo($1)
making  $1
making  $0
sentence is  Eve read .
making  lambda $0_{ev}.and(aux|will(v|read&ZERO(n:prop|Mommy,$0),$0),adv|later($0))
making  and(aux|will(v|read&ZERO(n:prop|Mommy,$0),$0),adv|later($0))
making  aux|will(v|read&ZERO(n:prop|Mommy,$0),$0)
making  v|read&ZERO(n:prop|Mommy,$0)
making  n:prop|Mommy
making  $0
making  $0
making  adv|later($0)
making  $0
sentence is  Eve read .
making  lambda $0_{ev}.and(aux|will(v|read&ZERO(pro|I,$0),$0),adv|later($0))
making  and(aux|will(v|read&ZERO(pro|I,$0),$0),adv|later($0))
making  aux|will(v|read&ZERO(pro|I,$0),$0)
making  v|read&ZERO(pro|I,$0)
making  pro|I
making  $0
making  $0
making  adv|later($0)
making  $0
sentence is  Eve read .

got training pair
Sent : Eve read .
Cat : S:lambda $0_{ev}.v|read&ZERO(pro|you,det|the($1,n|book($1)),$0)
Cat : S:lambda $0_{ev}.not(aux|can(v|read&ZERO(n:prop|Mommy,$0),$0),$0)
Cat : St:adj|busy(n:prop|Mommy)
Cat : S:lambda $0_{ev}.v|read&ZERO(n:prop|Eve,$0)
Cat : S:lambda $0_{ev}.and(v|read&ZERO(pro|you,$0),prep|about(det|the($1,n|+on|choo+on|choo($1)),$0))
Cat : S:lambda $0_{ev}.and(aux|will(v|read&ZERO(n:prop|Mommy,$0),$0),adv|later($0))
Cat : S:lambda $0_{ev}.and(aux|will(v|read&ZERO(pro|I,$0),$0),adv|later($0))
sentence is  ['Eve', 'read']
sem is  lambda $0_{ev}.v|read&ZERO(pro|you,det|the($1,n|book($1)),$0)
sem is  lambda $0_{ev}.not(aux|can(v|read&ZERO(n:prop|Mommy,$0),$0),$0)
sem is  adj|busy(n:prop|Mommy)
sem is  lambda $0_{ev}.v|read&ZERO(n:prop|Eve,$0)
sem is  lambda $0_{ev}.and(v|read&ZERO(pro|you,$0),prep|about(det|the($1,n|+on|choo+on|choo($1)),$0))
sem is  lambda $0_{ev}.and(aux|will(v|read&ZERO(n:prop|Mommy,$0),$0),adv|later($0))
sem is  lambda $0_{ev}.and(aux|will(v|read&ZERO(pro|I,$0),$0),adv|later($0))
size of chart is  93
got chart
norm score is  -14.1422302068
doing updates with learning rate  0.0210122224352
Deleting 0 entries of the total 2922
done io
WATCH	Eve read .
WATCH	75	((S\NP)\NP)	0.664374791955
WATCH	75	((S\NP)/NP)	0.00155199909801
WATCH	75	((S/NP)/NP)	0.333819568108
WATCH	75	((S/NP)\NP)	0.000253640839397
getting topparses
outputting cat probs
done with sent


making  lambda $0_{ev}.not(aux|can(v|read&ZERO(n:prop|Mommy,$0),$0),$0)
making  not(aux|can(v|read&ZERO(n:prop|Mommy,$0),$0),$0)
making  aux|can(v|read&ZERO(n:prop|Mommy,$0),$0),$0)
making  v|read&ZERO(n:prop|Mommy,$0)
making  n:prop|Mommy
making  $0
making  $0
making  $0)
sentence is  you read about the choochoo .
making  adj|busy(n:prop|Mommy)
making  n:prop|Mommy
sentence is  you read about the choochoo .
making  lambda $0_{ev}.v|read&ZERO(n:prop|Eve,$0)
making  v|read&ZERO(n:prop|Eve,$0)
making  n:prop|Eve
making  $0
sentence is  you read about the choochoo .
making  lambda $0_{ev}.and(v|read&ZERO(pro|you,$0),prep|about(det|the($1,n|+on|choo+on|choo($1)),$0))
making  and(v|read&ZERO(pro|you,$0),prep|about(det|the($1,n|+on|choo+on|choo($1)),$0))
making  v|read&ZERO(pro|you,$0)
making  pro|you
making  $0
making  prep|about(det|the($1,n|+on|choo+on|choo($1)),$0)
making  det|the($1,n|+on|choo+on|choo($1))
making  n|+on|choo+on|choo($1)
making  $1
making  $0
sentence is  you read about the choochoo .
making  lambda $0_{ev}.and(aux|will(v|read&ZERO(n:prop|Mommy,$0),$0),adv|later($0))
making  and(aux|will(v|read&ZERO(n:prop|Mommy,$0),$0),adv|later($0))
making  aux|will(v|read&ZERO(n:prop|Mommy,$0),$0)
making  v|read&ZERO(n:prop|Mommy,$0)
making  n:prop|Mommy
making  $0
making  $0
making  adv|later($0)
making  $0
sentence is  you read about the choochoo .
making  lambda $0_{ev}.and(aux|will(v|read&ZERO(pro|I,$0),$0),adv|later($0))
making  and(aux|will(v|read&ZERO(pro|I,$0),$0),adv|later($0))
making  aux|will(v|read&ZERO(pro|I,$0),$0)
making  v|read&ZERO(pro|I,$0)
making  pro|I
making  $0
making  $0
making  adv|later($0)
making  $0
sentence is  you read about the choochoo .
making  lambda $0_{ev}.Q(v|come(pro|you,$0),$0)
making  Q(v|come(pro|you,$0),$0)
making  v|come(pro|you,$0),$0)
making  pro|you
making  $0
making  $0)
Is Q
sentence is  you read about the choochoo .

got training pair
Sent : you read about the choochoo .
Cat : S:lambda $0_{ev}.not(aux|can(v|read&ZERO(n:prop|Mommy,$0),$0),$0)
Cat : St:adj|busy(n:prop|Mommy)
Cat : S:lambda $0_{ev}.v|read&ZERO(n:prop|Eve,$0)
Cat : S:lambda $0_{ev}.and(v|read&ZERO(pro|you,$0),prep|about(det|the($1,n|+on|choo+on|choo($1)),$0))
Cat : S:lambda $0_{ev}.and(aux|will(v|read&ZERO(n:prop|Mommy,$0),$0),adv|later($0))
Cat : S:lambda $0_{ev}.and(aux|will(v|read&ZERO(pro|I,$0),$0),adv|later($0))
Cat : Syn:lambda $0_{ev}.Q(v|come(pro|you,$0),$0)
sentence is  ['you', 'read', 'about', 'the', 'choochoo', '.']
sem is  lambda $0_{ev}.not(aux|can(v|read&ZERO(n:prop|Mommy,$0),$0),$0)
sem is  adj|busy(n:prop|Mommy)
sem is  lambda $0_{ev}.v|read&ZERO(n:prop|Eve,$0)
sem is  lambda $0_{ev}.and(v|read&ZERO(pro|you,$0),prep|about(det|the($1,n|+on|choo+on|choo($1)),$0))
sem is  lambda $0_{ev}.and(aux|will(v|read&ZERO(n:prop|Mommy,$0),$0),adv|later($0))
sem is  lambda $0_{ev}.and(aux|will(v|read&ZERO(pro|I,$0),$0),adv|later($0))
sem is  lambda $0_{ev}.Q(v|come(pro|you,$0),$0)
size of chart is  5457
got chart
norm score is  -43.9259638145
doing updates with learning rate  0.0208787052798
Deleting 0 entries of the total 5286
done io
WATCH	you read about the choochoo .
WATCH	76	((S\NP)\NP)	0.664010839936
WATCH	76	((S\NP)/NP)	0.00154841956899
WATCH	76	((S/NP)/NP)	0.334191447545
WATCH	76	((S/NP)\NP)	0.000249292950111
getting topparses
outputting cat probs
done with sent


making  adj|busy(n:prop|Mommy)
making  n:prop|Mommy
sentence is  Mommy 'll read later .
making  lambda $0_{ev}.v|read&ZERO(n:prop|Eve,$0)
making  v|read&ZERO(n:prop|Eve,$0)
making  n:prop|Eve
making  $0
sentence is  Mommy 'll read later .
making  lambda $0_{ev}.and(v|read&ZERO(pro|you,$0),prep|about(det|the($1,n|+on|choo+on|choo($1)),$0))
making  and(v|read&ZERO(pro|you,$0),prep|about(det|the($1,n|+on|choo+on|choo($1)),$0))
making  v|read&ZERO(pro|you,$0)
making  pro|you
making  $0
making  prep|about(det|the($1,n|+on|choo+on|choo($1)),$0)
making  det|the($1,n|+on|choo+on|choo($1))
making  n|+on|choo+on|choo($1)
making  $1
making  $0
sentence is  Mommy 'll read later .
making  lambda $0_{ev}.and(aux|will(v|read&ZERO(n:prop|Mommy,$0),$0),adv|later($0))
making  and(aux|will(v|read&ZERO(n:prop|Mommy,$0),$0),adv|later($0))
making  aux|will(v|read&ZERO(n:prop|Mommy,$0),$0)
making  v|read&ZERO(n:prop|Mommy,$0)
making  n:prop|Mommy
making  $0
making  $0
making  adv|later($0)
making  $0
sentence is  Mommy 'll read later .
making  lambda $0_{ev}.and(aux|will(v|read&ZERO(pro|I,$0),$0),adv|later($0))
making  and(aux|will(v|read&ZERO(pro|I,$0),$0),adv|later($0))
making  aux|will(v|read&ZERO(pro|I,$0),$0)
making  v|read&ZERO(pro|I,$0)
making  pro|I
making  $0
making  $0
making  adv|later($0)
making  $0
sentence is  Mommy 'll read later .
making  lambda $0_{ev}.Q(v|come(pro|you,$0),$0)
making  Q(v|come(pro|you,$0),$0)
making  v|come(pro|you,$0),$0)
making  pro|you
making  $0
making  $0)
Is Q
sentence is  Mommy 'll read later .
making  lambda $0_{ev}.Q(v|want(pro|you,qn|some($1,n|milk($1)),$0),$0)
making  Q(v|want(pro|you,qn|some($1,n|milk($1)),$0),$0)
making  v|want(pro|you,qn|some($1,n|milk($1)),$0),$0)
making  pro|you
making  qn|some($1,n|milk($1))
making  n|milk($1)
making  $1
making  $0
making  $0)
Is Q
sentence is  Mommy 'll read later .

got training pair
Sent : Mommy 'll read later .
Cat : St:adj|busy(n:prop|Mommy)
Cat : S:lambda $0_{ev}.v|read&ZERO(n:prop|Eve,$0)
Cat : S:lambda $0_{ev}.and(v|read&ZERO(pro|you,$0),prep|about(det|the($1,n|+on|choo+on|choo($1)),$0))
Cat : S:lambda $0_{ev}.and(aux|will(v|read&ZERO(n:prop|Mommy,$0),$0),adv|later($0))
Cat : S:lambda $0_{ev}.and(aux|will(v|read&ZERO(pro|I,$0),$0),adv|later($0))
Cat : Syn:lambda $0_{ev}.Q(v|come(pro|you,$0),$0)
Cat : Syn:lambda $0_{ev}.Q(v|want(pro|you,qn|some($1,n|milk($1)),$0),$0)
sentence is  ['Mommy', "'ll", 'read', 'later', '.']
sem is  adj|busy(n:prop|Mommy)
sem is  lambda $0_{ev}.v|read&ZERO(n:prop|Eve,$0)
sem is  lambda $0_{ev}.and(v|read&ZERO(pro|you,$0),prep|about(det|the($1,n|+on|choo+on|choo($1)),$0))
sem is  lambda $0_{ev}.and(aux|will(v|read&ZERO(n:prop|Mommy,$0),$0),adv|later($0))
sem is  lambda $0_{ev}.and(aux|will(v|read&ZERO(pro|I,$0),$0),adv|later($0))
sem is  lambda $0_{ev}.Q(v|come(pro|you,$0),$0)
sem is  lambda $0_{ev}.Q(v|want(pro|you,qn|some($1,n|milk($1)),$0),$0)
size of chart is  3445
got chart
norm score is  -32.4717905465
doing updates with learning rate  0.0207470819903
Deleting 0 entries of the total 6725
done io
WATCH	Mommy 'll read later .
WATCH	77	((S\NP)\NP)	0.663649295824
WATCH	77	((S\NP)/NP)	0.00153748684934
WATCH	77	((S/NP)/NP)	0.334568138419
WATCH	77	((S/NP)\NP)	0.000245078908177
getting topparses
outputting cat probs
done with sent


making  lambda $0_{ev}.v|read&ZERO(n:prop|Eve,$0)
making  v|read&ZERO(n:prop|Eve,$0)
making  n:prop|Eve
making  $0
sentence is  I 'll read to you later .
making  lambda $0_{ev}.and(v|read&ZERO(pro|you,$0),prep|about(det|the($1,n|+on|choo+on|choo($1)),$0))
making  and(v|read&ZERO(pro|you,$0),prep|about(det|the($1,n|+on|choo+on|choo($1)),$0))
making  v|read&ZERO(pro|you,$0)
making  pro|you
making  $0
making  prep|about(det|the($1,n|+on|choo+on|choo($1)),$0)
making  det|the($1,n|+on|choo+on|choo($1))
making  n|+on|choo+on|choo($1)
making  $1
making  $0
sentence is  I 'll read to you later .
making  lambda $0_{ev}.and(aux|will(v|read&ZERO(n:prop|Mommy,$0),$0),adv|later($0))
making  and(aux|will(v|read&ZERO(n:prop|Mommy,$0),$0),adv|later($0))
making  aux|will(v|read&ZERO(n:prop|Mommy,$0),$0)
making  v|read&ZERO(n:prop|Mommy,$0)
making  n:prop|Mommy
making  $0
making  $0
making  adv|later($0)
making  $0
sentence is  I 'll read to you later .
making  lambda $0_{ev}.and(aux|will(v|read&ZERO(pro|I,$0),$0),adv|later($0))
making  and(aux|will(v|read&ZERO(pro|I,$0),$0),adv|later($0))
making  aux|will(v|read&ZERO(pro|I,$0),$0)
making  v|read&ZERO(pro|I,$0)
making  pro|I
making  $0
making  $0
making  adv|later($0)
making  $0
sentence is  I 'll read to you later .
making  lambda $0_{ev}.Q(v|come(pro|you,$0),$0)
making  Q(v|come(pro|you,$0),$0)
making  v|come(pro|you,$0),$0)
making  pro|you
making  $0
making  $0)
Is Q
sentence is  I 'll read to you later .
making  lambda $0_{ev}.Q(v|want(pro|you,qn|some($1,n|milk($1)),$0),$0)
making  Q(v|want(pro|you,qn|some($1,n|milk($1)),$0),$0)
making  v|want(pro|you,qn|some($1,n|milk($1)),$0),$0)
making  pro|you
making  qn|some($1,n|milk($1))
making  n|milk($1)
making  $1
making  $0
making  $0)
Is Q
sentence is  I 'll read to you later .
making  lambda $0_{ev}.and(aux|will(v|have(pro|we,lambda $1_{e}.n|milk($1),$0),$0),prep|for(lambda $2_{e}.n|lunch($2),$0))
making  and(aux|will(v|have(pro|we,lambda $1_{e}.n|milk($1),$0),$0),prep|for(lambda $2_{e}.n|lunch($2),$0))
making  aux|will(v|have(pro|we,lambda $1_{e}.n|milk($1),$0),$0)
making  v|have(pro|we,lambda $1_{e}.n|milk($1),$0)
making  pro|we
making  lambda $1_{e}.n|milk($1)
making  n|milk($1)
making  $1
making  $0
making  $0
making  prep|for(lambda $2_{e}.n|lunch($2),$0)
making  lambda $2_{e}.n|lunch($2)
making  n|lunch($2)
making  $2
making  $0
sentence is  I 'll read to you later .

got training pair
Sent : I 'll read to you later .
Cat : S:lambda $0_{ev}.v|read&ZERO(n:prop|Eve,$0)
Cat : S:lambda $0_{ev}.and(v|read&ZERO(pro|you,$0),prep|about(det|the($1,n|+on|choo+on|choo($1)),$0))
Cat : S:lambda $0_{ev}.and(aux|will(v|read&ZERO(n:prop|Mommy,$0),$0),adv|later($0))
Cat : S:lambda $0_{ev}.and(aux|will(v|read&ZERO(pro|I,$0),$0),adv|later($0))
Cat : Syn:lambda $0_{ev}.Q(v|come(pro|you,$0),$0)
Cat : Syn:lambda $0_{ev}.Q(v|want(pro|you,qn|some($1,n|milk($1)),$0),$0)
Cat : S:lambda $0_{ev}.and(aux|will(v|have(pro|we,lambda $1_{e}.n|milk($1),$0),$0),prep|for(lambda $2_{e}.n|lunch($2),$0))
sentence is  ['I', "'ll", 'read', 'to', 'you', 'later']
sem is  lambda $0_{ev}.v|read&ZERO(n:prop|Eve,$0)
sem is  lambda $0_{ev}.and(v|read&ZERO(pro|you,$0),prep|about(det|the($1,n|+on|choo+on|choo($1)),$0))
sem is  lambda $0_{ev}.and(aux|will(v|read&ZERO(n:prop|Mommy,$0),$0),adv|later($0))
sem is  lambda $0_{ev}.and(aux|will(v|read&ZERO(pro|I,$0),$0),adv|later($0))
sem is  lambda $0_{ev}.Q(v|come(pro|you,$0),$0)
sem is  lambda $0_{ev}.Q(v|want(pro|you,qn|some($1,n|milk($1)),$0),$0)
sem is  lambda $0_{ev}.and(aux|will(v|have(pro|we,lambda $1_{e}.n|milk($1),$0),$0),prep|for(lambda $2_{e}.n|lunch($2),$0))
size of chart is  10605
got chart
norm score is  -36.8560673847
doing updates with learning rate  0.0206173111058
Deleting 0 entries of the total 10428
done io
WATCH	I 'll read to you later .
WATCH	78	((S\NP)\NP)	0.665713765491
WATCH	78	((S\NP)/NP)	0.00153208301172
WATCH	78	((S/NP)/NP)	0.33251501362
WATCH	78	((S/NP)\NP)	0.000239137877712
getting topparses
outputting cat probs
done with sent


making  lambda $0_{ev}.and(v|read&ZERO(pro|you,$0),prep|about(det|the($1,n|+on|choo+on|choo($1)),$0))
making  and(v|read&ZERO(pro|you,$0),prep|about(det|the($1,n|+on|choo+on|choo($1)),$0))
making  v|read&ZERO(pro|you,$0)
making  pro|you
making  $0
making  prep|about(det|the($1,n|+on|choo+on|choo($1)),$0)
making  det|the($1,n|+on|choo+on|choo($1))
making  n|+on|choo+on|choo($1)
making  $1
making  $0
sentence is  come ?
making  lambda $0_{ev}.and(aux|will(v|read&ZERO(n:prop|Mommy,$0),$0),adv|later($0))
making  and(aux|will(v|read&ZERO(n:prop|Mommy,$0),$0),adv|later($0))
making  aux|will(v|read&ZERO(n:prop|Mommy,$0),$0)
making  v|read&ZERO(n:prop|Mommy,$0)
making  n:prop|Mommy
making  $0
making  $0
making  adv|later($0)
making  $0
sentence is  come ?
making  lambda $0_{ev}.and(aux|will(v|read&ZERO(pro|I,$0),$0),adv|later($0))
making  and(aux|will(v|read&ZERO(pro|I,$0),$0),adv|later($0))
making  aux|will(v|read&ZERO(pro|I,$0),$0)
making  v|read&ZERO(pro|I,$0)
making  pro|I
making  $0
making  $0
making  adv|later($0)
making  $0
sentence is  come ?
making  lambda $0_{ev}.Q(v|come(pro|you,$0),$0)
making  Q(v|come(pro|you,$0),$0)
making  v|come(pro|you,$0),$0)
making  pro|you
making  $0
making  $0)
Is Q
sentence is  come ?
making  lambda $0_{ev}.Q(v|want(pro|you,qn|some($1,n|milk($1)),$0),$0)
making  Q(v|want(pro|you,qn|some($1,n|milk($1)),$0),$0)
making  v|want(pro|you,qn|some($1,n|milk($1)),$0),$0)
making  pro|you
making  qn|some($1,n|milk($1))
making  n|milk($1)
making  $1
making  $0
making  $0)
Is Q
sentence is  come ?
making  lambda $0_{ev}.and(aux|will(v|have(pro|we,lambda $1_{e}.n|milk($1),$0),$0),prep|for(lambda $2_{e}.n|lunch($2),$0))
making  and(aux|will(v|have(pro|we,lambda $1_{e}.n|milk($1),$0),$0),prep|for(lambda $2_{e}.n|lunch($2),$0))
making  aux|will(v|have(pro|we,lambda $1_{e}.n|milk($1),$0),$0)
making  v|have(pro|we,lambda $1_{e}.n|milk($1),$0)
making  pro|we
making  lambda $1_{e}.n|milk($1)
making  n|milk($1)
making  $1
making  $0
making  $0
making  prep|for(lambda $2_{e}.n|lunch($2),$0)
making  lambda $2_{e}.n|lunch($2)
making  n|lunch($2)
making  $2
making  $0
sentence is  come ?
making  lambda $0_{e}.n|cup($0)
making  n|cup($0)
making  $0
sentence is  come ?

got training pair
Sent : come ?
Cat : S:lambda $0_{ev}.and(v|read&ZERO(pro|you,$0),prep|about(det|the($1,n|+on|choo+on|choo($1)),$0))
Cat : S:lambda $0_{ev}.and(aux|will(v|read&ZERO(n:prop|Mommy,$0),$0),adv|later($0))
Cat : S:lambda $0_{ev}.and(aux|will(v|read&ZERO(pro|I,$0),$0),adv|later($0))
Cat : Syn:lambda $0_{ev}.Q(v|come(pro|you,$0),$0)
Cat : Syn:lambda $0_{ev}.Q(v|want(pro|you,qn|some($1,n|milk($1)),$0),$0)
Cat : S:lambda $0_{ev}.and(aux|will(v|have(pro|we,lambda $1_{e}.n|milk($1),$0),$0),prep|for(lambda $2_{e}.n|lunch($2),$0))
Cat : Swh:lambda $0_{e}.n|cup($0)
sentence is  ['come']
sem is  lambda $0_{ev}.and(v|read&ZERO(pro|you,$0),prep|about(det|the($1,n|+on|choo+on|choo($1)),$0))
sem is  lambda $0_{ev}.and(aux|will(v|read&ZERO(n:prop|Mommy,$0),$0),adv|later($0))
sem is  lambda $0_{ev}.and(aux|will(v|read&ZERO(pro|I,$0),$0),adv|later($0))
sem is  lambda $0_{ev}.Q(v|come(pro|you,$0),$0)
sem is  lambda $0_{ev}.Q(v|want(pro|you,qn|some($1,n|milk($1)),$0),$0)
sem is  lambda $0_{ev}.and(aux|will(v|have(pro|we,lambda $1_{e}.n|milk($1),$0),$0),prep|for(lambda $2_{e}.n|lunch($2),$0))
sem is  lambda $0_{e}.n|cup($0)
size of chart is  7
got chart
norm score is  -7.47195067176
doing updates with learning rate  0.0204893523878
Deleting 0 entries of the total 10435
done io
WATCH	come ?
WATCH	79	((S\NP)\NP)	0.665728906505
WATCH	79	((S\NP)/NP)	0.00152188498108
WATCH	79	((S/NP)/NP)	0.332514472895
WATCH	79	((S/NP)\NP)	0.000234735618055
getting topparses
outputting cat probs
done with sent


making  lambda $0_{ev}.and(aux|will(v|read&ZERO(n:prop|Mommy,$0),$0),adv|later($0))
making  and(aux|will(v|read&ZERO(n:prop|Mommy,$0),$0),adv|later($0))
making  aux|will(v|read&ZERO(n:prop|Mommy,$0),$0)
making  v|read&ZERO(n:prop|Mommy,$0)
making  n:prop|Mommy
making  $0
making  $0
making  adv|later($0)
making  $0
sentence is  you want some milk ?
making  lambda $0_{ev}.and(aux|will(v|read&ZERO(pro|I,$0),$0),adv|later($0))
making  and(aux|will(v|read&ZERO(pro|I,$0),$0),adv|later($0))
making  aux|will(v|read&ZERO(pro|I,$0),$0)
making  v|read&ZERO(pro|I,$0)
making  pro|I
making  $0
making  $0
making  adv|later($0)
making  $0
sentence is  you want some milk ?
making  lambda $0_{ev}.Q(v|come(pro|you,$0),$0)
making  Q(v|come(pro|you,$0),$0)
making  v|come(pro|you,$0),$0)
making  pro|you
making  $0
making  $0)
Is Q
sentence is  you want some milk ?
making  lambda $0_{ev}.Q(v|want(pro|you,qn|some($1,n|milk($1)),$0),$0)
making  Q(v|want(pro|you,qn|some($1,n|milk($1)),$0),$0)
making  v|want(pro|you,qn|some($1,n|milk($1)),$0),$0)
making  pro|you
making  qn|some($1,n|milk($1))
making  n|milk($1)
making  $1
making  $0
making  $0)
Is Q
sentence is  you want some milk ?
making  lambda $0_{ev}.and(aux|will(v|have(pro|we,lambda $1_{e}.n|milk($1),$0),$0),prep|for(lambda $2_{e}.n|lunch($2),$0))
making  and(aux|will(v|have(pro|we,lambda $1_{e}.n|milk($1),$0),$0),prep|for(lambda $2_{e}.n|lunch($2),$0))
making  aux|will(v|have(pro|we,lambda $1_{e}.n|milk($1),$0),$0)
making  v|have(pro|we,lambda $1_{e}.n|milk($1),$0)
making  pro|we
making  lambda $1_{e}.n|milk($1)
making  n|milk($1)
making  $1
making  $0
making  $0
making  prep|for(lambda $2_{e}.n|lunch($2),$0)
making  lambda $2_{e}.n|lunch($2)
making  n|lunch($2)
making  $2
making  $0
sentence is  you want some milk ?
making  lambda $0_{e}.n|cup($0)
making  n|cup($0)
making  $0
sentence is  you want some milk ?
making  lambda $0_{ev}.not(eq(pro:dem|that,det|a($1,n|cup($1)),$0),$0)
making  not(eq(pro:dem|that,det|a($1,n|cup($1)),$0),$0)
making  eq(pro:dem|that,det|a($1,n|cup($1)),$0),$0)
making  pro:dem|that,det|a($1,n|cup($1)),$0),$0)
making  det|a($1,n|cup($1)),$0),$0)
making  n|cup($1)
making  $1
making  $0),$0)
making  $0)
sentence is  you want some milk ?

got training pair
Sent : you want some milk ?
Cat : S:lambda $0_{ev}.and(aux|will(v|read&ZERO(n:prop|Mommy,$0),$0),adv|later($0))
Cat : S:lambda $0_{ev}.and(aux|will(v|read&ZERO(pro|I,$0),$0),adv|later($0))
Cat : Syn:lambda $0_{ev}.Q(v|come(pro|you,$0),$0)
Cat : Syn:lambda $0_{ev}.Q(v|want(pro|you,qn|some($1,n|milk($1)),$0),$0)
Cat : S:lambda $0_{ev}.and(aux|will(v|have(pro|we,lambda $1_{e}.n|milk($1),$0),$0),prep|for(lambda $2_{e}.n|lunch($2),$0))
Cat : Swh:lambda $0_{e}.n|cup($0)
Cat : S:lambda $0_{ev}.not(eq(pro:dem|that,det|a($1,n|cup($1)),$0),$0)
sentence is  ['you', 'want', 'some', 'milk']
sem is  lambda $0_{ev}.and(aux|will(v|read&ZERO(n:prop|Mommy,$0),$0),adv|later($0))
sem is  lambda $0_{ev}.and(aux|will(v|read&ZERO(pro|I,$0),$0),adv|later($0))
sem is  lambda $0_{ev}.Q(v|come(pro|you,$0),$0)
sem is  lambda $0_{ev}.Q(v|want(pro|you,qn|some($1,n|milk($1)),$0),$0)
sem is  lambda $0_{ev}.and(aux|will(v|have(pro|we,lambda $1_{e}.n|milk($1),$0),$0),prep|for(lambda $2_{e}.n|lunch($2),$0))
sem is  lambda $0_{e}.n|cup($0)
sem is  lambda $0_{ev}.not(eq(pro:dem|that,det|a($1,n|cup($1)),$0),$0)
size of chart is  1914
got chart
norm score is  -29.6376063935
doing updates with learning rate  0.0203631667747
Deleting 0 entries of the total 11521
done io
WATCH	you want some milk ?
WATCH	80	((S\NP)\NP)	0.671256411329
WATCH	80	((S\NP)/NP)	0.00149194333644
WATCH	80	((S/NP)/NP)	0.327025496071
WATCH	80	((S/NP)\NP)	0.00022614926279
getting topparses
outputting cat probs
done with sent


making  lambda $0_{ev}.and(aux|will(v|read&ZERO(pro|I,$0),$0),adv|later($0))
making  and(aux|will(v|read&ZERO(pro|I,$0),$0),adv|later($0))
making  aux|will(v|read&ZERO(pro|I,$0),$0)
making  v|read&ZERO(pro|I,$0)
making  pro|I
making  $0
making  $0
making  adv|later($0)
making  $0
sentence is  we 'll have milk for lunch .
making  lambda $0_{ev}.Q(v|come(pro|you,$0),$0)
making  Q(v|come(pro|you,$0),$0)
making  v|come(pro|you,$0),$0)
making  pro|you
making  $0
making  $0)
Is Q
sentence is  we 'll have milk for lunch .
making  lambda $0_{ev}.Q(v|want(pro|you,qn|some($1,n|milk($1)),$0),$0)
making  Q(v|want(pro|you,qn|some($1,n|milk($1)),$0),$0)
making  v|want(pro|you,qn|some($1,n|milk($1)),$0),$0)
making  pro|you
making  qn|some($1,n|milk($1))
making  n|milk($1)
making  $1
making  $0
making  $0)
Is Q
sentence is  we 'll have milk for lunch .
making  lambda $0_{ev}.and(aux|will(v|have(pro|we,lambda $1_{e}.n|milk($1),$0),$0),prep|for(lambda $2_{e}.n|lunch($2),$0))
making  and(aux|will(v|have(pro|we,lambda $1_{e}.n|milk($1),$0),$0),prep|for(lambda $2_{e}.n|lunch($2),$0))
making  aux|will(v|have(pro|we,lambda $1_{e}.n|milk($1),$0),$0)
making  v|have(pro|we,lambda $1_{e}.n|milk($1),$0)
making  pro|we
making  lambda $1_{e}.n|milk($1)
making  n|milk($1)
making  $1
making  $0
making  $0
making  prep|for(lambda $2_{e}.n|lunch($2),$0)
making  lambda $2_{e}.n|lunch($2)
making  n|lunch($2)
making  $2
making  $0
sentence is  we 'll have milk for lunch .
making  lambda $0_{e}.n|cup($0)
making  n|cup($0)
making  $0
sentence is  we 'll have milk for lunch .
making  lambda $0_{ev}.not(eq(pro:dem|that,det|a($1,n|cup($1)),$0),$0)
making  not(eq(pro:dem|that,det|a($1,n|cup($1)),$0),$0)
making  eq(pro:dem|that,det|a($1,n|cup($1)),$0),$0)
making  pro:dem|that,det|a($1,n|cup($1)),$0),$0)
making  det|a($1,n|cup($1)),$0),$0)
making  n|cup($1)
making  $1
making  $0),$0)
making  $0)
sentence is  we 'll have milk for lunch .
making  lambda $0_{ev}.eq(pro:dem|that,det|the($1,n|top($1)),$0)
making  eq(pro:dem|that,det|the($1,n|top($1)),$0)
making  pro:dem|that,det|the($1,n|top($1)),$0)
making  det|the($1,n|top($1)),$0)
making  n|top($1)
making  $1
making  $0)
sentence is  we 'll have milk for lunch .

got training pair
Sent : we 'll have milk for lunch .
Cat : S:lambda $0_{ev}.and(aux|will(v|read&ZERO(pro|I,$0),$0),adv|later($0))
Cat : Syn:lambda $0_{ev}.Q(v|come(pro|you,$0),$0)
Cat : Syn:lambda $0_{ev}.Q(v|want(pro|you,qn|some($1,n|milk($1)),$0),$0)
Cat : S:lambda $0_{ev}.and(aux|will(v|have(pro|we,lambda $1_{e}.n|milk($1),$0),$0),prep|for(lambda $2_{e}.n|lunch($2),$0))
Cat : Swh:lambda $0_{e}.n|cup($0)
Cat : S:lambda $0_{ev}.not(eq(pro:dem|that,det|a($1,n|cup($1)),$0),$0)
Cat : S:lambda $0_{ev}.eq(pro:dem|that,det|the($1,n|top($1)),$0)
sentence is  ['we', "'ll", 'have', 'milk', 'for', 'lunch']
sem is  lambda $0_{ev}.and(aux|will(v|read&ZERO(pro|I,$0),$0),adv|later($0))
sem is  lambda $0_{ev}.Q(v|come(pro|you,$0),$0)
sem is  lambda $0_{ev}.Q(v|want(pro|you,qn|some($1,n|milk($1)),$0),$0)
sem is  lambda $0_{ev}.and(aux|will(v|have(pro|we,lambda $1_{e}.n|milk($1),$0),$0),prep|for(lambda $2_{e}.n|lunch($2),$0))
sem is  lambda $0_{e}.n|cup($0)
sem is  lambda $0_{ev}.not(eq(pro:dem|that,det|a($1,n|cup($1)),$0),$0)
sem is  lambda $0_{ev}.eq(pro:dem|that,det|the($1,n|top($1)),$0)
size of chart is  9867
got chart
norm score is  -47.5718252646
doing updates with learning rate  0.020238716339
Deleting 13686 entries of the total 15330
done io
WATCH	we 'll have milk for lunch .
WATCH	81	((S\NP)\NP)	0.674032061303
WATCH	81	((S\NP)/NP)	0.00148777128403
WATCH	81	((S/NP)/NP)	0.324260183323
WATCH	81	((S/NP)\NP)	0.000219984089796
getting topparses
outputting cat probs
done with sent


making  lambda $0_{ev}.Q(v|come(pro|you,$0),$0)
making  Q(v|come(pro|you,$0),$0)
making  v|come(pro|you,$0),$0)
making  pro|you
making  $0
making  $0)
Is Q
sentence is  cup ?
making  lambda $0_{ev}.Q(v|want(pro|you,qn|some($1,n|milk($1)),$0),$0)
making  Q(v|want(pro|you,qn|some($1,n|milk($1)),$0),$0)
making  v|want(pro|you,qn|some($1,n|milk($1)),$0),$0)
making  pro|you
making  qn|some($1,n|milk($1))
making  n|milk($1)
making  $1
making  $0
making  $0)
Is Q
sentence is  cup ?
making  lambda $0_{ev}.and(aux|will(v|have(pro|we,lambda $1_{e}.n|milk($1),$0),$0),prep|for(lambda $2_{e}.n|lunch($2),$0))
making  and(aux|will(v|have(pro|we,lambda $1_{e}.n|milk($1),$0),$0),prep|for(lambda $2_{e}.n|lunch($2),$0))
making  aux|will(v|have(pro|we,lambda $1_{e}.n|milk($1),$0),$0)
making  v|have(pro|we,lambda $1_{e}.n|milk($1),$0)
making  pro|we
making  lambda $1_{e}.n|milk($1)
making  n|milk($1)
making  $1
making  $0
making  $0
making  prep|for(lambda $2_{e}.n|lunch($2),$0)
making  lambda $2_{e}.n|lunch($2)
making  n|lunch($2)
making  $2
making  $0
sentence is  cup ?
making  lambda $0_{e}.n|cup($0)
making  n|cup($0)
making  $0
sentence is  cup ?
making  lambda $0_{ev}.not(eq(pro:dem|that,det|a($1,n|cup($1)),$0),$0)
making  not(eq(pro:dem|that,det|a($1,n|cup($1)),$0),$0)
making  eq(pro:dem|that,det|a($1,n|cup($1)),$0),$0)
making  pro:dem|that,det|a($1,n|cup($1)),$0),$0)
making  det|a($1,n|cup($1)),$0),$0)
making  n|cup($1)
making  $1
making  $0),$0)
making  $0)
sentence is  cup ?
making  lambda $0_{ev}.eq(pro:dem|that,det|the($1,n|top($1)),$0)
making  eq(pro:dem|that,det|the($1,n|top($1)),$0)
making  pro:dem|that,det|the($1,n|top($1)),$0)
making  det|the($1,n|top($1)),$0)
making  n|top($1)
making  $1
making  $0)
sentence is  cup ?
making  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  eq($0,pro:dem|that,$1)
making  $0,pro:dem|that,$1)
making  pro:dem|that,$1)
making  $1)
sentence is  cup ?

got training pair
Sent : cup ?
Cat : Syn:lambda $0_{ev}.Q(v|come(pro|you,$0),$0)
Cat : Syn:lambda $0_{ev}.Q(v|want(pro|you,qn|some($1,n|milk($1)),$0),$0)
Cat : S:lambda $0_{ev}.and(aux|will(v|have(pro|we,lambda $1_{e}.n|milk($1),$0),$0),prep|for(lambda $2_{e}.n|lunch($2),$0))
Cat : Swh:lambda $0_{e}.n|cup($0)
Cat : S:lambda $0_{ev}.not(eq(pro:dem|that,det|a($1,n|cup($1)),$0),$0)
Cat : S:lambda $0_{ev}.eq(pro:dem|that,det|the($1,n|top($1)),$0)
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
sentence is  ['cup']
sem is  lambda $0_{ev}.Q(v|come(pro|you,$0),$0)
sem is  lambda $0_{ev}.Q(v|want(pro|you,qn|some($1,n|milk($1)),$0),$0)
sem is  lambda $0_{ev}.and(aux|will(v|have(pro|we,lambda $1_{e}.n|milk($1),$0),$0),prep|for(lambda $2_{e}.n|lunch($2),$0))
sem is  lambda $0_{e}.n|cup($0)
sem is  lambda $0_{ev}.not(eq(pro:dem|that,det|a($1,n|cup($1)),$0),$0)
sem is  lambda $0_{ev}.eq(pro:dem|that,det|the($1,n|top($1)),$0)
sem is  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
size of chart is  7
got chart
norm score is  -10.1724651435
doing updates with learning rate  0.0201159642459
Deleting 0 entries of the total 1651
done io
WATCH	cup ?
WATCH	82	((S\NP)\NP)	0.674047478946
WATCH	82	((S\NP)/NP)	0.00147753261453
WATCH	82	((S/NP)/NP)	0.32425917844
WATCH	82	((S/NP)\NP)	0.000215809998857
getting topparses
outputting cat probs
done with sent


making  lambda $0_{ev}.Q(v|want(pro|you,qn|some($1,n|milk($1)),$0),$0)
making  Q(v|want(pro|you,qn|some($1,n|milk($1)),$0),$0)
making  v|want(pro|you,qn|some($1,n|milk($1)),$0),$0)
making  pro|you
making  qn|some($1,n|milk($1))
making  n|milk($1)
making  $1
making  $0
making  $0)
Is Q
sentence is  that 's not a cup .
making  lambda $0_{ev}.and(aux|will(v|have(pro|we,lambda $1_{e}.n|milk($1),$0),$0),prep|for(lambda $2_{e}.n|lunch($2),$0))
making  and(aux|will(v|have(pro|we,lambda $1_{e}.n|milk($1),$0),$0),prep|for(lambda $2_{e}.n|lunch($2),$0))
making  aux|will(v|have(pro|we,lambda $1_{e}.n|milk($1),$0),$0)
making  v|have(pro|we,lambda $1_{e}.n|milk($1),$0)
making  pro|we
making  lambda $1_{e}.n|milk($1)
making  n|milk($1)
making  $1
making  $0
making  $0
making  prep|for(lambda $2_{e}.n|lunch($2),$0)
making  lambda $2_{e}.n|lunch($2)
making  n|lunch($2)
making  $2
making  $0
sentence is  that 's not a cup .
making  lambda $0_{e}.n|cup($0)
making  n|cup($0)
making  $0
sentence is  that 's not a cup .
making  lambda $0_{ev}.not(eq(pro:dem|that,det|a($1,n|cup($1)),$0),$0)
making  not(eq(pro:dem|that,det|a($1,n|cup($1)),$0),$0)
making  eq(pro:dem|that,det|a($1,n|cup($1)),$0),$0)
making  pro:dem|that,det|a($1,n|cup($1)),$0),$0)
making  det|a($1,n|cup($1)),$0),$0)
making  n|cup($1)
making  $1
making  $0),$0)
making  $0)
sentence is  that 's not a cup .
making  lambda $0_{ev}.eq(pro:dem|that,det|the($1,n|top($1)),$0)
making  eq(pro:dem|that,det|the($1,n|top($1)),$0)
making  pro:dem|that,det|the($1,n|top($1)),$0)
making  det|the($1,n|top($1)),$0)
making  n|top($1)
making  $1
making  $0)
sentence is  that 's not a cup .
making  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  eq($0,pro:dem|that,$1)
making  $0,pro:dem|that,$1)
making  pro:dem|that,$1)
making  $1)
sentence is  that 's not a cup .
making  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  eq($0,pro:dem|that,$1)
making  $0,pro:dem|that,$1)
making  pro:dem|that,$1)
making  $1)
sentence is  that 's not a cup .

got training pair
Sent : that 's not a cup .
Cat : Syn:lambda $0_{ev}.Q(v|want(pro|you,qn|some($1,n|milk($1)),$0),$0)
Cat : S:lambda $0_{ev}.and(aux|will(v|have(pro|we,lambda $1_{e}.n|milk($1),$0),$0),prep|for(lambda $2_{e}.n|lunch($2),$0))
Cat : Swh:lambda $0_{e}.n|cup($0)
Cat : S:lambda $0_{ev}.not(eq(pro:dem|that,det|a($1,n|cup($1)),$0),$0)
Cat : S:lambda $0_{ev}.eq(pro:dem|that,det|the($1,n|top($1)),$0)
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
sentence is  ['that', "'s", 'not', 'a', 'cup']
sem is  lambda $0_{ev}.Q(v|want(pro|you,qn|some($1,n|milk($1)),$0),$0)
sem is  lambda $0_{ev}.and(aux|will(v|have(pro|we,lambda $1_{e}.n|milk($1),$0),$0),prep|for(lambda $2_{e}.n|lunch($2),$0))
sem is  lambda $0_{e}.n|cup($0)
sem is  lambda $0_{ev}.not(eq(pro:dem|that,det|a($1,n|cup($1)),$0),$0)
sem is  lambda $0_{ev}.eq(pro:dem|that,det|the($1,n|top($1)),$0)
sem is  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
sem is  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
size of chart is  4538
got chart
norm score is  -36.0400919575
doing updates with learning rate  0.0199948747138
Deleting 0 entries of the total 4039
done io
WATCH	that 's not a cup .
WATCH	83	((S\NP)\NP)	0.682446944477
WATCH	83	((S\NP)/NP)	0.00137889617976
WATCH	83	((S/NP)/NP)	0.315977727443
WATCH	83	((S/NP)\NP)	0.000196431900968
getting topparses
outputting cat probs
done with sent


making  lambda $0_{ev}.and(aux|will(v|have(pro|we,lambda $1_{e}.n|milk($1),$0),$0),prep|for(lambda $2_{e}.n|lunch($2),$0))
making  and(aux|will(v|have(pro|we,lambda $1_{e}.n|milk($1),$0),$0),prep|for(lambda $2_{e}.n|lunch($2),$0))
making  aux|will(v|have(pro|we,lambda $1_{e}.n|milk($1),$0),$0)
making  v|have(pro|we,lambda $1_{e}.n|milk($1),$0)
making  pro|we
making  lambda $1_{e}.n|milk($1)
making  n|milk($1)
making  $1
making  $0
making  $0
making  prep|for(lambda $2_{e}.n|lunch($2),$0)
making  lambda $2_{e}.n|lunch($2)
making  n|lunch($2)
making  $2
making  $0
sentence is  that 's the top .
making  lambda $0_{e}.n|cup($0)
making  n|cup($0)
making  $0
sentence is  that 's the top .
making  lambda $0_{ev}.not(eq(pro:dem|that,det|a($1,n|cup($1)),$0),$0)
making  not(eq(pro:dem|that,det|a($1,n|cup($1)),$0),$0)
making  eq(pro:dem|that,det|a($1,n|cup($1)),$0),$0)
making  pro:dem|that,det|a($1,n|cup($1)),$0),$0)
making  det|a($1,n|cup($1)),$0),$0)
making  n|cup($1)
making  $1
making  $0),$0)
making  $0)
sentence is  that 's the top .
making  lambda $0_{ev}.eq(pro:dem|that,det|the($1,n|top($1)),$0)
making  eq(pro:dem|that,det|the($1,n|top($1)),$0)
making  pro:dem|that,det|the($1,n|top($1)),$0)
making  det|the($1,n|top($1)),$0)
making  n|top($1)
making  $1
making  $0)
sentence is  that 's the top .
making  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  eq($0,pro:dem|that,$1)
making  $0,pro:dem|that,$1)
making  pro:dem|that,$1)
making  $1)
sentence is  that 's the top .
making  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  eq($0,pro:dem|that,$1)
making  $0,pro:dem|that,$1)
making  pro:dem|that,$1)
making  $1)
sentence is  that 's the top .
making  lambda $0_{e}.lambda $1_{ev}.eq($0,pro|it,$1)
making  lambda $1_{ev}.eq($0,pro|it,$1)
making  eq($0,pro|it,$1)
making  $0,pro|it,$1)
making  pro|it,$1)
making  $1)
sentence is  that 's the top .

got training pair
Sent : that 's the top .
Cat : S:lambda $0_{ev}.and(aux|will(v|have(pro|we,lambda $1_{e}.n|milk($1),$0),$0),prep|for(lambda $2_{e}.n|lunch($2),$0))
Cat : Swh:lambda $0_{e}.n|cup($0)
Cat : S:lambda $0_{ev}.not(eq(pro:dem|that,det|a($1,n|cup($1)),$0),$0)
Cat : S:lambda $0_{ev}.eq(pro:dem|that,det|the($1,n|top($1)),$0)
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.eq($0,pro|it,$1)
sentence is  ['that', "'s", 'the', 'top']
sem is  lambda $0_{ev}.and(aux|will(v|have(pro|we,lambda $1_{e}.n|milk($1),$0),$0),prep|for(lambda $2_{e}.n|lunch($2),$0))
sem is  lambda $0_{e}.n|cup($0)
sem is  lambda $0_{ev}.not(eq(pro:dem|that,det|a($1,n|cup($1)),$0),$0)
sem is  lambda $0_{ev}.eq(pro:dem|that,det|the($1,n|top($1)),$0)
sem is  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
sem is  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
sem is  lambda $0_{e}.lambda $1_{ev}.eq($0,pro|it,$1)
size of chart is  1444
got chart
norm score is  -28.8939621434
doing updates with learning rate  0.0198754129766
Deleting 0 entries of the total 4612
done io
WATCH	that 's the top .
WATCH	84	((S\NP)\NP)	0.670399554662
WATCH	84	((S\NP)/NP)	0.00133186713532
WATCH	84	((S/NP)/NP)	0.328083266791
WATCH	84	((S/NP)\NP)	0.000185311411841
getting topparses
outputting cat probs
done with sent


making  lambda $0_{e}.n|cup($0)
making  n|cup($0)
making  $0
sentence is  what is that ?
making  lambda $0_{ev}.not(eq(pro:dem|that,det|a($1,n|cup($1)),$0),$0)
making  not(eq(pro:dem|that,det|a($1,n|cup($1)),$0),$0)
making  eq(pro:dem|that,det|a($1,n|cup($1)),$0),$0)
making  pro:dem|that,det|a($1,n|cup($1)),$0),$0)
making  det|a($1,n|cup($1)),$0),$0)
making  n|cup($1)
making  $1
making  $0),$0)
making  $0)
sentence is  what is that ?
making  lambda $0_{ev}.eq(pro:dem|that,det|the($1,n|top($1)),$0)
making  eq(pro:dem|that,det|the($1,n|top($1)),$0)
making  pro:dem|that,det|the($1,n|top($1)),$0)
making  det|the($1,n|top($1)),$0)
making  n|top($1)
making  $1
making  $0)
sentence is  what is that ?
making  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  eq($0,pro:dem|that,$1)
making  $0,pro:dem|that,$1)
making  pro:dem|that,$1)
making  $1)
sentence is  what is that ?
making  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  eq($0,pro:dem|that,$1)
making  $0,pro:dem|that,$1)
making  pro:dem|that,$1)
making  $1)
sentence is  what is that ?
making  lambda $0_{e}.lambda $1_{ev}.eq($0,pro|it,$1)
making  lambda $1_{ev}.eq($0,pro|it,$1)
making  eq($0,pro|it,$1)
making  $0,pro|it,$1)
making  pro|it,$1)
making  $1)
sentence is  what is that ?
making  lambda $0_{e}.lambda $1_{ev}.v|say(det|the($2,n|duck-PL($2)),$0,$1)
making  lambda $1_{ev}.v|say(det|the($2,n|duck-PL($2)),$0,$1)
making  v|say(det|the($2,n|duck-PL($2)),$0,$1)
making  det|the($2,n|duck-PL($2))
making  n|duck-PL($2)
making  $2
making  $0
making  $1
sentence is  what is that ?

got training pair
Sent : what is that ?
Cat : Swh:lambda $0_{e}.n|cup($0)
Cat : S:lambda $0_{ev}.not(eq(pro:dem|that,det|a($1,n|cup($1)),$0),$0)
Cat : S:lambda $0_{ev}.eq(pro:dem|that,det|the($1,n|top($1)),$0)
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.eq($0,pro|it,$1)
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.v|say(det|the($2,n|duck-PL($2)),$0,$1)
sentence is  ['what', 'is', 'that']
sem is  lambda $0_{e}.n|cup($0)
sem is  lambda $0_{ev}.not(eq(pro:dem|that,det|a($1,n|cup($1)),$0),$0)
sem is  lambda $0_{ev}.eq(pro:dem|that,det|the($1,n|top($1)),$0)
sem is  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
sem is  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
sem is  lambda $0_{e}.lambda $1_{ev}.eq($0,pro|it,$1)
sem is  lambda $0_{e}.lambda $1_{ev}.v|say(det|the($2,n|duck-PL($2)),$0,$1)
size of chart is  263
got chart
norm score is  -19.1911656345
doing updates with learning rate  0.0197575452474
Deleting 0 entries of the total 4762
done io
WATCH	what is that ?
WATCH	85	((S\NP)\NP)	0.671601194233
WATCH	85	((S\NP)/NP)	0.00132404870657
WATCH	85	((S/NP)/NP)	0.326893860341
WATCH	85	((S/NP)\NP)	0.000180896718989
getting topparses
outputting cat probs
done with sent


making  lambda $0_{ev}.not(eq(pro:dem|that,det|a($1,n|cup($1)),$0),$0)
making  not(eq(pro:dem|that,det|a($1,n|cup($1)),$0),$0)
making  eq(pro:dem|that,det|a($1,n|cup($1)),$0),$0)
making  pro:dem|that,det|a($1,n|cup($1)),$0),$0)
making  det|a($1,n|cup($1)),$0),$0)
making  n|cup($1)
making  $1
making  $0),$0)
making  $0)
sentence is  what is that ?
making  lambda $0_{ev}.eq(pro:dem|that,det|the($1,n|top($1)),$0)
making  eq(pro:dem|that,det|the($1,n|top($1)),$0)
making  pro:dem|that,det|the($1,n|top($1)),$0)
making  det|the($1,n|top($1)),$0)
making  n|top($1)
making  $1
making  $0)
sentence is  what is that ?
making  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  eq($0,pro:dem|that,$1)
making  $0,pro:dem|that,$1)
making  pro:dem|that,$1)
making  $1)
sentence is  what is that ?
making  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  eq($0,pro:dem|that,$1)
making  $0,pro:dem|that,$1)
making  pro:dem|that,$1)
making  $1)
sentence is  what is that ?
making  lambda $0_{e}.lambda $1_{ev}.eq($0,pro|it,$1)
making  lambda $1_{ev}.eq($0,pro|it,$1)
making  eq($0,pro|it,$1)
making  $0,pro|it,$1)
making  pro|it,$1)
making  $1)
sentence is  what is that ?
making  lambda $0_{e}.lambda $1_{ev}.v|say(det|the($2,n|duck-PL($2)),$0,$1)
making  lambda $1_{ev}.v|say(det|the($2,n|duck-PL($2)),$0,$1)
making  v|say(det|the($2,n|duck-PL($2)),$0,$1)
making  det|the($2,n|duck-PL($2))
making  n|duck-PL($2)
making  $2
making  $0
making  $1
sentence is  what is that ?
making  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  eq($0,pro:dem|that,$1)
making  $0,pro:dem|that,$1)
making  pro:dem|that,$1)
making  $1)
sentence is  what is that ?

got training pair
Sent : what is that ?
Cat : S:lambda $0_{ev}.not(eq(pro:dem|that,det|a($1,n|cup($1)),$0),$0)
Cat : S:lambda $0_{ev}.eq(pro:dem|that,det|the($1,n|top($1)),$0)
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.eq($0,pro|it,$1)
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.v|say(det|the($2,n|duck-PL($2)),$0,$1)
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
sentence is  ['what', 'is', 'that']
sem is  lambda $0_{ev}.not(eq(pro:dem|that,det|a($1,n|cup($1)),$0),$0)
sem is  lambda $0_{ev}.eq(pro:dem|that,det|the($1,n|top($1)),$0)
sem is  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
sem is  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
sem is  lambda $0_{e}.lambda $1_{ev}.eq($0,pro|it,$1)
sem is  lambda $0_{e}.lambda $1_{ev}.v|say(det|the($2,n|duck-PL($2)),$0,$1)
sem is  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
size of chart is  258
got chart
norm score is  -14.3904199539
doing updates with learning rate  0.0196412386841
Deleting 0 entries of the total 4762
done io
WATCH	what is that ?
WATCH	86	((S\NP)\NP)	0.672776111127
WATCH	86	((S\NP)/NP)	0.00131656657388
WATCH	86	((S/NP)/NP)	0.325730646727
WATCH	86	((S/NP)\NP)	0.000176675572142
getting topparses
outputting cat probs
done with sent


making  lambda $0_{ev}.eq(pro:dem|that,det|the($1,n|top($1)),$0)
making  eq(pro:dem|that,det|the($1,n|top($1)),$0)
making  pro:dem|that,det|the($1,n|top($1)),$0)
making  det|the($1,n|top($1)),$0)
making  n|top($1)
making  $1
making  $0)
sentence is  what is it ?
making  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  eq($0,pro:dem|that,$1)
making  $0,pro:dem|that,$1)
making  pro:dem|that,$1)
making  $1)
sentence is  what is it ?
making  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  eq($0,pro:dem|that,$1)
making  $0,pro:dem|that,$1)
making  pro:dem|that,$1)
making  $1)
sentence is  what is it ?
making  lambda $0_{e}.lambda $1_{ev}.eq($0,pro|it,$1)
making  lambda $1_{ev}.eq($0,pro|it,$1)
making  eq($0,pro|it,$1)
making  $0,pro|it,$1)
making  pro|it,$1)
making  $1)
sentence is  what is it ?
making  lambda $0_{e}.lambda $1_{ev}.v|say(det|the($2,n|duck-PL($2)),$0,$1)
making  lambda $1_{ev}.v|say(det|the($2,n|duck-PL($2)),$0,$1)
making  v|say(det|the($2,n|duck-PL($2)),$0,$1)
making  det|the($2,n|duck-PL($2))
making  n|duck-PL($2)
making  $2
making  $0
making  $1
sentence is  what is it ?
making  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  eq($0,pro:dem|that,$1)
making  $0,pro:dem|that,$1)
making  pro:dem|that,$1)
making  $1)
sentence is  what is it ?
making  lambda $0_{e}.n|radio($0)
making  n|radio($0)
making  $0
sentence is  what is it ?

got training pair
Sent : what is it ?
Cat : S:lambda $0_{ev}.eq(pro:dem|that,det|the($1,n|top($1)),$0)
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.eq($0,pro|it,$1)
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.v|say(det|the($2,n|duck-PL($2)),$0,$1)
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
Cat : Swh:lambda $0_{e}.n|radio($0)
sentence is  ['what', 'is', 'it']
sem is  lambda $0_{ev}.eq(pro:dem|that,det|the($1,n|top($1)),$0)
sem is  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
sem is  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
sem is  lambda $0_{e}.lambda $1_{ev}.eq($0,pro|it,$1)
sem is  lambda $0_{e}.lambda $1_{ev}.v|say(det|the($2,n|duck-PL($2)),$0,$1)
sem is  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
sem is  lambda $0_{e}.n|radio($0)
size of chart is  189
got chart
norm score is  -18.2794045261
doing updates with learning rate  0.0195264613563
Deleting 0 entries of the total 4818
done io
WATCH	what is it ?
WATCH	87	((S\NP)\NP)	0.674572694521
WATCH	87	((S\NP)/NP)	0.00129934305498
WATCH	87	((S/NP)/NP)	0.323955742852
WATCH	87	((S/NP)\NP)	0.000172219572085
getting topparses
outputting cat probs
done with sent


making  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  eq($0,pro:dem|that,$1)
making  $0,pro:dem|that,$1)
making  pro:dem|that,$1)
making  $1)
sentence is  the ducks say what ?
making  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  eq($0,pro:dem|that,$1)
making  $0,pro:dem|that,$1)
making  pro:dem|that,$1)
making  $1)
sentence is  the ducks say what ?
making  lambda $0_{e}.lambda $1_{ev}.eq($0,pro|it,$1)
making  lambda $1_{ev}.eq($0,pro|it,$1)
making  eq($0,pro|it,$1)
making  $0,pro|it,$1)
making  pro|it,$1)
making  $1)
sentence is  the ducks say what ?
making  lambda $0_{e}.lambda $1_{ev}.v|say(det|the($2,n|duck-PL($2)),$0,$1)
making  lambda $1_{ev}.v|say(det|the($2,n|duck-PL($2)),$0,$1)
making  v|say(det|the($2,n|duck-PL($2)),$0,$1)
making  det|the($2,n|duck-PL($2))
making  n|duck-PL($2)
making  $2
making  $0
making  $1
sentence is  the ducks say what ?
making  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  eq($0,pro:dem|that,$1)
making  $0,pro:dem|that,$1)
making  pro:dem|that,$1)
making  $1)
sentence is  the ducks say what ?
making  lambda $0_{e}.n|radio($0)
making  n|radio($0)
making  $0
sentence is  the ducks say what ?
making  lambda $0_{e}.lambda $1_{ev}.and(aux|will(v|do(pro|you,$0,$1),$1),prep|with(pro|it,$1))
making  lambda $1_{ev}.and(aux|will(v|do(pro|you,$0,$1),$1),prep|with(pro|it,$1))
making  and(aux|will(v|do(pro|you,$0,$1),$1),prep|with(pro|it,$1))
making  aux|will(v|do(pro|you,$0,$1),$1)
making  v|do(pro|you,$0,$1)
making  pro|you
making  $0
making  $1
making  $1
making  prep|with(pro|it,$1)
making  pro|it
making  $1
sentence is  the ducks say what ?

got training pair
Sent : the ducks say what ?
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.eq($0,pro|it,$1)
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.v|say(det|the($2,n|duck-PL($2)),$0,$1)
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
Cat : Swh:lambda $0_{e}.n|radio($0)
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.and(aux|will(v|do(pro|you,$0,$1),$1),prep|with(pro|it,$1))
sentence is  ['the', 'ducks', 'say', 'what']
sem is  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
sem is  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
sem is  lambda $0_{e}.lambda $1_{ev}.eq($0,pro|it,$1)
sem is  lambda $0_{e}.lambda $1_{ev}.v|say(det|the($2,n|duck-PL($2)),$0,$1)
sem is  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
sem is  lambda $0_{e}.n|radio($0)
sem is  lambda $0_{e}.lambda $1_{ev}.and(aux|will(v|do(pro|you,$0,$1),$1),prep|with(pro|it,$1))
types dont match 2 :  (Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|with(pro|it,$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|with(pro|it,$1)) (S/NP):lambda $0_{e}.lambda $1_{ev}.aux|will(v|do(pro|you,$0,$1),$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|with(pro|it,$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
types dont match 2 :  (Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|with(pro|it,$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|with(pro|it,$1)) (S\NP):lambda $0_{e}.lambda $1_{ev}.aux|will(v|do(pro|you,$0,$1),$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|with(pro|it,$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
types dont match 2 :  (Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|with(pro|it,$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|with(pro|it,$1)) (S/NP):lambda $0_{e}.lambda $1_{ev}.aux|will(v|do(pro|you,$0,$1),$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|with(pro|it,$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
types dont match 2 :  (Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|with(pro|it,$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|with(pro|it,$1)) (S\NP):lambda $0_{e}.lambda $1_{ev}.aux|will(v|do(pro|you,$0,$1),$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|with(pro|it,$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
types dont match 2 :  (Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and(aux|will($0($1),$1),prep|with(pro|it,$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and(aux|will($0($1),$1),prep|with(pro|it,$1)) (S/NP):lambda $0_{e}.lambda $1_{ev}.v|do(pro|you,$0,$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and(aux|will($0($1),$1),prep|with(pro|it,$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
types dont match 2 :  (Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and(aux|will($0($1),$1),prep|with(pro|it,$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and(aux|will($0($1),$1),prep|with(pro|it,$1)) (S\NP):lambda $0_{e}.lambda $1_{ev}.v|do(pro|you,$0,$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and(aux|will($0($1),$1),prep|with(pro|it,$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
size of chart is  1236
got chart
norm score is  -37.9701243524
doing updates with learning rate  0.0194131822135
Deleting 0 entries of the total 5258
done io
WATCH	the ducks say what ?
WATCH	88	((S\NP)\NP)	0.660634507384
WATCH	88	((S\NP)/NP)	0.00125597582461
WATCH	88	((S/NP)/NP)	0.337957481923
WATCH	88	((S/NP)\NP)	0.000152034868733
getting topparses
outputting cat probs
done with sent


making  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  eq($0,pro:dem|that,$1)
making  $0,pro:dem|that,$1)
making  pro:dem|that,$1)
making  $1)
sentence is  what is that ?
making  lambda $0_{e}.lambda $1_{ev}.eq($0,pro|it,$1)
making  lambda $1_{ev}.eq($0,pro|it,$1)
making  eq($0,pro|it,$1)
making  $0,pro|it,$1)
making  pro|it,$1)
making  $1)
sentence is  what is that ?
making  lambda $0_{e}.lambda $1_{ev}.v|say(det|the($2,n|duck-PL($2)),$0,$1)
making  lambda $1_{ev}.v|say(det|the($2,n|duck-PL($2)),$0,$1)
making  v|say(det|the($2,n|duck-PL($2)),$0,$1)
making  det|the($2,n|duck-PL($2))
making  n|duck-PL($2)
making  $2
making  $0
making  $1
sentence is  what is that ?
making  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  eq($0,pro:dem|that,$1)
making  $0,pro:dem|that,$1)
making  pro:dem|that,$1)
making  $1)
sentence is  what is that ?
making  lambda $0_{e}.n|radio($0)
making  n|radio($0)
making  $0
sentence is  what is that ?
making  lambda $0_{e}.lambda $1_{ev}.and(aux|will(v|do(pro|you,$0,$1),$1),prep|with(pro|it,$1))
making  lambda $1_{ev}.and(aux|will(v|do(pro|you,$0,$1),$1),prep|with(pro|it,$1))
making  and(aux|will(v|do(pro|you,$0,$1),$1),prep|with(pro|it,$1))
making  aux|will(v|do(pro|you,$0,$1),$1)
making  v|do(pro|you,$0,$1)
making  pro|you
making  $0
making  $1
making  $1
making  prep|with(pro|it,$1)
making  pro|it
making  $1
sentence is  what is that ?
making  lambda $0_{e}.n|hat($0)
making  n|hat($0)
making  $0
sentence is  what is that ?

got training pair
Sent : what is that ?
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.eq($0,pro|it,$1)
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.v|say(det|the($2,n|duck-PL($2)),$0,$1)
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
Cat : Swh:lambda $0_{e}.n|radio($0)
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.and(aux|will(v|do(pro|you,$0,$1),$1),prep|with(pro|it,$1))
Cat : Swh:lambda $0_{e}.n|hat($0)
sentence is  ['what', 'is', 'that']
sem is  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
sem is  lambda $0_{e}.lambda $1_{ev}.eq($0,pro|it,$1)
sem is  lambda $0_{e}.lambda $1_{ev}.v|say(det|the($2,n|duck-PL($2)),$0,$1)
sem is  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
sem is  lambda $0_{e}.n|radio($0)
sem is  lambda $0_{e}.lambda $1_{ev}.and(aux|will(v|do(pro|you,$0,$1),$1),prep|with(pro|it,$1))
types dont match 2 :  (Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|with(pro|it,$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|with(pro|it,$1)) (S/NP):lambda $0_{e}.lambda $1_{ev}.aux|will(v|do(pro|you,$0,$1),$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|with(pro|it,$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
types dont match 2 :  (Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|with(pro|it,$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|with(pro|it,$1)) (S\NP):lambda $0_{e}.lambda $1_{ev}.aux|will(v|do(pro|you,$0,$1),$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|with(pro|it,$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
types dont match 2 :  (Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|with(pro|it,$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|with(pro|it,$1)) (S/NP):lambda $0_{e}.lambda $1_{ev}.aux|will(v|do(pro|you,$0,$1),$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|with(pro|it,$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
types dont match 2 :  (Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|with(pro|it,$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|with(pro|it,$1)) (S\NP):lambda $0_{e}.lambda $1_{ev}.aux|will(v|do(pro|you,$0,$1),$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|with(pro|it,$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
types dont match 2 :  (Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and(aux|will($0($1),$1),prep|with(pro|it,$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and(aux|will($0($1),$1),prep|with(pro|it,$1)) (S/NP):lambda $0_{e}.lambda $1_{ev}.v|do(pro|you,$0,$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and(aux|will($0($1),$1),prep|with(pro|it,$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
types dont match 2 :  (Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and(aux|will($0($1),$1),prep|with(pro|it,$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and(aux|will($0($1),$1),prep|with(pro|it,$1)) (S\NP):lambda $0_{e}.lambda $1_{ev}.v|do(pro|you,$0,$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and(aux|will($0($1),$1),prep|with(pro|it,$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
sem is  lambda $0_{e}.n|hat($0)
size of chart is  368
got chart
norm score is  -11.7617506449
doing updates with learning rate  0.0193013710544
Deleting 0 entries of the total 5338
done io
WATCH	what is that ?
WATCH	89	((S\NP)\NP)	0.660648494105
WATCH	89	((S\NP)/NP)	0.00124666081841
WATCH	89	((S/NP)/NP)	0.337955878892
WATCH	89	((S/NP)\NP)	0.000148966185204
getting topparses
outputting cat probs
done with sent


making  lambda $0_{e}.lambda $1_{ev}.eq($0,pro|it,$1)
making  lambda $1_{ev}.eq($0,pro|it,$1)
making  eq($0,pro|it,$1)
making  $0,pro|it,$1)
making  pro|it,$1)
making  $1)
sentence is  radio .
making  lambda $0_{e}.lambda $1_{ev}.v|say(det|the($2,n|duck-PL($2)),$0,$1)
making  lambda $1_{ev}.v|say(det|the($2,n|duck-PL($2)),$0,$1)
making  v|say(det|the($2,n|duck-PL($2)),$0,$1)
making  det|the($2,n|duck-PL($2))
making  n|duck-PL($2)
making  $2
making  $0
making  $1
sentence is  radio .
making  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  eq($0,pro:dem|that,$1)
making  $0,pro:dem|that,$1)
making  pro:dem|that,$1)
making  $1)
sentence is  radio .
making  lambda $0_{e}.n|radio($0)
making  n|radio($0)
making  $0
sentence is  radio .
making  lambda $0_{e}.lambda $1_{ev}.and(aux|will(v|do(pro|you,$0,$1),$1),prep|with(pro|it,$1))
making  lambda $1_{ev}.and(aux|will(v|do(pro|you,$0,$1),$1),prep|with(pro|it,$1))
making  and(aux|will(v|do(pro|you,$0,$1),$1),prep|with(pro|it,$1))
making  aux|will(v|do(pro|you,$0,$1),$1)
making  v|do(pro|you,$0,$1)
making  pro|you
making  $0
making  $1
making  $1
making  prep|with(pro|it,$1)
making  pro|it
making  $1
sentence is  radio .
making  lambda $0_{e}.n|hat($0)
making  n|hat($0)
making  $0
sentence is  radio .
making  lambda $0_{e}.eqLoc(pro:poss:det|your($1,n|hat($1)),$0)
making  eqLoc(pro:poss:det|your($1,n|hat($1)),$0)
making  pro:poss:det|your($1,n|hat($1)),$0)
making  n|hat($1)
making  $1
making  $0)
sentence is  radio .

got training pair
Sent : radio .
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.eq($0,pro|it,$1)
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.v|say(det|the($2,n|duck-PL($2)),$0,$1)
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
Cat : Swh:lambda $0_{e}.n|radio($0)
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.and(aux|will(v|do(pro|you,$0,$1),$1),prep|with(pro|it,$1))
Cat : Swh:lambda $0_{e}.n|hat($0)
Cat : Swh:lambda $0_{e}.eqLoc(pro:poss:det|your($1,n|hat($1)),$0)
sentence is  ['radio']
sem is  lambda $0_{e}.lambda $1_{ev}.eq($0,pro|it,$1)
sem is  lambda $0_{e}.lambda $1_{ev}.v|say(det|the($2,n|duck-PL($2)),$0,$1)
sem is  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
sem is  lambda $0_{e}.n|radio($0)
sem is  lambda $0_{e}.lambda $1_{ev}.and(aux|will(v|do(pro|you,$0,$1),$1),prep|with(pro|it,$1))
sem is  lambda $0_{e}.n|hat($0)
sem is  lambda $0_{e}.eqLoc(pro:poss:det|your($1,n|hat($1)),$0)
size of chart is  7
got chart
norm score is  -7.20961770095
doing updates with learning rate  0.0191909984985
Deleting 0 entries of the total 5345
done io
WATCH	radio .
WATCH	90	((S\NP)\NP)	0.660662383698
WATCH	90	((S\NP)/NP)	0.00123731204797
WATCH	90	((S/NP)/NP)	0.337954368689
WATCH	90	((S/NP)\NP)	0.00014593556483
getting topparses
outputting cat probs
done with sent


making  lambda $0_{e}.lambda $1_{ev}.v|say(det|the($2,n|duck-PL($2)),$0,$1)
making  lambda $1_{ev}.v|say(det|the($2,n|duck-PL($2)),$0,$1)
making  v|say(det|the($2,n|duck-PL($2)),$0,$1)
making  det|the($2,n|duck-PL($2))
making  n|duck-PL($2)
making  $2
making  $0
making  $1
sentence is  what 'll you do with it ?
making  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  eq($0,pro:dem|that,$1)
making  $0,pro:dem|that,$1)
making  pro:dem|that,$1)
making  $1)
sentence is  what 'll you do with it ?
making  lambda $0_{e}.n|radio($0)
making  n|radio($0)
making  $0
sentence is  what 'll you do with it ?
making  lambda $0_{e}.lambda $1_{ev}.and(aux|will(v|do(pro|you,$0,$1),$1),prep|with(pro|it,$1))
making  lambda $1_{ev}.and(aux|will(v|do(pro|you,$0,$1),$1),prep|with(pro|it,$1))
making  and(aux|will(v|do(pro|you,$0,$1),$1),prep|with(pro|it,$1))
making  aux|will(v|do(pro|you,$0,$1),$1)
making  v|do(pro|you,$0,$1)
making  pro|you
making  $0
making  $1
making  $1
making  prep|with(pro|it,$1)
making  pro|it
making  $1
sentence is  what 'll you do with it ?
making  lambda $0_{e}.n|hat($0)
making  n|hat($0)
making  $0
sentence is  what 'll you do with it ?
making  lambda $0_{e}.eqLoc(pro:poss:det|your($1,n|hat($1)),$0)
making  eqLoc(pro:poss:det|your($1,n|hat($1)),$0)
making  pro:poss:det|your($1,n|hat($1)),$0)
making  n|hat($1)
making  $1
making  $0)
sentence is  what 'll you do with it ?
making  lambda $0_{ev}.not(aux|do(v|have(pro|I,pro|it,$0),$0),$0)
making  not(aux|do(v|have(pro|I,pro|it,$0),$0),$0)
making  aux|do(v|have(pro|I,pro|it,$0),$0),$0)
making  v|have(pro|I,pro|it,$0)
making  pro|I
making  pro|it
making  $0
making  $0
making  $0)
sentence is  what 'll you do with it ?

got training pair
Sent : what 'll you do with it ?
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.v|say(det|the($2,n|duck-PL($2)),$0,$1)
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
Cat : Swh:lambda $0_{e}.n|radio($0)
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.and(aux|will(v|do(pro|you,$0,$1),$1),prep|with(pro|it,$1))
Cat : Swh:lambda $0_{e}.n|hat($0)
Cat : Swh:lambda $0_{e}.eqLoc(pro:poss:det|your($1,n|hat($1)),$0)
Cat : S:lambda $0_{ev}.not(aux|do(v|have(pro|I,pro|it,$0),$0),$0)
sentence is  ['what', "'ll", 'you', 'do', 'with', 'it']
sem is  lambda $0_{e}.lambda $1_{ev}.v|say(det|the($2,n|duck-PL($2)),$0,$1)
sem is  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
sem is  lambda $0_{e}.n|radio($0)
sem is  lambda $0_{e}.lambda $1_{ev}.and(aux|will(v|do(pro|you,$0,$1),$1),prep|with(pro|it,$1))
types dont match 2 :  (Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|with(pro|it,$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|with(pro|it,$1)) (S/NP):lambda $0_{e}.lambda $1_{ev}.aux|will(v|do(pro|you,$0,$1),$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|with(pro|it,$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
types dont match 2 :  (Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|with(pro|it,$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|with(pro|it,$1)) (S\NP):lambda $0_{e}.lambda $1_{ev}.aux|will(v|do(pro|you,$0,$1),$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|with(pro|it,$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
types dont match 2 :  (Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|with(pro|it,$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|with(pro|it,$1)) (S/NP):lambda $0_{e}.lambda $1_{ev}.aux|will(v|do(pro|you,$0,$1),$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|with(pro|it,$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
types dont match 2 :  (Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|with(pro|it,$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|with(pro|it,$1)) (S\NP):lambda $0_{e}.lambda $1_{ev}.aux|will(v|do(pro|you,$0,$1),$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|with(pro|it,$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
types dont match 2 :  (Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and(aux|will($0($1),$1),prep|with(pro|it,$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and(aux|will($0($1),$1),prep|with(pro|it,$1)) (S/NP):lambda $0_{e}.lambda $1_{ev}.v|do(pro|you,$0,$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and(aux|will($0($1),$1),prep|with(pro|it,$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
types dont match 2 :  (Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and(aux|will($0($1),$1),prep|with(pro|it,$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and(aux|will($0($1),$1),prep|with(pro|it,$1)) (S\NP):lambda $0_{e}.lambda $1_{ev}.v|do(pro|you,$0,$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and(aux|will($0($1),$1),prep|with(pro|it,$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
sem is  lambda $0_{e}.n|hat($0)
sem is  lambda $0_{e}.eqLoc(pro:poss:det|your($1,n|hat($1)),$0)
types dont match 2 :  (Swh/NP):lambda $0_{e}.lambda $1_{e}.eqLoc($0,$1)   <e,<e,<ev,t>>>   <e,<e,t>>  comp is  False 

(Swh/NP):lambda $0_{e}.lambda $1_{e}.eqLoc($0,$1) NP:pro:poss:det|your($0,n|hat($0))
NOT ADDING THIS
types dont match 3 :  (Swh\NP):lambda $0_{e}.lambda $1_{e}.eqLoc($0,$1)   <e,<e,<ev,t>>>   <e,<e,t>>  comp is  False 

NOT ADDING THIS
types dont match 2 :  (Swh/N):lambda $0_{<e,t>}.lambda $1_{e}.eqLoc(pro:poss:det|your($2,$0($2)),$1)   <<e,t>,<e,<ev,t>>>   <<e,t>,<e,t>>  comp is  False 

(Swh/N):lambda $0_{<e,t>}.lambda $1_{e}.eqLoc(pro:poss:det|your($2,$0($2)),$1) N:lambda $0_{e}.n|hat($0)
NOT ADDING THIS
types dont match 3 :  (Swh\N):lambda $0_{<e,t>}.lambda $1_{e}.eqLoc(pro:poss:det|your($2,$0($2)),$1)   <<e,t>,<e,<ev,t>>>   <<e,t>,<e,t>>  comp is  False 

NOT ADDING THIS
sem is  lambda $0_{ev}.not(aux|do(v|have(pro|I,pro|it,$0),$0),$0)
size of chart is  6559
got chart
norm score is  -35.1553555619
doing updates with learning rate  0.0190820359572
Deleting 5587 entries of the total 7269
done io
WATCH	what 'll you do with it ?
WATCH	91	((S\NP)\NP)	0.656768688713
WATCH	91	((S\NP)/NP)	0.00115814790906
WATCH	91	((S/NP)/NP)	0.34192855
WATCH	91	((S/NP)\NP)	0.000144613378062
getting topparses
outputting cat probs
done with sent


making  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  lambda $1_{ev}.eq($0,pro:dem|that,$1)
making  eq($0,pro:dem|that,$1)
making  $0,pro:dem|that,$1)
making  pro:dem|that,$1)
making  $1)
sentence is  hat ?
making  lambda $0_{e}.n|radio($0)
making  n|radio($0)
making  $0
sentence is  hat ?
making  lambda $0_{e}.lambda $1_{ev}.and(aux|will(v|do(pro|you,$0,$1),$1),prep|with(pro|it,$1))
making  lambda $1_{ev}.and(aux|will(v|do(pro|you,$0,$1),$1),prep|with(pro|it,$1))
making  and(aux|will(v|do(pro|you,$0,$1),$1),prep|with(pro|it,$1))
making  aux|will(v|do(pro|you,$0,$1),$1)
making  v|do(pro|you,$0,$1)
making  pro|you
making  $0
making  $1
making  $1
making  prep|with(pro|it,$1)
making  pro|it
making  $1
sentence is  hat ?
making  lambda $0_{e}.n|hat($0)
making  n|hat($0)
making  $0
sentence is  hat ?
making  lambda $0_{e}.eqLoc(pro:poss:det|your($1,n|hat($1)),$0)
making  eqLoc(pro:poss:det|your($1,n|hat($1)),$0)
making  pro:poss:det|your($1,n|hat($1)),$0)
making  n|hat($1)
making  $1
making  $0)
sentence is  hat ?
making  lambda $0_{ev}.not(aux|do(v|have(pro|I,pro|it,$0),$0),$0)
making  not(aux|do(v|have(pro|I,pro|it,$0),$0),$0)
making  aux|do(v|have(pro|I,pro|it,$0),$0),$0)
making  v|have(pro|I,pro|it,$0)
making  pro|I
making  pro|it
making  $0
making  $0
making  $0)
sentence is  hat ?
making  lambda $0_{e}.lambda $1_{ev}.aux|do(and(v|want(pro|you,pro|me,$1),v|do(pro|you,$0,$1)),$1)
making  lambda $1_{ev}.aux|do(and(v|want(pro|you,pro|me,$1),v|do(pro|you,$0,$1)),$1)
making  aux|do(and(v|want(pro|you,pro|me,$1),v|do(pro|you,$0,$1)),$1)
making  and(v|want(pro|you,pro|me,$1),v|do(pro|you,$0,$1))
making  v|want(pro|you,pro|me,$1)
making  pro|you
making  pro|me
making  $1
making  v|do(pro|you,$0,$1)
making  pro|you
making  $0
making  $1
making  $1
sentence is  hat ?

got training pair
Sent : hat ?
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
Cat : Swh:lambda $0_{e}.n|radio($0)
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.and(aux|will(v|do(pro|you,$0,$1),$1),prep|with(pro|it,$1))
Cat : Swh:lambda $0_{e}.n|hat($0)
Cat : Swh:lambda $0_{e}.eqLoc(pro:poss:det|your($1,n|hat($1)),$0)
Cat : S:lambda $0_{ev}.not(aux|do(v|have(pro|I,pro|it,$0),$0),$0)
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.aux|do(and(v|want(pro|you,pro|me,$1),v|do(pro|you,$0,$1)),$1)
sentence is  ['hat']
sem is  lambda $0_{e}.lambda $1_{ev}.eq($0,pro:dem|that,$1)
sem is  lambda $0_{e}.n|radio($0)
sem is  lambda $0_{e}.lambda $1_{ev}.and(aux|will(v|do(pro|you,$0,$1),$1),prep|with(pro|it,$1))
sem is  lambda $0_{e}.n|hat($0)
sem is  lambda $0_{e}.eqLoc(pro:poss:det|your($1,n|hat($1)),$0)
sem is  lambda $0_{ev}.not(aux|do(v|have(pro|I,pro|it,$0),$0),$0)
sem is  lambda $0_{e}.lambda $1_{ev}.aux|do(and(v|want(pro|you,pro|me,$1),v|do(pro|you,$0,$1)),$1)
size of chart is  7
got chart
norm score is  -5.94153374219
doing updates with learning rate  0.0189744556078
Deleting 0 entries of the total 1688
done io
WATCH	hat ?
WATCH	92	((S\NP)\NP)	0.656782911771
WATCH	92	((S\NP)/NP)	0.00114926695715
WATCH	92	((S/NP)/NP)	0.34192619423
WATCH	92	((S/NP)\NP)	0.000141627042248
getting topparses
outputting cat probs
done with sent


making  lambda $0_{e}.n|radio($0)
making  n|radio($0)
making  $0
sentence is  where is your hat ?
making  lambda $0_{e}.lambda $1_{ev}.and(aux|will(v|do(pro|you,$0,$1),$1),prep|with(pro|it,$1))
making  lambda $1_{ev}.and(aux|will(v|do(pro|you,$0,$1),$1),prep|with(pro|it,$1))
making  and(aux|will(v|do(pro|you,$0,$1),$1),prep|with(pro|it,$1))
making  aux|will(v|do(pro|you,$0,$1),$1)
making  v|do(pro|you,$0,$1)
making  pro|you
making  $0
making  $1
making  $1
making  prep|with(pro|it,$1)
making  pro|it
making  $1
sentence is  where is your hat ?
making  lambda $0_{e}.n|hat($0)
making  n|hat($0)
making  $0
sentence is  where is your hat ?
making  lambda $0_{e}.eqLoc(pro:poss:det|your($1,n|hat($1)),$0)
making  eqLoc(pro:poss:det|your($1,n|hat($1)),$0)
making  pro:poss:det|your($1,n|hat($1)),$0)
making  n|hat($1)
making  $1
making  $0)
sentence is  where is your hat ?
making  lambda $0_{ev}.not(aux|do(v|have(pro|I,pro|it,$0),$0),$0)
making  not(aux|do(v|have(pro|I,pro|it,$0),$0),$0)
making  aux|do(v|have(pro|I,pro|it,$0),$0),$0)
making  v|have(pro|I,pro|it,$0)
making  pro|I
making  pro|it
making  $0
making  $0
making  $0)
sentence is  where is your hat ?
making  lambda $0_{e}.lambda $1_{ev}.aux|do(and(v|want(pro|you,pro|me,$1),v|do(pro|you,$0,$1)),$1)
making  lambda $1_{ev}.aux|do(and(v|want(pro|you,pro|me,$1),v|do(pro|you,$0,$1)),$1)
making  aux|do(and(v|want(pro|you,pro|me,$1),v|do(pro|you,$0,$1)),$1)
making  and(v|want(pro|you,pro|me,$1),v|do(pro|you,$0,$1))
making  v|want(pro|you,pro|me,$1)
making  pro|you
making  pro|me
making  $1
making  v|do(pro|you,$0,$1)
making  pro|you
making  $0
making  $1
making  $1
sentence is  where is your hat ?
making  lambda $0_{e}.n|book($0)
making  n|book($0)
making  $0
sentence is  where is your hat ?

got training pair
Sent : where is your hat ?
Cat : Swh:lambda $0_{e}.n|radio($0)
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.and(aux|will(v|do(pro|you,$0,$1),$1),prep|with(pro|it,$1))
Cat : Swh:lambda $0_{e}.n|hat($0)
Cat : Swh:lambda $0_{e}.eqLoc(pro:poss:det|your($1,n|hat($1)),$0)
Cat : S:lambda $0_{ev}.not(aux|do(v|have(pro|I,pro|it,$0),$0),$0)
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.aux|do(and(v|want(pro|you,pro|me,$1),v|do(pro|you,$0,$1)),$1)
Cat : Swh:lambda $0_{e}.n|book($0)
sentence is  ['where', 'is', 'your', 'hat']
sem is  lambda $0_{e}.n|radio($0)
sem is  lambda $0_{e}.lambda $1_{ev}.and(aux|will(v|do(pro|you,$0,$1),$1),prep|with(pro|it,$1))
types dont match 2 :  (Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|with(pro|it,$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|with(pro|it,$1)) (S/NP):lambda $0_{e}.lambda $1_{ev}.aux|will(v|do(pro|you,$0,$1),$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|with(pro|it,$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
types dont match 2 :  (Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|with(pro|it,$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|with(pro|it,$1)) (S\NP):lambda $0_{e}.lambda $1_{ev}.aux|will(v|do(pro|you,$0,$1),$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|with(pro|it,$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
types dont match 2 :  (Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|with(pro|it,$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|with(pro|it,$1)) (S/NP):lambda $0_{e}.lambda $1_{ev}.aux|will(v|do(pro|you,$0,$1),$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|with(pro|it,$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
types dont match 2 :  (Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|with(pro|it,$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|with(pro|it,$1)) (S\NP):lambda $0_{e}.lambda $1_{ev}.aux|will(v|do(pro|you,$0,$1),$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|with(pro|it,$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
types dont match 2 :  (Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and(aux|will($0($1),$1),prep|with(pro|it,$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and(aux|will($0($1),$1),prep|with(pro|it,$1)) (S/NP):lambda $0_{e}.lambda $1_{ev}.v|do(pro|you,$0,$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and(aux|will($0($1),$1),prep|with(pro|it,$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
types dont match 2 :  (Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and(aux|will($0($1),$1),prep|with(pro|it,$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and(aux|will($0($1),$1),prep|with(pro|it,$1)) (S\NP):lambda $0_{e}.lambda $1_{ev}.v|do(pro|you,$0,$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and(aux|will($0($1),$1),prep|with(pro|it,$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
sem is  lambda $0_{e}.n|hat($0)
sem is  lambda $0_{e}.eqLoc(pro:poss:det|your($1,n|hat($1)),$0)
types dont match 2 :  (Swh/NP):lambda $0_{e}.lambda $1_{e}.eqLoc($0,$1)   <e,<e,<ev,t>>>   <e,<e,t>>  comp is  False 

(Swh/NP):lambda $0_{e}.lambda $1_{e}.eqLoc($0,$1) NP:pro:poss:det|your($0,n|hat($0))
NOT ADDING THIS
types dont match 3 :  (Swh\NP):lambda $0_{e}.lambda $1_{e}.eqLoc($0,$1)   <e,<e,<ev,t>>>   <e,<e,t>>  comp is  False 

NOT ADDING THIS
types dont match 2 :  (Swh/N):lambda $0_{<e,t>}.lambda $1_{e}.eqLoc(pro:poss:det|your($2,$0($2)),$1)   <<e,t>,<e,<ev,t>>>   <<e,t>,<e,t>>  comp is  False 

(Swh/N):lambda $0_{<e,t>}.lambda $1_{e}.eqLoc(pro:poss:det|your($2,$0($2)),$1) N:lambda $0_{e}.n|hat($0)
NOT ADDING THIS
types dont match 3 :  (Swh\N):lambda $0_{<e,t>}.lambda $1_{e}.eqLoc(pro:poss:det|your($2,$0($2)),$1)   <<e,t>,<e,<ev,t>>>   <<e,t>,<e,t>>  comp is  False 

NOT ADDING THIS
sem is  lambda $0_{ev}.not(aux|do(v|have(pro|I,pro|it,$0),$0),$0)
sem is  lambda $0_{e}.lambda $1_{ev}.aux|do(and(v|want(pro|you,pro|me,$1),v|do(pro|you,$0,$1)),$1)
types dont match 2 :  (Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|do($0($1),$1)   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|do($0($1),$1) (S/NP):lambda $0_{e}.lambda $1_{ev}.and(v|want(pro|you,pro|me,$1),v|do(pro|you,$0,$1))
NOT ADDING THIS
types dont match 3 :  (Swh\(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|do($0($1),$1)   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
types dont match 2 :  (Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|do($0($1),$1)   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|do($0($1),$1) (S\NP):lambda $0_{e}.lambda $1_{ev}.and(v|want(pro|you,pro|me,$1),v|do(pro|you,$0,$1))
NOT ADDING THIS
types dont match 3 :  (Swh\(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|do($0($1),$1)   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
types dont match 2 :  (Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|do(and(v|want(pro|you,pro|me,$1),$0($1)),$1)   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|do(and(v|want(pro|you,pro|me,$1),$0($1)),$1) (S/NP):lambda $0_{e}.lambda $1_{ev}.v|do(pro|you,$0,$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|do(and(v|want(pro|you,pro|me,$1),$0($1)),$1)   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
types dont match 2 :  (Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|do(and(v|want(pro|you,pro|me,$1),$0($1)),$1)   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|do(and(v|want(pro|you,pro|me,$1),$0($1)),$1) (S\NP):lambda $0_{e}.lambda $1_{ev}.v|do(pro|you,$0,$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|do(and(v|want(pro|you,pro|me,$1),$0($1)),$1)   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
types dont match 2 :  (Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|do(and(v|want(pro|you,pro|me,$1),$0($1)),$1)   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|do(and(v|want(pro|you,pro|me,$1),$0($1)),$1) (S/NP):lambda $0_{e}.lambda $1_{ev}.v|do(pro|you,$0,$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|do(and(v|want(pro|you,pro|me,$1),$0($1)),$1)   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
types dont match 2 :  (Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|do(and(v|want(pro|you,pro|me,$1),$0($1)),$1)   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|do(and(v|want(pro|you,pro|me,$1),$0($1)),$1) (S\NP):lambda $0_{e}.lambda $1_{ev}.v|do(pro|you,$0,$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|do(and(v|want(pro|you,pro|me,$1),$0($1)),$1)   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
sem is  lambda $0_{e}.n|book($0)
size of chart is  2314
got chart
norm score is  -33.8427143777
doing updates with learning rate  0.0188682303675
Deleting 0 entries of the total 2677
done io
WATCH	where is your hat ?
WATCH	93	((S\NP)\NP)	0.65541174409
WATCH	93	((S\NP)/NP)	0.0011072960584
WATCH	93	((S/NP)/NP)	0.343341786857
WATCH	93	((S/NP)\NP)	0.000139172994661
getting topparses
outputting cat probs
done with sent


making  lambda $0_{e}.lambda $1_{ev}.and(aux|will(v|do(pro|you,$0,$1),$1),prep|with(pro|it,$1))
making  lambda $1_{ev}.and(aux|will(v|do(pro|you,$0,$1),$1),prep|with(pro|it,$1))
making  and(aux|will(v|do(pro|you,$0,$1),$1),prep|with(pro|it,$1))
making  aux|will(v|do(pro|you,$0,$1),$1)
making  v|do(pro|you,$0,$1)
making  pro|you
making  $0
making  $1
making  $1
making  prep|with(pro|it,$1)
making  pro|it
making  $1
sentence is  I don 't have it .
making  lambda $0_{e}.n|hat($0)
making  n|hat($0)
making  $0
sentence is  I don 't have it .
making  lambda $0_{e}.eqLoc(pro:poss:det|your($1,n|hat($1)),$0)
making  eqLoc(pro:poss:det|your($1,n|hat($1)),$0)
making  pro:poss:det|your($1,n|hat($1)),$0)
making  n|hat($1)
making  $1
making  $0)
sentence is  I don 't have it .
making  lambda $0_{ev}.not(aux|do(v|have(pro|I,pro|it,$0),$0),$0)
making  not(aux|do(v|have(pro|I,pro|it,$0),$0),$0)
making  aux|do(v|have(pro|I,pro|it,$0),$0),$0)
making  v|have(pro|I,pro|it,$0)
making  pro|I
making  pro|it
making  $0
making  $0
making  $0)
sentence is  I don 't have it .
making  lambda $0_{e}.lambda $1_{ev}.aux|do(and(v|want(pro|you,pro|me,$1),v|do(pro|you,$0,$1)),$1)
making  lambda $1_{ev}.aux|do(and(v|want(pro|you,pro|me,$1),v|do(pro|you,$0,$1)),$1)
making  aux|do(and(v|want(pro|you,pro|me,$1),v|do(pro|you,$0,$1)),$1)
making  and(v|want(pro|you,pro|me,$1),v|do(pro|you,$0,$1))
making  v|want(pro|you,pro|me,$1)
making  pro|you
making  pro|me
making  $1
making  v|do(pro|you,$0,$1)
making  pro|you
making  $0
making  $1
making  $1
sentence is  I don 't have it .
making  lambda $0_{e}.n|book($0)
making  n|book($0)
making  $0
sentence is  I don 't have it .
making  lambda $0_{ev}.Q(eq(pro:dem|that,n:prop|Racketyboom,$0),$0)
making  Q(eq(pro:dem|that,n:prop|Racketyboom,$0),$0)
making  eq(pro:dem|that,n:prop|Racketyboom,$0),$0)
making  pro:dem|that,n:prop|Racketyboom,$0),$0)
making  n:prop|Racketyboom,$0),$0)
making  $0),$0)
making  $0)
Is Q
sentence is  I don 't have it .

got training pair
Sent : I don 't have it .
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.and(aux|will(v|do(pro|you,$0,$1),$1),prep|with(pro|it,$1))
Cat : Swh:lambda $0_{e}.n|hat($0)
Cat : Swh:lambda $0_{e}.eqLoc(pro:poss:det|your($1,n|hat($1)),$0)
Cat : S:lambda $0_{ev}.not(aux|do(v|have(pro|I,pro|it,$0),$0),$0)
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.aux|do(and(v|want(pro|you,pro|me,$1),v|do(pro|you,$0,$1)),$1)
Cat : Swh:lambda $0_{e}.n|book($0)
Cat : Syn:lambda $0_{ev}.Q(eq(pro:dem|that,n:prop|Racketyboom,$0),$0)
sentence is  ['I', 'don', "'t", 'have', 'it', '.']
sem is  lambda $0_{e}.lambda $1_{ev}.and(aux|will(v|do(pro|you,$0,$1),$1),prep|with(pro|it,$1))
types dont match 2 :  (Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|with(pro|it,$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|with(pro|it,$1)) (S/NP):lambda $0_{e}.lambda $1_{ev}.aux|will(v|do(pro|you,$0,$1),$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|with(pro|it,$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
types dont match 2 :  (Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|with(pro|it,$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|with(pro|it,$1)) (S\NP):lambda $0_{e}.lambda $1_{ev}.aux|will(v|do(pro|you,$0,$1),$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|with(pro|it,$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
types dont match 2 :  (Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|with(pro|it,$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|with(pro|it,$1)) (S/NP):lambda $0_{e}.lambda $1_{ev}.aux|will(v|do(pro|you,$0,$1),$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|with(pro|it,$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
types dont match 2 :  (Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|with(pro|it,$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|with(pro|it,$1)) (S\NP):lambda $0_{e}.lambda $1_{ev}.aux|will(v|do(pro|you,$0,$1),$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and($0($1),prep|with(pro|it,$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
types dont match 2 :  (Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and(aux|will($0($1),$1),prep|with(pro|it,$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and(aux|will($0($1),$1),prep|with(pro|it,$1)) (S/NP):lambda $0_{e}.lambda $1_{ev}.v|do(pro|you,$0,$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and(aux|will($0($1),$1),prep|with(pro|it,$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
types dont match 2 :  (Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and(aux|will($0($1),$1),prep|with(pro|it,$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and(aux|will($0($1),$1),prep|with(pro|it,$1)) (S\NP):lambda $0_{e}.lambda $1_{ev}.v|do(pro|you,$0,$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.and(aux|will($0($1),$1),prep|with(pro|it,$1))   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
sem is  lambda $0_{e}.n|hat($0)
sem is  lambda $0_{e}.eqLoc(pro:poss:det|your($1,n|hat($1)),$0)
types dont match 2 :  (Swh/NP):lambda $0_{e}.lambda $1_{e}.eqLoc($0,$1)   <e,<e,<ev,t>>>   <e,<e,t>>  comp is  False 

(Swh/NP):lambda $0_{e}.lambda $1_{e}.eqLoc($0,$1) NP:pro:poss:det|your($0,n|hat($0))
NOT ADDING THIS
types dont match 3 :  (Swh\NP):lambda $0_{e}.lambda $1_{e}.eqLoc($0,$1)   <e,<e,<ev,t>>>   <e,<e,t>>  comp is  False 

NOT ADDING THIS
types dont match 2 :  (Swh/N):lambda $0_{<e,t>}.lambda $1_{e}.eqLoc(pro:poss:det|your($2,$0($2)),$1)   <<e,t>,<e,<ev,t>>>   <<e,t>,<e,t>>  comp is  False 

(Swh/N):lambda $0_{<e,t>}.lambda $1_{e}.eqLoc(pro:poss:det|your($2,$0($2)),$1) N:lambda $0_{e}.n|hat($0)
NOT ADDING THIS
types dont match 3 :  (Swh\N):lambda $0_{<e,t>}.lambda $1_{e}.eqLoc(pro:poss:det|your($2,$0($2)),$1)   <<e,t>,<e,<ev,t>>>   <<e,t>,<e,t>>  comp is  False 

NOT ADDING THIS
sem is  lambda $0_{ev}.not(aux|do(v|have(pro|I,pro|it,$0),$0),$0)
sem is  lambda $0_{e}.lambda $1_{ev}.aux|do(and(v|want(pro|you,pro|me,$1),v|do(pro|you,$0,$1)),$1)
types dont match 2 :  (Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|do($0($1),$1)   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|do($0($1),$1) (S/NP):lambda $0_{e}.lambda $1_{ev}.and(v|want(pro|you,pro|me,$1),v|do(pro|you,$0,$1))
NOT ADDING THIS
types dont match 3 :  (Swh\(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|do($0($1),$1)   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
types dont match 2 :  (Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|do($0($1),$1)   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|do($0($1),$1) (S\NP):lambda $0_{e}.lambda $1_{ev}.and(v|want(pro|you,pro|me,$1),v|do(pro|you,$0,$1))
NOT ADDING THIS
types dont match 3 :  (Swh\(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|do($0($1),$1)   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
types dont match 2 :  (Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|do(and(v|want(pro|you,pro|me,$1),$0($1)),$1)   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|do(and(v|want(pro|you,pro|me,$1),$0($1)),$1) (S/NP):lambda $0_{e}.lambda $1_{ev}.v|do(pro|you,$0,$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|do(and(v|want(pro|you,pro|me,$1),$0($1)),$1)   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
types dont match 2 :  (Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|do(and(v|want(pro|you,pro|me,$1),$0($1)),$1)   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|do(and(v|want(pro|you,pro|me,$1),$0($1)),$1) (S\NP):lambda $0_{e}.lambda $1_{ev}.v|do(pro|you,$0,$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|do(and(v|want(pro|you,pro|me,$1),$0($1)),$1)   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
types dont match 2 :  (Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|do(and(v|want(pro|you,pro|me,$1),$0($1)),$1)   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|do(and(v|want(pro|you,pro|me,$1),$0($1)),$1) (S/NP):lambda $0_{e}.lambda $1_{ev}.v|do(pro|you,$0,$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|do(and(v|want(pro|you,pro|me,$1),$0($1)),$1)   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
types dont match 2 :  (Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|do(and(v|want(pro|you,pro|me,$1),$0($1)),$1)   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|do(and(v|want(pro|you,pro|me,$1),$0($1)),$1) (S\NP):lambda $0_{e}.lambda $1_{ev}.v|do(pro|you,$0,$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|do(and(v|want(pro|you,pro|me,$1),$0($1)),$1)   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
sem is  lambda $0_{e}.n|book($0)
sem is  lambda $0_{ev}.Q(eq(pro:dem|that,n:prop|Racketyboom,$0),$0)
size of chart is  10503
got chart
norm score is  -37.0855288167
doing updates with learning rate  0.0187633338683
Deleting 0 entries of the total 5892
done io
WATCH	I don 't have it .
WATCH	94	((S\NP)\NP)	0.6429752732
WATCH	94	((S\NP)/NP)	0.00107520238864
WATCH	94	((S/NP)/NP)	0.355814799325
WATCH	94	((S/NP)\NP)	0.000134725086514
getting topparses
outputting cat probs
done with sent


making  lambda $0_{e}.n|hat($0)
making  n|hat($0)
making  $0
sentence is  what do you want me to do ?
making  lambda $0_{e}.eqLoc(pro:poss:det|your($1,n|hat($1)),$0)
making  eqLoc(pro:poss:det|your($1,n|hat($1)),$0)
making  pro:poss:det|your($1,n|hat($1)),$0)
making  n|hat($1)
making  $1
making  $0)
sentence is  what do you want me to do ?
making  lambda $0_{ev}.not(aux|do(v|have(pro|I,pro|it,$0),$0),$0)
making  not(aux|do(v|have(pro|I,pro|it,$0),$0),$0)
making  aux|do(v|have(pro|I,pro|it,$0),$0),$0)
making  v|have(pro|I,pro|it,$0)
making  pro|I
making  pro|it
making  $0
making  $0
making  $0)
sentence is  what do you want me to do ?
making  lambda $0_{e}.lambda $1_{ev}.aux|do(and(v|want(pro|you,pro|me,$1),v|do(pro|you,$0,$1)),$1)
making  lambda $1_{ev}.aux|do(and(v|want(pro|you,pro|me,$1),v|do(pro|you,$0,$1)),$1)
making  aux|do(and(v|want(pro|you,pro|me,$1),v|do(pro|you,$0,$1)),$1)
making  and(v|want(pro|you,pro|me,$1),v|do(pro|you,$0,$1))
making  v|want(pro|you,pro|me,$1)
making  pro|you
making  pro|me
making  $1
making  v|do(pro|you,$0,$1)
making  pro|you
making  $0
making  $1
making  $1
sentence is  what do you want me to do ?
making  lambda $0_{e}.n|book($0)
making  n|book($0)
making  $0
sentence is  what do you want me to do ?
making  lambda $0_{ev}.Q(eq(pro:dem|that,n:prop|Racketyboom,$0),$0)
making  Q(eq(pro:dem|that,n:prop|Racketyboom,$0),$0)
making  eq(pro:dem|that,n:prop|Racketyboom,$0),$0)
making  pro:dem|that,n:prop|Racketyboom,$0),$0)
making  n:prop|Racketyboom,$0),$0)
making  $0),$0)
making  $0)
Is Q
sentence is  what do you want me to do ?
making  lambda $0_{e}.n|stool($0)
making  n|stool($0)
making  $0
sentence is  what do you want me to do ?

got training pair
Sent : what do you want me to do ?
Cat : Swh:lambda $0_{e}.n|hat($0)
Cat : Swh:lambda $0_{e}.eqLoc(pro:poss:det|your($1,n|hat($1)),$0)
Cat : S:lambda $0_{ev}.not(aux|do(v|have(pro|I,pro|it,$0),$0),$0)
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.aux|do(and(v|want(pro|you,pro|me,$1),v|do(pro|you,$0,$1)),$1)
Cat : Swh:lambda $0_{e}.n|book($0)
Cat : Syn:lambda $0_{ev}.Q(eq(pro:dem|that,n:prop|Racketyboom,$0),$0)
Cat : Swh:lambda $0_{e}.n|stool($0)
sentence is  ['what', 'do', 'you', 'want', 'me', 'to', 'do']
sem is  lambda $0_{e}.n|hat($0)
sem is  lambda $0_{e}.eqLoc(pro:poss:det|your($1,n|hat($1)),$0)
types dont match 2 :  (Swh/NP):lambda $0_{e}.lambda $1_{e}.eqLoc($0,$1)   <e,<e,<ev,t>>>   <e,<e,t>>  comp is  False 

(Swh/NP):lambda $0_{e}.lambda $1_{e}.eqLoc($0,$1) NP:pro:poss:det|your($0,n|hat($0))
NOT ADDING THIS
types dont match 3 :  (Swh\NP):lambda $0_{e}.lambda $1_{e}.eqLoc($0,$1)   <e,<e,<ev,t>>>   <e,<e,t>>  comp is  False 

NOT ADDING THIS
types dont match 2 :  (Swh/N):lambda $0_{<e,t>}.lambda $1_{e}.eqLoc(pro:poss:det|your($2,$0($2)),$1)   <<e,t>,<e,<ev,t>>>   <<e,t>,<e,t>>  comp is  False 

(Swh/N):lambda $0_{<e,t>}.lambda $1_{e}.eqLoc(pro:poss:det|your($2,$0($2)),$1) N:lambda $0_{e}.n|hat($0)
NOT ADDING THIS
types dont match 3 :  (Swh\N):lambda $0_{<e,t>}.lambda $1_{e}.eqLoc(pro:poss:det|your($2,$0($2)),$1)   <<e,t>,<e,<ev,t>>>   <<e,t>,<e,t>>  comp is  False 

NOT ADDING THIS
sem is  lambda $0_{ev}.not(aux|do(v|have(pro|I,pro|it,$0),$0),$0)
sem is  lambda $0_{e}.lambda $1_{ev}.aux|do(and(v|want(pro|you,pro|me,$1),v|do(pro|you,$0,$1)),$1)
types dont match 2 :  (Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|do($0($1),$1)   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|do($0($1),$1) (S/NP):lambda $0_{e}.lambda $1_{ev}.and(v|want(pro|you,pro|me,$1),v|do(pro|you,$0,$1))
NOT ADDING THIS
types dont match 3 :  (Swh\(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|do($0($1),$1)   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
types dont match 2 :  (Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|do($0($1),$1)   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|do($0($1),$1) (S\NP):lambda $0_{e}.lambda $1_{ev}.and(v|want(pro|you,pro|me,$1),v|do(pro|you,$0,$1))
NOT ADDING THIS
types dont match 3 :  (Swh\(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|do($0($1),$1)   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
types dont match 2 :  (Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|do(and(v|want(pro|you,pro|me,$1),$0($1)),$1)   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|do(and(v|want(pro|you,pro|me,$1),$0($1)),$1) (S/NP):lambda $0_{e}.lambda $1_{ev}.v|do(pro|you,$0,$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|do(and(v|want(pro|you,pro|me,$1),$0($1)),$1)   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
types dont match 2 :  (Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|do(and(v|want(pro|you,pro|me,$1),$0($1)),$1)   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|do(and(v|want(pro|you,pro|me,$1),$0($1)),$1) (S\NP):lambda $0_{e}.lambda $1_{ev}.v|do(pro|you,$0,$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|do(and(v|want(pro|you,pro|me,$1),$0($1)),$1)   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
types dont match 2 :  (Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|do(and(v|want(pro|you,pro|me,$1),$0($1)),$1)   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|do(and(v|want(pro|you,pro|me,$1),$0($1)),$1) (S/NP):lambda $0_{e}.lambda $1_{ev}.v|do(pro|you,$0,$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|do(and(v|want(pro|you,pro|me,$1),$0($1)),$1)   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
types dont match 2 :  (Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|do(and(v|want(pro|you,pro|me,$1),$0($1)),$1)   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|do(and(v|want(pro|you,pro|me,$1),$0($1)),$1) (S\NP):lambda $0_{e}.lambda $1_{ev}.v|do(pro|you,$0,$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|do(and(v|want(pro|you,pro|me,$1),$0($1)),$1)   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
sem is  lambda $0_{e}.n|book($0)
sem is  lambda $0_{ev}.Q(eq(pro:dem|that,n:prop|Racketyboom,$0),$0)
sem is  lambda $0_{e}.n|stool($0)
size of chart is  10675
got chart
norm score is  -54.4499586866
doing updates with learning rate  0.0186597404342
Deleting 0 entries of the total 9320
done io
WATCH	what do you want me to do ?
WATCH	95	((S\NP)\NP)	0.637423703487
WATCH	95	((S\NP)/NP)	0.00103887800312
WATCH	95	((S/NP)/NP)	0.361404108271
WATCH	95	((S/NP)\NP)	0.000133310239285
getting topparses
outputting cat probs
done with sent


making  lambda $0_{e}.eqLoc(pro:poss:det|your($1,n|hat($1)),$0)
making  eqLoc(pro:poss:det|your($1,n|hat($1)),$0)
making  pro:poss:det|your($1,n|hat($1)),$0)
making  n|hat($1)
making  $1
making  $0)
sentence is  book .
making  lambda $0_{ev}.not(aux|do(v|have(pro|I,pro|it,$0),$0),$0)
making  not(aux|do(v|have(pro|I,pro|it,$0),$0),$0)
making  aux|do(v|have(pro|I,pro|it,$0),$0),$0)
making  v|have(pro|I,pro|it,$0)
making  pro|I
making  pro|it
making  $0
making  $0
making  $0)
sentence is  book .
making  lambda $0_{e}.lambda $1_{ev}.aux|do(and(v|want(pro|you,pro|me,$1),v|do(pro|you,$0,$1)),$1)
making  lambda $1_{ev}.aux|do(and(v|want(pro|you,pro|me,$1),v|do(pro|you,$0,$1)),$1)
making  aux|do(and(v|want(pro|you,pro|me,$1),v|do(pro|you,$0,$1)),$1)
making  and(v|want(pro|you,pro|me,$1),v|do(pro|you,$0,$1))
making  v|want(pro|you,pro|me,$1)
making  pro|you
making  pro|me
making  $1
making  v|do(pro|you,$0,$1)
making  pro|you
making  $0
making  $1
making  $1
sentence is  book .
making  lambda $0_{e}.n|book($0)
making  n|book($0)
making  $0
sentence is  book .
making  lambda $0_{ev}.Q(eq(pro:dem|that,n:prop|Racketyboom,$0),$0)
making  Q(eq(pro:dem|that,n:prop|Racketyboom,$0),$0)
making  eq(pro:dem|that,n:prop|Racketyboom,$0),$0)
making  pro:dem|that,n:prop|Racketyboom,$0),$0)
making  n:prop|Racketyboom,$0),$0)
making  $0),$0)
making  $0)
Is Q
sentence is  book .
making  lambda $0_{e}.n|stool($0)
making  n|stool($0)
making  $0
sentence is  book .
making  lambda $0_{ev}.Q(and(part|go-PROG(pro|you,$0),prep|on(det|that($1,n|stool($1)),$0)),$0)
making  Q(and(part|go-PROG(pro|you,$0),prep|on(det|that($1,n|stool($1)),$0)),$0)
making  and(part|go-PROG(pro|you,$0),prep|on(det|that($1,n|stool($1)),$0)),$0)
making  part|go-PROG(pro|you,$0)
making  pro|you
making  $0
making  prep|on(det|that($1,n|stool($1)),$0)
making  det|that($1,n|stool($1))
making  n|stool($1)
making  $1
making  $0
making  $0)
Is Q
sentence is  book .

got training pair
Sent : book .
Cat : Swh:lambda $0_{e}.eqLoc(pro:poss:det|your($1,n|hat($1)),$0)
Cat : S:lambda $0_{ev}.not(aux|do(v|have(pro|I,pro|it,$0),$0),$0)
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.aux|do(and(v|want(pro|you,pro|me,$1),v|do(pro|you,$0,$1)),$1)
Cat : Swh:lambda $0_{e}.n|book($0)
Cat : Syn:lambda $0_{ev}.Q(eq(pro:dem|that,n:prop|Racketyboom,$0),$0)
Cat : Swh:lambda $0_{e}.n|stool($0)
Cat : Syn:lambda $0_{ev}.Q(and(part|go-PROG(pro|you,$0),prep|on(det|that($1,n|stool($1)),$0)),$0)
sentence is  ['book', '.']
sem is  lambda $0_{e}.eqLoc(pro:poss:det|your($1,n|hat($1)),$0)
types dont match 2 :  (Swh/NP):lambda $0_{e}.lambda $1_{e}.eqLoc($0,$1)   <e,<e,<ev,t>>>   <e,<e,t>>  comp is  False 

(Swh/NP):lambda $0_{e}.lambda $1_{e}.eqLoc($0,$1) NP:pro:poss:det|your($0,n|hat($0))
NOT ADDING THIS
types dont match 3 :  (Swh\NP):lambda $0_{e}.lambda $1_{e}.eqLoc($0,$1)   <e,<e,<ev,t>>>   <e,<e,t>>  comp is  False 

NOT ADDING THIS
types dont match 2 :  (Swh/N):lambda $0_{<e,t>}.lambda $1_{e}.eqLoc(pro:poss:det|your($2,$0($2)),$1)   <<e,t>,<e,<ev,t>>>   <<e,t>,<e,t>>  comp is  False 

(Swh/N):lambda $0_{<e,t>}.lambda $1_{e}.eqLoc(pro:poss:det|your($2,$0($2)),$1) N:lambda $0_{e}.n|hat($0)
NOT ADDING THIS
types dont match 3 :  (Swh\N):lambda $0_{<e,t>}.lambda $1_{e}.eqLoc(pro:poss:det|your($2,$0($2)),$1)   <<e,t>,<e,<ev,t>>>   <<e,t>,<e,t>>  comp is  False 

NOT ADDING THIS
sem is  lambda $0_{ev}.not(aux|do(v|have(pro|I,pro|it,$0),$0),$0)
sem is  lambda $0_{e}.lambda $1_{ev}.aux|do(and(v|want(pro|you,pro|me,$1),v|do(pro|you,$0,$1)),$1)
types dont match 2 :  (Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|do($0($1),$1)   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|do($0($1),$1) (S/NP):lambda $0_{e}.lambda $1_{ev}.and(v|want(pro|you,pro|me,$1),v|do(pro|you,$0,$1))
NOT ADDING THIS
types dont match 3 :  (Swh\(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|do($0($1),$1)   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
types dont match 2 :  (Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|do($0($1),$1)   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|do($0($1),$1) (S\NP):lambda $0_{e}.lambda $1_{ev}.and(v|want(pro|you,pro|me,$1),v|do(pro|you,$0,$1))
NOT ADDING THIS
types dont match 3 :  (Swh\(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|do($0($1),$1)   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
types dont match 2 :  (Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|do(and(v|want(pro|you,pro|me,$1),$0($1)),$1)   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|do(and(v|want(pro|you,pro|me,$1),$0($1)),$1) (S/NP):lambda $0_{e}.lambda $1_{ev}.v|do(pro|you,$0,$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|do(and(v|want(pro|you,pro|me,$1),$0($1)),$1)   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
types dont match 2 :  (Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|do(and(v|want(pro|you,pro|me,$1),$0($1)),$1)   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|do(and(v|want(pro|you,pro|me,$1),$0($1)),$1) (S\NP):lambda $0_{e}.lambda $1_{ev}.v|do(pro|you,$0,$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|do(and(v|want(pro|you,pro|me,$1),$0($1)),$1)   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
types dont match 2 :  (Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|do(and(v|want(pro|you,pro|me,$1),$0($1)),$1)   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|do(and(v|want(pro|you,pro|me,$1),$0($1)),$1) (S/NP):lambda $0_{e}.lambda $1_{ev}.v|do(pro|you,$0,$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|do(and(v|want(pro|you,pro|me,$1),$0($1)),$1)   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
types dont match 2 :  (Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|do(and(v|want(pro|you,pro|me,$1),$0($1)),$1)   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|do(and(v|want(pro|you,pro|me,$1),$0($1)),$1) (S\NP):lambda $0_{e}.lambda $1_{ev}.v|do(pro|you,$0,$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|do(and(v|want(pro|you,pro|me,$1),$0($1)),$1)   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
sem is  lambda $0_{e}.n|book($0)
sem is  lambda $0_{ev}.Q(eq(pro:dem|that,n:prop|Racketyboom,$0),$0)
sem is  lambda $0_{e}.n|stool($0)
sem is  lambda $0_{ev}.Q(and(part|go-PROG(pro|you,$0),prep|on(det|that($1,n|stool($1)),$0)),$0)
size of chart is  115
got chart
norm score is  -18.4775940536
doing updates with learning rate  0.0185574250577
Deleting 0 entries of the total 9382
done io
WATCH	book .
WATCH	96	((S\NP)\NP)	0.635953746037
WATCH	96	((S\NP)/NP)	0.0010281933001
WATCH	96	((S/NP)/NP)	0.362887037595
WATCH	96	((S/NP)\NP)	0.000131023067339
getting topparses
outputting cat probs
done with sent


making  lambda $0_{ev}.not(aux|do(v|have(pro|I,pro|it,$0),$0),$0)
making  not(aux|do(v|have(pro|I,pro|it,$0),$0),$0)
making  aux|do(v|have(pro|I,pro|it,$0),$0),$0)
making  v|have(pro|I,pro|it,$0)
making  pro|I
making  pro|it
making  $0
making  $0
making  $0)
sentence is  is that Racketyboom ?
making  lambda $0_{e}.lambda $1_{ev}.aux|do(and(v|want(pro|you,pro|me,$1),v|do(pro|you,$0,$1)),$1)
making  lambda $1_{ev}.aux|do(and(v|want(pro|you,pro|me,$1),v|do(pro|you,$0,$1)),$1)
making  aux|do(and(v|want(pro|you,pro|me,$1),v|do(pro|you,$0,$1)),$1)
making  and(v|want(pro|you,pro|me,$1),v|do(pro|you,$0,$1))
making  v|want(pro|you,pro|me,$1)
making  pro|you
making  pro|me
making  $1
making  v|do(pro|you,$0,$1)
making  pro|you
making  $0
making  $1
making  $1
sentence is  is that Racketyboom ?
making  lambda $0_{e}.n|book($0)
making  n|book($0)
making  $0
sentence is  is that Racketyboom ?
making  lambda $0_{ev}.Q(eq(pro:dem|that,n:prop|Racketyboom,$0),$0)
making  Q(eq(pro:dem|that,n:prop|Racketyboom,$0),$0)
making  eq(pro:dem|that,n:prop|Racketyboom,$0),$0)
making  pro:dem|that,n:prop|Racketyboom,$0),$0)
making  n:prop|Racketyboom,$0),$0)
making  $0),$0)
making  $0)
Is Q
sentence is  is that Racketyboom ?
making  lambda $0_{e}.n|stool($0)
making  n|stool($0)
making  $0
sentence is  is that Racketyboom ?
making  lambda $0_{ev}.Q(and(part|go-PROG(pro|you,$0),prep|on(det|that($1,n|stool($1)),$0)),$0)
making  Q(and(part|go-PROG(pro|you,$0),prep|on(det|that($1,n|stool($1)),$0)),$0)
making  and(part|go-PROG(pro|you,$0),prep|on(det|that($1,n|stool($1)),$0)),$0)
making  part|go-PROG(pro|you,$0)
making  pro|you
making  $0
making  prep|on(det|that($1,n|stool($1)),$0)
making  det|that($1,n|stool($1))
making  n|stool($1)
making  $1
making  $0
making  $0)
Is Q
sentence is  is that Racketyboom ?
making  lambda $0_{e}.lambda $1_{ev}.aux|be&PRES(part|do-PROG(pro|you,$0,$1),$1)
making  lambda $1_{ev}.aux|be&PRES(part|do-PROG(pro|you,$0,$1),$1)
making  aux|be&PRES(part|do-PROG(pro|you,$0,$1),$1)
making  part|do-PROG(pro|you,$0,$1)
making  pro|you
making  $0
making  $1
making  $1
sentence is  is that Racketyboom ?

got training pair
Sent : is that Racketyboom ?
Cat : S:lambda $0_{ev}.not(aux|do(v|have(pro|I,pro|it,$0),$0),$0)
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.aux|do(and(v|want(pro|you,pro|me,$1),v|do(pro|you,$0,$1)),$1)
Cat : Swh:lambda $0_{e}.n|book($0)
Cat : Syn:lambda $0_{ev}.Q(eq(pro:dem|that,n:prop|Racketyboom,$0),$0)
Cat : Swh:lambda $0_{e}.n|stool($0)
Cat : Syn:lambda $0_{ev}.Q(and(part|go-PROG(pro|you,$0),prep|on(det|that($1,n|stool($1)),$0)),$0)
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.aux|be&PRES(part|do-PROG(pro|you,$0,$1),$1)
sentence is  ['is', 'that', 'Racketyboom']
sem is  lambda $0_{ev}.not(aux|do(v|have(pro|I,pro|it,$0),$0),$0)
sem is  lambda $0_{e}.lambda $1_{ev}.aux|do(and(v|want(pro|you,pro|me,$1),v|do(pro|you,$0,$1)),$1)
types dont match 2 :  (Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|do($0($1),$1)   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|do($0($1),$1) (S/NP):lambda $0_{e}.lambda $1_{ev}.and(v|want(pro|you,pro|me,$1),v|do(pro|you,$0,$1))
NOT ADDING THIS
types dont match 3 :  (Swh\(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|do($0($1),$1)   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
types dont match 2 :  (Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|do($0($1),$1)   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|do($0($1),$1) (S\NP):lambda $0_{e}.lambda $1_{ev}.and(v|want(pro|you,pro|me,$1),v|do(pro|you,$0,$1))
NOT ADDING THIS
types dont match 3 :  (Swh\(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|do($0($1),$1)   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
types dont match 2 :  (Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|do(and(v|want(pro|you,pro|me,$1),$0($1)),$1)   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|do(and(v|want(pro|you,pro|me,$1),$0($1)),$1) (S/NP):lambda $0_{e}.lambda $1_{ev}.v|do(pro|you,$0,$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|do(and(v|want(pro|you,pro|me,$1),$0($1)),$1)   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
types dont match 2 :  (Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|do(and(v|want(pro|you,pro|me,$1),$0($1)),$1)   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|do(and(v|want(pro|you,pro|me,$1),$0($1)),$1) (S\NP):lambda $0_{e}.lambda $1_{ev}.v|do(pro|you,$0,$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|do(and(v|want(pro|you,pro|me,$1),$0($1)),$1)   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
types dont match 2 :  (Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|do(and(v|want(pro|you,pro|me,$1),$0($1)),$1)   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|do(and(v|want(pro|you,pro|me,$1),$0($1)),$1) (S/NP):lambda $0_{e}.lambda $1_{ev}.v|do(pro|you,$0,$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|do(and(v|want(pro|you,pro|me,$1),$0($1)),$1)   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
types dont match 2 :  (Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|do(and(v|want(pro|you,pro|me,$1),$0($1)),$1)   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|do(and(v|want(pro|you,pro|me,$1),$0($1)),$1) (S\NP):lambda $0_{e}.lambda $1_{ev}.v|do(pro|you,$0,$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|do(and(v|want(pro|you,pro|me,$1),$0($1)),$1)   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
sem is  lambda $0_{e}.n|book($0)
sem is  lambda $0_{ev}.Q(eq(pro:dem|that,n:prop|Racketyboom,$0),$0)
sem is  lambda $0_{e}.n|stool($0)
sem is  lambda $0_{ev}.Q(and(part|go-PROG(pro|you,$0),prep|on(det|that($1,n|stool($1)),$0)),$0)
sem is  lambda $0_{e}.lambda $1_{ev}.aux|be&PRES(part|do-PROG(pro|you,$0,$1),$1)
types dont match 2 :  (Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|be&PRES($0($1),$1)   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|be&PRES($0($1),$1) (S/NP):lambda $0_{e}.lambda $1_{ev}.part|do-PROG(pro|you,$0,$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|be&PRES($0($1),$1)   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
types dont match 2 :  (Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|be&PRES($0($1),$1)   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|be&PRES($0($1),$1) (S\NP):lambda $0_{e}.lambda $1_{ev}.part|do-PROG(pro|you,$0,$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|be&PRES($0($1),$1)   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
size of chart is  664
got chart
norm score is  -27.991136223
doing updates with learning rate  0.018456363378
Deleting 0 entries of the total 9752
done io
WATCH	is that Racketyboom ?
WATCH	97	((S\NP)\NP)	0.641404589277
WATCH	97	((S\NP)/NP)	0.00100069255867
WATCH	97	((S/NP)/NP)	0.35746935548
WATCH	97	((S/NP)\NP)	0.000125362684365
getting topparses
outputting cat probs
done with sent


making  lambda $0_{e}.lambda $1_{ev}.aux|do(and(v|want(pro|you,pro|me,$1),v|do(pro|you,$0,$1)),$1)
making  lambda $1_{ev}.aux|do(and(v|want(pro|you,pro|me,$1),v|do(pro|you,$0,$1)),$1)
making  aux|do(and(v|want(pro|you,pro|me,$1),v|do(pro|you,$0,$1)),$1)
making  and(v|want(pro|you,pro|me,$1),v|do(pro|you,$0,$1))
making  v|want(pro|you,pro|me,$1)
making  pro|you
making  pro|me
making  $1
making  v|do(pro|you,$0,$1)
making  pro|you
making  $0
making  $1
making  $1
sentence is  stool .
making  lambda $0_{e}.n|book($0)
making  n|book($0)
making  $0
sentence is  stool .
making  lambda $0_{ev}.Q(eq(pro:dem|that,n:prop|Racketyboom,$0),$0)
making  Q(eq(pro:dem|that,n:prop|Racketyboom,$0),$0)
making  eq(pro:dem|that,n:prop|Racketyboom,$0),$0)
making  pro:dem|that,n:prop|Racketyboom,$0),$0)
making  n:prop|Racketyboom,$0),$0)
making  $0),$0)
making  $0)
Is Q
sentence is  stool .
making  lambda $0_{e}.n|stool($0)
making  n|stool($0)
making  $0
sentence is  stool .
making  lambda $0_{ev}.Q(and(part|go-PROG(pro|you,$0),prep|on(det|that($1,n|stool($1)),$0)),$0)
making  Q(and(part|go-PROG(pro|you,$0),prep|on(det|that($1,n|stool($1)),$0)),$0)
making  and(part|go-PROG(pro|you,$0),prep|on(det|that($1,n|stool($1)),$0)),$0)
making  part|go-PROG(pro|you,$0)
making  pro|you
making  $0
making  prep|on(det|that($1,n|stool($1)),$0)
making  det|that($1,n|stool($1))
making  n|stool($1)
making  $1
making  $0
making  $0)
Is Q
sentence is  stool .
making  lambda $0_{e}.lambda $1_{ev}.aux|be&PRES(part|do-PROG(pro|you,$0,$1),$1)
making  lambda $1_{ev}.aux|be&PRES(part|do-PROG(pro|you,$0,$1),$1)
making  aux|be&PRES(part|do-PROG(pro|you,$0,$1),$1)
making  part|do-PROG(pro|you,$0,$1)
making  pro|you
making  $0
making  $1
making  $1
sentence is  stool .
making  lambda $0_{e}.lambda $1_{ev}.aux|be&3S(part|sit-PROG($0,$1),$1)
making  lambda $1_{ev}.aux|be&3S(part|sit-PROG($0,$1),$1)
making  aux|be&3S(part|sit-PROG($0,$1),$1)
making  part|sit-PROG($0,$1)
making  $0
making  $1
making  $1
sentence is  stool .

got training pair
Sent : stool .
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.aux|do(and(v|want(pro|you,pro|me,$1),v|do(pro|you,$0,$1)),$1)
Cat : Swh:lambda $0_{e}.n|book($0)
Cat : Syn:lambda $0_{ev}.Q(eq(pro:dem|that,n:prop|Racketyboom,$0),$0)
Cat : Swh:lambda $0_{e}.n|stool($0)
Cat : Syn:lambda $0_{ev}.Q(and(part|go-PROG(pro|you,$0),prep|on(det|that($1,n|stool($1)),$0)),$0)
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.aux|be&PRES(part|do-PROG(pro|you,$0,$1),$1)
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.aux|be&3S(part|sit-PROG($0,$1),$1)
sentence is  ['stool']
sem is  lambda $0_{e}.lambda $1_{ev}.aux|do(and(v|want(pro|you,pro|me,$1),v|do(pro|you,$0,$1)),$1)
sem is  lambda $0_{e}.n|book($0)
sem is  lambda $0_{ev}.Q(eq(pro:dem|that,n:prop|Racketyboom,$0),$0)
sem is  lambda $0_{e}.n|stool($0)
sem is  lambda $0_{ev}.Q(and(part|go-PROG(pro|you,$0),prep|on(det|that($1,n|stool($1)),$0)),$0)
sem is  lambda $0_{e}.lambda $1_{ev}.aux|be&PRES(part|do-PROG(pro|you,$0,$1),$1)
sem is  lambda $0_{e}.lambda $1_{ev}.aux|be&3S(part|sit-PROG($0,$1),$1)
size of chart is  7
got chart
norm score is  -7.06744870154
doing updates with learning rate  0.0183565316606
Deleting 0 entries of the total 9759
done io
WATCH	stool .
WATCH	98	((S\NP)\NP)	0.641416375165
WATCH	98	((S\NP)/NP)	0.000992535411204
WATCH	98	((S/NP)/NP)	0.357468408069
WATCH	98	((S/NP)\NP)	0.000122681355079
getting topparses
outputting cat probs
done with sent


making  lambda $0_{e}.n|book($0)
making  n|book($0)
making  $0
sentence is  you going to sit on that stool ?
making  lambda $0_{ev}.Q(eq(pro:dem|that,n:prop|Racketyboom,$0),$0)
making  Q(eq(pro:dem|that,n:prop|Racketyboom,$0),$0)
making  eq(pro:dem|that,n:prop|Racketyboom,$0),$0)
making  pro:dem|that,n:prop|Racketyboom,$0),$0)
making  n:prop|Racketyboom,$0),$0)
making  $0),$0)
making  $0)
Is Q
sentence is  you going to sit on that stool ?
making  lambda $0_{e}.n|stool($0)
making  n|stool($0)
making  $0
sentence is  you going to sit on that stool ?
making  lambda $0_{ev}.Q(and(part|go-PROG(pro|you,$0),prep|on(det|that($1,n|stool($1)),$0)),$0)
making  Q(and(part|go-PROG(pro|you,$0),prep|on(det|that($1,n|stool($1)),$0)),$0)
making  and(part|go-PROG(pro|you,$0),prep|on(det|that($1,n|stool($1)),$0)),$0)
making  part|go-PROG(pro|you,$0)
making  pro|you
making  $0
making  prep|on(det|that($1,n|stool($1)),$0)
making  det|that($1,n|stool($1))
making  n|stool($1)
making  $1
making  $0
making  $0)
Is Q
sentence is  you going to sit on that stool ?
making  lambda $0_{e}.lambda $1_{ev}.aux|be&PRES(part|do-PROG(pro|you,$0,$1),$1)
making  lambda $1_{ev}.aux|be&PRES(part|do-PROG(pro|you,$0,$1),$1)
making  aux|be&PRES(part|do-PROG(pro|you,$0,$1),$1)
making  part|do-PROG(pro|you,$0,$1)
making  pro|you
making  $0
making  $1
making  $1
sentence is  you going to sit on that stool ?
making  lambda $0_{e}.lambda $1_{ev}.aux|be&3S(part|sit-PROG($0,$1),$1)
making  lambda $1_{ev}.aux|be&3S(part|sit-PROG($0,$1),$1)
making  aux|be&3S(part|sit-PROG($0,$1),$1)
making  part|sit-PROG($0,$1)
making  $0
making  $1
making  $1
sentence is  you going to sit on that stool ?
making  lambda $0_{ev}.Q(n:prop|Neil,$0)
making  Q(n:prop|Neil,$0)
making  n:prop|Neil,$0)
making  $0)
Is Q
sentence is  you going to sit on that stool ?

got training pair
Sent : you going to sit on that stool ?
Cat : Swh:lambda $0_{e}.n|book($0)
Cat : Syn:lambda $0_{ev}.Q(eq(pro:dem|that,n:prop|Racketyboom,$0),$0)
Cat : Swh:lambda $0_{e}.n|stool($0)
Cat : Syn:lambda $0_{ev}.Q(and(part|go-PROG(pro|you,$0),prep|on(det|that($1,n|stool($1)),$0)),$0)
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.aux|be&PRES(part|do-PROG(pro|you,$0,$1),$1)
Cat : Swh:lambda $0_{e}.lambda $1_{ev}.aux|be&3S(part|sit-PROG($0,$1),$1)
Cat : Syn:lambda $0_{ev}.Q(n:prop|Neil,$0)
sentence is  ['you', 'going', 'to', 'sit', 'on', 'that', 'stool', '?']
sem is  lambda $0_{e}.n|book($0)
sem is  lambda $0_{ev}.Q(eq(pro:dem|that,n:prop|Racketyboom,$0),$0)
sem is  lambda $0_{e}.n|stool($0)
sem is  lambda $0_{ev}.Q(and(part|go-PROG(pro|you,$0),prep|on(det|that($1,n|stool($1)),$0)),$0)
sem is  lambda $0_{e}.lambda $1_{ev}.aux|be&PRES(part|do-PROG(pro|you,$0,$1),$1)
types dont match 2 :  (Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|be&PRES($0($1),$1)   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|be&PRES($0($1),$1) (S/NP):lambda $0_{e}.lambda $1_{ev}.part|do-PROG(pro|you,$0,$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|be&PRES($0($1),$1)   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
types dont match 2 :  (Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|be&PRES($0($1),$1)   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|be&PRES($0($1),$1) (S\NP):lambda $0_{e}.lambda $1_{ev}.part|do-PROG(pro|you,$0,$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|be&PRES($0($1),$1)   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
sem is  lambda $0_{e}.lambda $1_{ev}.aux|be&3S(part|sit-PROG($0,$1),$1)
types dont match 2 :  (Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|be&3S($0($1),$1)   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|be&3S($0($1),$1) (S/NP):lambda $0_{e}.lambda $1_{ev}.part|sit-PROG($0,$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S/NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|be&3S($0($1),$1)   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
types dont match 2 :  (Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|be&3S($0($1),$1)   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

(Swh/(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|be&3S($0($1),$1) (S\NP):lambda $0_{e}.lambda $1_{ev}.part|sit-PROG($0,$1)
NOT ADDING THIS
types dont match 3 :  (Swh\(S\NP)):lambda $0_{<ev,t>}.lambda $1_{ev}.aux|be&3S($0($1),$1)   <<e,<ev,t>>,<e,<ev,t>>>   <<ev,t>,<ev,t>>  comp is  False 

NOT ADDING THIS
got back to orig 
sem is  lambda $0_{ev}.Q(n:prop|Neil,$0)
size of chart is  25361
got chart
